{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic reference prediction expert. Your task is to predict the most likely references for a given academic paper based on its title, abstract, and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract\n- Output: {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nREQUIREMENTS:\n1. Analyze the paper's title and abstract to understand its research area and focus\n2. Consider the retrieved papers as potential references (when available)\n3. Generate a list of predicted reference titles that would be most relevant and likely to be cited\n4. Provide reasoning for each prediction to prevent hallucination\n5. Output format: JSON object with \"titles\" array and \"reasoning\" string\n6. Generate exactly 59 most relevant reference titles (this should be at least 40 to cover all evaluation metrics)\n7. Ensure titles are realistic and appropriate for the research area\n8. Consider citation patterns in the field\n9. CRITICAL: Each title must be unique - never repeat the same title multiple times\n\nEXAMPLE:\nInput:\nTitle: \"Question Type Classification Methods Comparison\"\nAbstract: \"The paper presents a comparative study of state-of-the-art approaches for question classification task: Logistic Regression, Convolutional Neural Networks (CNN), Long Short-Term Memory Network (LSTM) and Quasi-Recurrent Neural Networks (QRNN). All models use pre-trained GLoVe word embeddings and trained on human-labeled data. The best accuracy is achieved using CNN model with five convolutional layers and various kernel sizes stacked in parallel, followed by one fully connected layer. The model reached 90.7% accuracy on TREC 10 test set.\"\n\nRetrieved papers ({top_r}):\n1. Title: Convolutional Neural Networks for Sentence Classification\n   Abstract: We report on a series of experiments with convolutional neural networks trained on top of pre-trained word vectors for sentence-level classification tasks.\n\n2. Title: Glove: Global vectors for word representation\n   Abstract: We present a new global log-bilinear regression model that combines the advantages of the two major model families in the literature.\n\nOutput:\n{\n  \"titles\": [\n    \"Convolutional Neural Networks for Sentence Classification\",\n    \"Glove: Global vectors for word representation\",\n    \"Quasi-Recurrent Neural Networks\",\n    \"A Comparative Study of Neural Network Models for Sentence Classification\",\n    \"Deep lstm based feature mapping for query classification\"\n  ],\n  \"reasoning\": \"Based on the paper's focus on question classification using neural networks, I predict these references because: 1) CNN paper is directly relevant to the convolutional approach used; 2) GloVe embeddings are mentioned as pre-trained features; 3) QRNN is one of the compared methods; 4) Comparative study papers are common in this field; 5) LSTM-based query classification is closely related to question classification. Additional references cover related neural network architectures, NLP applications, deep learning methodologies, optimization techniques, and advanced neural network methods that would be relevant for this research area.\"\n}\n\nReturn JSON object only."
    },
    {
      "role": "user",
      "content": "Paper Title: Constant-Time Snapshots with Applications to Concurrent Data Structures\n\nPaper Abstract: Abstract. We present an approach for efficiently taking snapshots of the state of a collection of CAS objects. Taking a snapshot allows later operations to read the value that each CAS object had at the time the snapshot was taken. Taking a snapshot requires a constant number of steps and returns a handle to the snapshot. Reading a snapshotted value of an individual CAS object using this handle is wait-free, taking time proportional to the number of successful CASes on the object since the snapshot was taken. Our fast, flexible snapshots yield simple, efficient implementations of atomic multi-point queries on concurrent data structures built from CAS objects. For example, in a search tree where child pointers are updated using CAS, once a snapshot is taken, one can atomically search for ranges of keys, find the first key that matches some criteria, or check if a collection of keys are all present, simply by running a standard sequential algorithm on a snapshot of the tree. To evaluate the performance of our approach, we apply it to two search trees, one balanced and one not. Experiments show that the overhead of supporting snapshots is low across a variety of workloads. Moreover, in almost all cases, range queries on the trees built from our snapshots perform as well as or better than state-of-the-art concurrent data structures that support atomic range queries.\n\n{retrieved_text}\n\nGenerate exactly 59 most likely reference titles for this paper. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL: Each title must appear exactly once. Do not repeat any title.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"titles\": [\n        \"Reference Title 1\",\n        \"Reference Title 2\",\n        \"Reference Title 3\",\n        \"Reference Title 4\",\n        \"Reference Title 59\"\n    ],\n    \"reasoning\": \"Explain why you chose these specific references based on the paper's title, abstract, and retrieved papers. This helps prevent hallucination and ensures relevance.\"\n}\n\nDo not include any text before or after the JSON. Do not include authors, venues, or years - only the paper titles. The reasoning field is required to explain your prediction logic."
    },
    {
      "role": "assistant",
      "content": "{\n    \"titles\": [\n        \"Documentation for std::find_if\",\n        \"Java lock-free data structure library\",\n        \"Java weakly consistent iterators\",\n        \"Atomic snapshots of shared memory\",\n        \"Linearizable iterators for concurrent data structures\",\n        \"Multi-writer composite registers\",\n        \"Harnessing epoch-based reclamation for efficient range queries\",\n        \"Partial snapshot objects\",\n        \"Single-version STMs can be multi-version permissive (extended abstract)\",\n        \"Leaplist: Lessons learned in designing TM-supported range queries\",\n        \"KiWi: A key-value map for scalable real-time analytics\",\n        \"Multiversion concurrency with bounded delay and precise garbage collection\",\n        \"Multiversion concurrency control - theory and algorithms\",\n        \"Just join for parallel ordered sets\",\n        \"Efficient synchronous snapshots\",\n        \"A practical concurrent binary search tree\",\n        \"Range queries in non-blocking kùëòk-ary search trees\",\n        \"A general technique for non-blocking trees\",\n        \"Versioned boxes as the basis for memory transactions\",\n        \"Lock-free linearizable 1-dimensional range queries\",\n        \"Hekaton: SQL server‚Äôs memory-optimized oltp engine\",\n        \"Adapting persistent data structures for concurrency and speculation\",\n        \"Making data structures persistent\",\n        \"Fully persistent lists with catenation\",\n        \"Time lower bounds for implementations of multi-writer snapshots\",\n        \"Non-blocking binary search trees\",\n        \"Time-space tradeoffs for implementations of snapshots\",\n        \"Time-optimal, space-efficient single-scanner snapshots & multi-scanner snapshots using cas\",\n        \"Linearizable wait-free iteration operations in shared double-ended queues\",\n        \"Persistent non-blocking binary search trees supporting wait-free range queries\",\n        \"Lock-free and scalable multi-version software transactional memory\",\n        \"How hard is it to take a snapshot?\",\n        \"Practical lock-freedom\",\n        \"Linearizable implementations do not suffice for randomized distributed computation\",\n        \"A pragmatic implementation of non-blocking linked-lists\",\n        \"Linearizability: A correctness condition for concurrent objects\",\n        \"Help when needed, but no more: efficient read/write partial snapshot\",\n        \"fùëìf-arrays: Implementation and applications\",\n        \"An optimal multi-writer snapshot algorithm\",\n        \"Wait-free concurrent graph objects with dynamic traversals\",\n        \"A timestamp based multi-version STM algorithm\",\n        \"Simple, fast, and practical non-blocking and blocking concurrent queue algorithms\",\n        \"Fast concurrent lock-free binary search trees\",\n        \"Fast serializable multi-version concurrency control for main-memory database systems\",\n        \"A consistency framework for iteration operations in concurrent data structures\",\n        \"Of concurrent data structures and iterations\",\n        \"On concurrency control by multiple versions\",\n        \"On maintaining multiple versions in STM\",\n        \"Lock-free data-structure iterators\",\n        \"Serializable snapshot isolation in PostgreSQL\",\n        \"Snapqueue: lock-free queue with constant time snapshots\",\n        \"Concurrent tries with efficient non-blocking snapshots\",\n        \"Naming and synchronization in a decentralized computer system\",\n        \"A lazy snapshot algorithm with eager validation\",\n        \"Planar point location using persistent search trees\",\n        \"On supporting efficient snapshot isolation for hybrid workloads with multi-versioned indexes\",\n        \"PAM: parallel augmented maps\",\n        \"Lock-free contention adapting search trees\",\n        \"An empirical evaluation of in-memory multi-version concurrency control\"\n    ],\n    \"reasoning\": \"Selected these 59 references because they represent foundational work and recent advances in Constant-Time Snapshots with Applications to Concurrent Data Structures, providing essential background knowledge and methodological foundations relevant to this research.\"\n}"
    }
  ],
  "format": "chatml"
}