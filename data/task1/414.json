{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic reference prediction expert. Your task is to predict the most likely references for a given academic paper based on its title, abstract, and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract\n- Output: {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nREQUIREMENTS:\n1. Analyze the paper's title and abstract to understand its research area and focus\n2. Consider the retrieved papers as potential references (when available)\n3. Generate a list of predicted reference titles that would be most relevant and likely to be cited\n4. Provide reasoning for each prediction to prevent hallucination\n5. Output format: JSON object with \"titles\" array and \"reasoning\" string\n6. Generate exactly 50 most relevant reference titles (this should be at least 40 to cover all evaluation metrics)\n7. Ensure titles are realistic and appropriate for the research area\n8. Consider citation patterns in the field\n9. CRITICAL: Each title must be unique - never repeat the same title multiple times\n\nEXAMPLE:\nInput:\nTitle: \"Question Type Classification Methods Comparison\"\nAbstract: \"The paper presents a comparative study of state-of-the-art approaches for question classification task: Logistic Regression, Convolutional Neural Networks (CNN), Long Short-Term Memory Network (LSTM) and Quasi-Recurrent Neural Networks (QRNN). All models use pre-trained GLoVe word embeddings and trained on human-labeled data. The best accuracy is achieved using CNN model with five convolutional layers and various kernel sizes stacked in parallel, followed by one fully connected layer. The model reached 90.7% accuracy on TREC 10 test set.\"\n\nRetrieved papers ({top_r}):\n1. Title: Convolutional Neural Networks for Sentence Classification\n   Abstract: We report on a series of experiments with convolutional neural networks trained on top of pre-trained word vectors for sentence-level classification tasks.\n\n2. Title: Glove: Global vectors for word representation\n   Abstract: We present a new global log-bilinear regression model that combines the advantages of the two major model families in the literature.\n\nOutput:\n{\n  \"titles\": [\n    \"Convolutional Neural Networks for Sentence Classification\",\n    \"Glove: Global vectors for word representation\",\n    \"Quasi-Recurrent Neural Networks\",\n    \"A Comparative Study of Neural Network Models for Sentence Classification\",\n    \"Deep lstm based feature mapping for query classification\"\n  ],\n  \"reasoning\": \"Based on the paper's focus on question classification using neural networks, I predict these references because: 1) CNN paper is directly relevant to the convolutional approach used; 2) GloVe embeddings are mentioned as pre-trained features; 3) QRNN is one of the compared methods; 4) Comparative study papers are common in this field; 5) LSTM-based query classification is closely related to question classification. Additional references cover related neural network architectures, NLP applications, deep learning methodologies, optimization techniques, and advanced neural network methods that would be relevant for this research area.\"\n}\n\nReturn JSON object only."
    },
    {
      "role": "user",
      "content": "Paper Title: A Symbolic Approach to Proving Query Equivalence Under Bag Semantics\n\nPaper Abstract: Abstract In database-as-a-service platforms, automated verification of query equivalence helps eliminate redundant computation in the form of overlapping sub-queries. Researchers have proposed two pragmatic techniques to tackle this problem. The first approach consists of reducing the queries to algebraic expressions and proving their equivalence using an algebraic theory. The limitations of this technique are threefold. It cannot prove the equivalence of queries with significant differences in the attributes of their relational operators (e.g., predicates in the filter operator). It does not support certain widely-used SQL features (e.g., NULL values). Its verification procedure is computationally intensive. The second approach transforms this problem to a constraint satisfaction problem and leverages a general-purpose solver to determine query equivalence. This technique consists of deriving the symbolic representation of the queries and proving their equivalence by determining the query containment relationship between the symbolic expressions. While the latter approach addresses all the limitations of the former technique, it only proves the equivalence of queries under set semantics (i.e., output tables must not contain duplicate tuples). However, in practice, database applications use bag semantics (i.e., output tables may contain duplicate tuples) In this paper, we introduce a novel symbolic approach for proving query equivalence under bag semantics. We transform the problem of proving query equivalence under bag semantics to that of proving the existence of a bijective, identity map between tuples returned by the queries on all valid inputs. We classify SQL queries into four categories, and propose a set of novel category-specific verification algorithms. We implement this symbolic approach in SPES and demonstrate that SPES proves the equivalence of a larger set of query pairs (95/232) under bag semantics compared to the state-of-the-art tools based on algebraic (30/232) and symbolic approaches (67/232) under set and bag semantics, respectively. Furthermore, SPES is 3Ã—\\times faster than the symbolic tool that proves equivalence under set semantics.\n\n{retrieved_text}\n\nGenerate exactly 50 most likely reference titles for this paper. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL: Each title must appear exactly once. Do not repeat any title.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"titles\": [\n        \"Reference Title 1\",\n        \"Reference Title 2\",\n        \"Reference Title 3\",\n        \"Reference Title 4\",\n        \"Reference Title 50\"\n    ],\n    \"reasoning\": \"Explain why you chose these specific references based on the paper's title, abstract, and retrieved papers. This helps prevent hallucination and ensures relevance.\"\n}\n\nDo not include any text before or after the JSON. Do not include authors, venues, or years - only the paper titles. The reasoning field is required to explain your prediction logic."
    },
    {
      "role": "assistant",
      "content": "{\n    \"titles\": [\n        \"Alibaba MaxCompute\",\n        \"Ant Financial Services Group\",\n        \"Apache Calcite project\",\n        \"Apache Drill project\",\n        \"Apache Flink project\",\n        \"Apache Hive project\",\n        \"Apache Kylin project\",\n        \"Apache Phoenix project\",\n        \"Azure Data Lake\",\n        \"Cosette: An automated SQL solver\",\n        \"Google BigQuery\",\n        \"Z3prover: Z3 theorem prover\",\n        \"Query-aware test generation using a relational constraint solver\",\n        \"Foundations of databases: the logical level\",\n        \"Equivalence among relational expressions\",\n        \"Algebraic properties of bag data types\",\n        \"Selecting subexpressions to materialize at datacenter scale\",\n        \"Impossibility of an algorithm for the decision problem in finite classes\",\n        \"Conjunctive query containment and answering under description logic constraints\",\n        \"Optimal implementation of conjunctive queries in relational data bases\",\n        \"Conjunctive query containment revisited\",\n        \"Demonstration of the Cosette automated sql prover\",\n        \"Axiomatic foundations and algorithms for deciding semantic equivalences of sql queries\",\n        \"Cosette: An automated SQL prover\",\n        \"HoTTSQL: proving query rewrites with univalent sql semantics\",\n        \"Deciding equivalences among conjunctive aggregate queries\",\n        \"Rewriting aggregate queries using views\",\n        \"On the decidability of query containment under constraints\",\n        \"Satisfiability modulo theories: Introduction and applications\",\n        \"Z3: an efficient SMT solver\",\n        \"The chase revisited\",\n        \"Physical data independence, constraints, and optimization with universal plans\",\n        \"Optimizing queries using materialized views: A practical, scalable solution\",\n        \"Verifying equivalence of spark programs\",\n        \"A formal semantics of sql queries, its validation, and applications\",\n        \"How to decide query containment under constraints using a description logic\",\n        \"Containment of conjunctive queries: Beyond relations as sets\",\n        \"On the automated verification of web applications with embedded sql\",\n        \"The containment problem for real conjunctive queries with inequalities\",\n        \"Conjunctive-query containment and constraint satisfaction\",\n        \"Formal semantics of sql queries\",\n        \"A chase too far?\",\n        \"A scalable algorithm for answering queries using views\",\n        \"Equivalences among relational expressions with the union and difference operators\",\n        \"An equational chase for path-conjunctive queries, constraints, and views\",\n        \"Symbolic query exploration\",\n        \"Qex: Symbolic sql query explorer\",\n        \"Verifying equivalence of database-driven applications\",\n        \"Generating application-specific data layouts for in-memory databases\",\n        \"Automated verification of query equivalence using satisfiability modulo theories\"\n    ],\n    \"reasoning\": \"Selected these 50 references because they represent foundational work and recent advances in A Symbolic Approach to Proving Query Equivalence Under Bag Semantics, providing essential background knowledge and methodological foundations relevant to this research.\"\n}"
    }
  ],
  "format": "chatml"
}