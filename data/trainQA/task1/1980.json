{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic reference prediction expert. Your task is to predict the most likely references for a given academic paper based on its title, abstract, and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract\n- Output: {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nREQUIREMENTS:\n1. Analyze the paper's title and abstract to understand its research area and focus\n2. Consider the retrieved papers as potential references (when available)\n3. Generate a list of predicted reference titles that would be most relevant and likely to be cited\n4. Provide reasoning for each prediction to prevent hallucination\n5. Output format: JSON object with \"titles\" array and \"reasoning\" string\n6. Generate exactly 54 most relevant reference titles (this should be at least 40 to cover all evaluation metrics)\n7. Ensure titles are realistic and appropriate for the research area\n8. Consider citation patterns in the field\n9. CRITICAL: Each title must be unique - never repeat the same title multiple times\n\nEXAMPLE:\nInput:\nTitle: \"Question Type Classification Methods Comparison\"\nAbstract: \"The paper presents a comparative study of state-of-the-art approaches for question classification task: Logistic Regression, Convolutional Neural Networks (CNN), Long Short-Term Memory Network (LSTM) and Quasi-Recurrent Neural Networks (QRNN). All models use pre-trained GLoVe word embeddings and trained on human-labeled data. The best accuracy is achieved using CNN model with five convolutional layers and various kernel sizes stacked in parallel, followed by one fully connected layer. The model reached 90.7% accuracy on TREC 10 test set.\"\n\nRetrieved papers ({top_r}):\n1. Title: Convolutional Neural Networks for Sentence Classification\n   Abstract: We report on a series of experiments with convolutional neural networks trained on top of pre-trained word vectors for sentence-level classification tasks.\n\n2. Title: Glove: Global vectors for word representation\n   Abstract: We present a new global log-bilinear regression model that combines the advantages of the two major model families in the literature.\n\nOutput:\n{\n  \"titles\": [\n    \"Convolutional Neural Networks for Sentence Classification\",\n    \"Glove: Global vectors for word representation\",\n    \"Quasi-Recurrent Neural Networks\",\n    \"A Comparative Study of Neural Network Models for Sentence Classification\",\n    \"Deep lstm based feature mapping for query classification\"\n  ],\n  \"reasoning\": \"Based on the paper's focus on question classification using neural networks, I predict these references because: 1) CNN paper is directly relevant to the convolutional approach used; 2) GloVe embeddings are mentioned as pre-trained features; 3) QRNN is one of the compared methods; 4) Comparative study papers are common in this field; 5) LSTM-based query classification is closely related to question classification. Additional references cover related neural network architectures, NLP applications, deep learning methodologies, optimization techniques, and advanced neural network methods that would be relevant for this research area.\"\n}\n\nReturn JSON object only."
    },
    {
      "role": "user",
      "content": "Paper Title: ControlFlag: A Self-Supervised Idiosyncratic Pattern Detection System for Software Control Structures\n\nPaper Abstract: Abstract. Software debugging has been shown to utilize upwards of half of developers’ time. Yet, machine programming (MP), the field concerned with the automation of software (and hardware) development, has recently made strides in both research and production-quality automated debugging systems. In this paper we present ControlFlag, a self-supervised MP system that aims to improve debugging by attempting to detect idiosyncratic pattern violations in software control structures. ControlFlag also suggests possible corrections in the event an anomalous pattern is detected. We present ControlFlag’s design and provide an experimental evaluation and analysis of its efficacy in identifying potential programming errors in production-quality software. As a first concrete evidence towards improving software quality, ControlFlag has already found an anomaly in CURL that has been acknowledged and fixed by its developers. We also discuss future extensions of ControlFlag.\n\n{retrieved_text}\n\nGenerate exactly 54 most likely reference titles for this paper. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL: Each title must appear exactly once. Do not repeat any title.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"titles\": [\n        \"Reference Title 1\",\n        \"Reference Title 2\",\n        \"Reference Title 3\",\n        \"Reference Title 4\",\n        \"Reference Title 54\"\n    ],\n    \"reasoning\": \"Explain why you chose these specific references based on the paper's title, abstract, and retrieved papers. This helps prevent hallucination and ensures relevance.\"\n}\n\nDo not include any text before or after the JSON. Do not include authors, venues, or years - only the paper titles. The reasoning field is required to explain your prediction logic."
    },
    {
      "role": "assistant",
      "content": "{\n    \"titles\": [\n        \"Mining API Error-handling Specifications from Source Code\",\n        \"A zero-positive learning approach for diagnosing software performance regressions\",\n        \"Mining Semantic Loop Idioms\",\n        \"Learning to Represent Programs with Graphs\",\n        \"Mining Idioms from Source Code\",\n        \"AI Programmer: Autonomously Creating Software Programs Using Genetic Algorithms\",\n        \"Automated Correction for Syntax Errors in Programming Assignments Using Recurrent Neural Networks\",\n        \"Reversible Debugging Software — Quantify the Time and Cost Saved Using Reversible Debuggers\",\n        \"Learned Garbage Collection\",\n        \"Introduction to Algorithms, Third Edition\",\n        \"http_proxy: Use Enum with State Names for ‘keepon’\",\n        \"Re: Potential Confusion in http_proxy.c and a Recommendation\",\n        \"A Language-Parametric Modular Framework for Mining Idiomatic Code Patterns\",\n        \"Hoppity: Learning Graph Transformations to Detect and Fix Bugs in Programs\",\n        \"An Abstraction-Based Framework for Neural Network Verification\",\n        \"A Critique of Software Defect Prediction Models\",\n        \"Parameter-free Probabilistic API Mining Across GitHub\",\n        \"Feedback-Driven Semi-Supervised Synthesis of Program Transformations\",\n        \"SymSpell\",\n        \"Concurrent Predicates: A Debugging Technique for Every Parallel Programmer\",\n        \"The Three Pillars of Machine Programming\",\n        \"Visualizing Transactional Memory\",\n        \"Automated program repair\",\n        \"Synthesize, Execute and Debug: Learning to Repair for Neural Program Synthesis\",\n        \"Extracting instruction semantics via symbolic execution of code generators\",\n        \"Lifting assembly to intermediate representation: A novel approach leveraging compilers\",\n        \"Learning Programmatic Idioms for Scalable Semantic Parsing\",\n        \"Code Template Inference Using Language Models\",\n        \"Verified Lifting of Stencil Computations\",\n        \"Dynamine: Finding Common Error Patterns by Mining Software Revision Histories\",\n        \"Mining Source Code for Structural Regularities\",\n        \"Aroma: Code Recommendation via Structural Code Search\",\n        \"Learning Fitness Functions for Machine Programming\",\n        \"Graph-based Mining of Multiple Object Usage Patterns\",\n        \"Guided Pattern Mining for API Misuse Detection by Change-Based Code Analysis\",\n        \"How to Write a Spelling Corrector\",\n        \"Learning to Represent Programs with Property Signatures\",\n        \"Finding Idioms in Source Code Using Subtree Counting Techniques\",\n        \"Predictive Locality Optimization for Higher-Order Tensor Computations\",\n        \"Mining Patterns in Source Code Using Tree Mining Algorithms\",\n        \"DeepBugs: A Learning Approach to Name-Based Bug Detection\",\n        \"MLSys: The New Frontier of Machine Learning Systems\",\n        \"Program Synthesis and Semantic Parsing with Learned Code Idioms\",\n        \"Automatically Identifying Code Features for Software Defect Prediction: Using AST N-grams\",\n        \"Standard Gotchas Subtleties in the Verilog and System Verilog Standards that Every Engineer Should Know\",\n        \"Pythia: AI-Assisted Code Completion System\",\n        \"Parseweb: A Programmer Assistant for Reusing Open Source Code on the Web\",\n        \"An Incremental Parsing System for Programming Tools\",\n        \"Neural Program Repair by Jointly Learning to Localize and Repair\",\n        \"Mining Temporal Specifications for Error Detection\",\n        \"MAPO: Mining API Usages from Open Source Repositories\",\n        \"Graph-based, Self-supervised Program Repair from Diagnostic Feedback\",\n        \"MISIM: An End-to-End Neural Code Similarity System\",\n        \"Efficiently Mining Frequent Trees in a Forest: Algorithms and Applications\"\n    ],\n    \"reasoning\": \"Selected these 54 references because they represent foundational work and recent advances in ControlFlag: A Self-Supervised Idiosyncratic Pattern Detection System for Software Control Structures, providing essential background knowledge and methodological foundations relevant to this research.\"\n}"
    }
  ],
  "format": "chatml"
}