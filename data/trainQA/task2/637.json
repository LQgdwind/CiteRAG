{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: Local Certification of Graphs with Bounded Genus\n\nPaper Abstract: \n\nPaper Section Text:\nThe paper considers the standard setting of distributed network computing, in which processing elements are nodes of a network modeled as a simple connected graph G=(V,E)ğºğ‘‰ğ¸G=(V,E), and the nodes exchange information along the links of that network (see, e.g.,Â ). As for centralized computing, distributed algorithms often assume promises on their inputs, and many algorithms are designed for specific families of graphs, including regular graphs, planar graphs, graphs with bounded arboricity, bipartite graphs, graphs with bounded treewidth, etc. Distributed decision refers to the problem of checking that the actual input graph (i.e., the network itself) satisfies a given predicate. One major objective of the check up is avoiding erroneous behaviors such as livelocks or deadlocks resulting from running an algorithm dedicated to a specific graph family on a graph that does not belong to this family. The decision rule typically specifies that, if the predicate is satisfied, then all nodes must accept, and otherwise at least one node must reject. A single rejecting node can indeed trigger an alarm (in, e.g., hardwired networks), or launch a recovery procedure (in, e.g., virtual networks such as overlay networks). The main goal of distributed decision is to design efficient checking protocols, that is, protocols where every node exchange information with nodes in its vicinity only, and where the nodes exchange a small volume of information between neighbors. Some graph predicate are trivial to check locally (e.g., regular graphs), but others do not admit local decision algorithms. For instance, deciding whether the network is bipartite may require long-distance communication for detecting the presence of an odd cycle. Proof-labeling schemesÂ  provide a remedy to this issue. These mechanisms have a flavor of NP-computation, but in the distributed setting. That is, a non-trustable oracle provides each node with a certificate, and the collection of certificates is supposed to be a distributed proof that the graph satisfies the given predicate. The nodes check locally the correctness of the proof. The specification of a proof-labeling scheme for a given predicate is that, if the predicate is satisfied, then there must exist a certificate assignment leading all nodes to accept, and, otherwise, for every certificate assignment, at least one node rejects. As an example, for the case of the bipartiteness predicate, if the graph is bipartite, then an oracle can color blue the nodes of one of the partition, and color red the nodes of the other partition. It is then sufficient for each node to locally check that all its neighbors have the same color, different from its own color, and to accept or reject accordingly. Indeed, if the graph is not bipartite, then there is no way that a dishonest oracle can fool the nodes, and make them all accept the graph. Interestingly, the certificates provided to the nodes by the oracle can often be computed by the nodes themselves, at low cost, during some pre-computation. For instance, a spanning tree construction algorithm is usually simply asked to encode the tree Tğ‘‡T locally at each nodeÂ vğ‘£v, say by a pointer pâ€‹(v)ğ‘ğ‘£p(v) to the parent of vğ‘£v in the tree. However, it is possible to ask the algorithm to also provide a distributed proof that Tğ‘‡T is a spanning tree. Such a proof may be encoded distributedly by providing each node with a certificate containing, e.g., the ID of the root ofÂ Tğ‘‡T, and the distance dâ€‹(v)ğ‘‘ğ‘£d(v) from vğ‘£v to the root (see, e.g., [ref]2  ). Indeed, every nodeÂ vğ‘£v but the root can simply check that dâ€‹(pâ€‹(v))=dâ€‹(v)âˆ’1ğ‘‘ğ‘ğ‘£ğ‘‘ğ‘£1d(p(v))=d(v)-1 (to guarantee the absence of cycles), and that it was given the same root-ID as all its neighbors in the network (for guaranteeing the unicity of the tree). The good news is that all (Turing-decidable) predicates on graphs admit a proof-labeling schemeÂ . The bad news is that there are simple graphs properties (e.g., existence of a non-trivial automorphismÂ , non 3-colorabilityÂ , bounded diameterÂ , etc.) which require certificates on Î©~â€‹(n2)~Î©superscriptğ‘›2\\widetilde{\\Omega}(n^{2}) bits in nğ‘›n-node graphs. Such huge certificates do not fit with the requirement that checking algorithms must not only be local, but they must also consume little bandwidth. Randomized proof-labeling schemesÂ  enable to limit the bandwidth consumption, but this is often to the cost of increasing the space-complexity of the nodes. However, motivated by cloud computing, which may provide large-scale distributed systems with the ability to interact with an external party, Kol, Oshman, and SaxenaÂ  introduced the notion of distributed interactive protocols. In such protocols, a centralized non-trustable oracle with unlimited computation power (a.k.a.Â Merlin) exchanges messages with a randomized distributed algorithm (a.k.a.Â Arthur). Specifically, Arthur and Merlin perform a sequence of exchanges during which every node queries the oracle by sending a random bit-string, and the oracle replies to each node by sending a bit-string called proof. Neither the random strings nor the proofs need to be the same for each node. After a certain number of rounds, every node exchange information with its neighbors in the network, and decides (i.e., it outputs accept or reject). It was proved that many predicate requiring large certificate whenever using proof-labeling schemes, including the existence of a non-trivial automorphism, have distributed interactive protocols with proofs on Oâ€‹(logâ¡n)ğ‘‚ğ‘›O(\\log n) bitsÂ . Naor, Parter, and YogevÂ  recently designed a compiler for automatically translating standard centralized interactive protocols to distributed interactive protocols. In particular, by using this compiler, every linear-time algorithm for deciding the membership to some fixed graph class can be translated into a ğ–½ğ–¬ğ– ğ–¬â€‹(Oâ€‹(logâ¡n))ğ–½ğ–¬ğ– ğ–¬ğ‘‚ğ‘›\\mathsf{dMAM}(O(\\log n)) protocol, that is, a distributed interactive protocol with Oâ€‹(logâ¡n)ğ‘‚ğ‘›O(\\log n)-bit proof size in nğ‘›n-node graphs, and three interactions between Merlin and Arthur: Merlin provides every node with a first part of the proof, on Oâ€‹(logâ¡n)ğ‘‚ğ‘›O(\\log n) bits, then every node challenges Merlin with a random bit-string on Oâ€‹(logâ¡n)ğ‘‚ğ‘›O(\\log n) bits, and finally Merlin replies to every node with the second part of the proof, again on Oâ€‹(logâ¡n)ğ‘‚ğ‘›O(\\log n) bits. As a corollary, there is a ğ–½ğ–¬ğ– ğ–¬â€‹(Oâ€‹(logâ¡n))ğ–½ğ–¬ğ– ğ–¬ğ‘‚ğ‘›\\mathsf{dMAM}(O(\\log n)) protocol for many graph classes, including planar graphs, graphs with bounded genus, graphs with bounded treewidth, etc. Although the compiler inÂ  is quite generic and powerful, it remains that the practical implementation of distributed interactive protocols may be complex, in particular for the ones based on several interactions between Merlin and Arthur. This raises the question of whether there exist protocols based on fewer interactions for the aforementioned classes of graphs, while keeping the proof size small (e.g., on Oâ€‹(polylogâ€‹n)ğ‘‚polylogğ‘›O(\\mathrm{polylog\\,}n) bits). Note that, with this objective in mind, proof-labeling schemes are particularly desirable as they do not require actual interactions. Indeed, as mentioned before, the certificates may often be constructed a priori by the nodes themselves. Unfortunately, under the current knowledge, establishing lower bounds on the number of interactions between the prover Merlin and the distributed verifier Arthur, as well as lower bounds on the proof size, not to speak about tradeoffs between these two complexity measures, remains challenging. Therefore, it is not known whether ğ–½ğ–¬ğ– ğ–¬â€‹(Oâ€‹(logâ¡n))ğ–½ğ–¬ğ– ğ–¬ğ‘‚ğ‘›\\mathsf{dMAM}(O(\\log n)) protocols are the best that can be achieved for graph classes such as graphs with bounded genus, or graphs with bounded treewidth. In this paper, we focus on the class of graphs with bounded genus, for several reasons. First, this class is among the prominent representative of sparse graphsÂ , and the design of fast algorithms for sparse graphs is not only of the utmost interest for centralized, but also for distributed computing (see, e.g.,\n   [ref]15    4 5 ),\nas many real-world physical or logical networks are sparse. Second, graphs of bounded genus, including planar graphs, have attracted lots of attention recently in the distributed computing framework (see, e.g.,\n  ),\nand it was shown that this large class of graphs enjoys distributed exact or approximation algorithms that overcome several known lower bounds for general graphsÂ 3 4 6. Last but not least, it appears that the graph classes for which proof-labeling schemes require certificates of large size are not closed under node-deletion, which yields the question of whether every graph family closed under node-deletion (in particular graph families closed under taking minors) have proof-labeling schemes with certificates of small size. This was recently shown to be true for planar graphsÂ , but the question is open beyond this class, putting aside simple classes such as bipartite graphs, forests, etc. As for the class of planar graphs, and for the class of graphs with bounded genus, every graph classÂ ğ’¢ğ’¢\\mathcal{G} that is closed under taking minors has a finite set of forbidden minors. As a consequence, as established inÂ , there is a simple proof-labeling scheme with Oâ€‹(logâ¡n)ğ‘‚ğ‘›O(\\log n)-bit certificates for ğ’¢Â¯Â¯ğ’¢\\overline{\\mathcal{G}}, i.e., for not being inÂ ğ’¢ğ’¢\\mathcal{G}. The scheme simply encodes a forbidden minor present in GğºG in a distributed manner for certifying that Gâˆ‰ğ’¢ğºğ’¢G\\notin\\mathcal{G}. Therefore, for every kâ‰¥0ğ‘˜0k\\geq 0, there exists a simple proof-labeling scheme with Oâ€‹(logâ¡n)ğ‘‚ğ‘›O(\\log n)-bit certificates for genus or demi-genus at leastÂ kğ‘˜k. The difficulty is to design a proof-labeling scheme with Oâ€‹(logâ¡n)ğ‘‚ğ‘›O(\\log n)-bit certificates for genus or demi-genus at mostÂ kğ‘˜k.\n\nReference markers found: [2]\n\nContext windows for each [ref]:\n[ref]2: tree. Such a proof may be encoded distributedly by providing each node with a certificate containing, e.g., the ID of the root ofÂ Tğ‘‡T, and the distance dâ€‹(v)ğ‘‘ğ‘£d(v) from vğ‘£v to the root (see, e.g., [ref]2  ). Indeed, every nodeÂ vğ‘£v but the root can simply check that dâ€‹(pâ€‹(v))=dâ€‹(v)âˆ’1ğ‘‘ğ‘ğ‘£ğ‘‘ğ‘£1d(p(v))=d(v)-1 (to guarantee the absence of cycles), and that it was given the same root-ID as all its\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 2,\n            \"titles\": [\n                \"Distributed Domination on Graph Classes of Bounded Expansion\",\n                \"Compact routing for graphs excluding a fixed minor\",\n                \"The local detection paradigm and its application to self-stabilization\",\n                \"A local constant factor MDS approximation for bounded genus graphs\",\n                \"Distributed dominating set approximations beyond planar graphs\",\n                \"Self-stabilization by local checking and correction (extended abstract)\",\n                \"What can be verified locally?\",\n                \"Shorter labeling schemes for planar graphs\",\n                \"Systems of circuits on two-dimensional manifolds\",\n                \"Approximate proof-labeling schemes\",\n                \"Trade-offs in distributed interactive proofs\",\n                \"Distributed almost exact approximations for minor-closed families\",\n                \"Distributed local approximation of the minimum k-tuple dominating set in planar graphs\",\n                \"Improved distributed local approximation algorithm for minimum 2-dominating set in planar graphs\",\n                \"Fast distributed approximations in planar graphs\",\n                \"ADJACENCY LABELLING FOR PLANAR GRAPHS (AND BEYOND)\",\n                \"Bibliography of distributed approximation beyond bounded degree\",\n                \"A hierarchy of local decision\",\n                \"Redundancy in Distributed Proofs\",\n                \"Compact Distributed Certification of Planar Graphs\",\n                \"Towards a complexity theory for local distributed computing\",\n                \"On distributed Merlin-Arthur decision protocols\",\n                \"Randomized proof-labeling schemes\",\n                \"Compact routing tables for graphs of bounded genus\",\n                \"Distributed algorithms for planar networks I: planar embedding\",\n                \"Distributed algorithms for planar networks II: low-congestion shortcuts, MST, and min-cut\",\n                \"Near-optimal distributed DFS in planar graphs\",\n                \"Locally checkable proofs in distributed computing\",\n                \"Brief announcement: local approximability of minimum dominating set on planar graphs\",\n                \"Fast and lean self-stabilizing asynchronous protocols\",\n                \"Interactive distributed proofs\",\n                \"Proof labeling schemes\",\n                \"What cannot be computed locally!\",\n                \"What can be approximated locally?: case study: dominating sets in planar graphs\",\n                \"Distributed minimum dominating set approximations in restricted families of graphs\",\n                \"A Basic Course in Algebraic Topology\",\n                \"Graphs on Surfaces\",\n                \"The Power of Distributed Verifiers in Interactive Proofs\",\n                \"What can be computed locally?\",\n                \"Sparsity - Graphs, Structures, and Algorithms, volumeÂ 28 of Algorithms and combinatorics\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]2 based on the context and research area of Local Certification of Graphs with Bounded Genus. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}