{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: Unifying Asynchronous Logics for Hyperproperties\n\nPaper Abstract: \n\nPaper Section Text:\nIn this section, we recall the classes of automata exploited inÂ  for solving satisfiability of full QPTL with past.\nIn the standard automata-theoretic approach for QPTL formulas Ï†ğœ‘\\varphi in prenex formÂ , first, one converts the quantifier-free part Ïˆğœ“\\psi of Ï†ğœ‘\\varphi into an equivalent nondeterministic BÃ¼chi automaton (NBA) accepting the set â„’â€‹(Ïˆ)â„’ğœ“\\mathcal{L}(\\psi) of traces satisfying Ïˆğœ“\\psi. Then, by using\nthe closure of NBA definable languages under projection and complementation, one obtains an NBA accepting â„’â€‹(Ï†)â„’ğœ‘\\mathcal{L}(\\varphi).\nThis approach would not work for arbitrary QPTL formulas Ï†ğœ‘\\varphi, where quantifiers can occur in the scope of both past and future temporal modalities. In this case, for a subformula Ï†â€²superscriptğœ‘â€²\\varphi^{\\prime} of Ï†ğœ‘\\varphi, we need to keep track of the full set â„’â„˜â€‹(Ï†â€²)subscriptâ„’Weierstrass-psuperscriptğœ‘â€²\\mathcal{L}_{\\wp}(\\varphi^{\\prime}) of pointed traces satisfying Ï†ğœ‘\\varphi, and not simply â„’â€‹(Ï†â€²)â„’superscriptğœ‘â€²\\mathcal{L}(\\varphi^{\\prime}). Thus, the automata-theoretic approach proposed inÂ \nis based on\na compositional translation of QPTL formulas into a simple two-way extension of NBA, called\nsimple two-way NBA (SNBA, for short) accepting languages of pointed traces.\nMoreover, each step of the translation into SNBA is based on an intermediate formalism consisting in a two-way extension of the class of (one-way) hesitant alternating automata (HAA, for short) over infinite words introduced inÂ [ref]27.\nWe now recall these two classes of automata. Moreover, for the class of two-way HAA, we consider additional requirements which may be fulfilled by some states of the automaton. These extra requirements allow to obtain\na more fine-grained complexity analysis in the translation of two-way HAA into equivalent SNBA, and they are important for obtaining an asymptotically optimal automata-theoretic approach for QPTL in terms of the strong alternation depth of a QPTL formula. SNBAÂ . An SNBA over traces on AP\nis a tuple ğ’œ=âŸ¨Q,Q0,Î´,Fâˆ’,F+âŸ©ğ’œğ‘„subscriptğ‘„0ğ›¿subscriptğ¹subscriptğ¹\\mathcal{A}=\\langle Q,Q_{0},\\delta,F_{-},F_{+}\\rangle, where Qğ‘„Q is a finite set of states, Q0âŠ†Qsubscriptğ‘„0ğ‘„Q_{0}\\subseteq Q is a set of initial states, Î´:QÃ—{â†’,â†}Ã—2APâ†’2Q:ğ›¿â†’ğ‘„â†’â†superscript2APsuperscript2ğ‘„\\delta:Q\\times\\{\\rightarrow,\\leftarrow\\}\\times 2^{\\textsf{AP}}\\rightarrow 2^{Q} is a transition function, and Fâˆ’subscriptğ¹F_{-} and F+subscriptğ¹F_{+} are sets of accepting states.\nIntuitively, the symbols â†’â†’\\rightarrow\nand â†â†\\leftarrow are used to denote forward and backward moves.\nA run of ğ’œğ’œ\\mathcal{A}\nover a pointed trace (Ïƒ,i)ğœğ‘–(\\sigma,i) is a pair r=(râ†,râ†’)ğ‘Ÿsubscriptğ‘Ÿâ†subscriptğ‘Ÿâ†’r=(r_{\\leftarrow},r_{\\rightarrow}) such that râ†’=qi,qi+1â€‹â€¦subscriptğ‘Ÿâ†’subscriptğ‘ğ‘–subscriptğ‘ğ‘–1â€¦r_{\\rightarrow}=q_{i},q_{i+1}\\ldots is an infinite sequence of states, râ†=qiâ€²,qiâˆ’1â€²â€‹â€¦â€‹q0â€²â€‹qâˆ’1â€²subscriptğ‘Ÿâ†subscriptsuperscriptğ‘â€²ğ‘–subscriptsuperscriptğ‘â€²ğ‘–1â€¦subscriptsuperscriptğ‘â€²0subscriptsuperscriptğ‘â€²1r_{\\leftarrow}=q^{\\prime}_{i},q^{\\prime}_{i-1}\\ldots q^{\\prime}_{0}q^{\\prime}_{-1} is a finite sequence of states, and: (i) qi=qiâ€²âˆˆQ0subscriptğ‘ğ‘–subscriptsuperscriptğ‘â€²ğ‘–subscriptğ‘„0q_{i}=q^{\\prime}_{i}\\in Q_{0};\n(ii) for each hâ‰¥iâ„ğ‘–h\\geq i, qh+1âˆˆÎ´â€‹(qh,â†’,Ïƒâ€‹(h))subscriptğ‘â„1ğ›¿subscriptğ‘â„â†’ğœâ„q_{h+1}\\in\\delta(q_{h},\\rightarrow,\\sigma(h)); and (iii)\nfor each hâˆˆ[0,i]â„0ğ‘–h\\in[0,i], qhâˆ’1â€²âˆˆÎ´â€‹(qhâ€²,â†,Ïƒâ€‹(h))subscriptsuperscriptğ‘â€²â„1ğ›¿subscriptsuperscriptğ‘â€²â„â†ğœâ„q^{\\prime}_{h-1}\\in\\delta(q^{\\prime}_{h},\\leftarrow,\\sigma(h)). Thus, starting from the initial position iğ‘–i in the input pointed trace (Ïƒ,i)ğœğ‘–(\\sigma,i), the automaton splits in two copies: the first one moves forwardly along the suffix of Ïƒğœ\\sigma starting from position iğ‘–i and the second one moves backwardly along the prefix Ïƒâ€‹(0)â€‹â€¦â€‹Ïƒâ€‹(i)ğœ0â€¦ğœğ‘–\\sigma(0)\\ldots\\sigma(i).\nThe run r=(râ†,râ†’)ğ‘Ÿsubscriptğ‘Ÿâ†subscriptğ‘Ÿâ†’r=(r_{\\leftarrow},r_{\\rightarrow}) is accepting if qâˆ’1â€²âˆˆFâˆ’subscriptsuperscriptğ‘â€²1subscriptğ¹q^{\\prime}_{-1}\\in F_{-} and râ†’subscriptğ‘Ÿâ†’r_{\\rightarrow} visits infinitely often some state in F+subscriptğ¹F_{+}. A pointed trace (Ïƒ,i)ğœğ‘–(\\sigma,i) is accepted by ğ’œğ’œ\\mathcal{A} if there is an accepting run of ğ’œğ’œ\\mathcal{A} over (Ïƒ,i)ğœğ‘–(\\sigma,i). We denote by â„’â„˜â€‹(ğ’œ)subscriptâ„’Weierstrass-pğ’œ\\mathcal{L}_{\\wp}(\\mathcal{A}) the set of pointed traces accepted by ğ’œğ’œ\\mathcal{A} and by â„’â€‹(ğ’œ)â„’ğ’œ\\mathcal{L}(\\mathcal{A}) the set of traces Ïƒğœ\\sigma such that (Ïƒ,0)âˆˆâ„’â„˜â€‹(ğ’œ)ğœ0subscriptâ„’Weierstrass-pğ’œ(\\sigma,0)\\in\\mathcal{L}_{\\wp}(\\mathcal{A}). Two-way HAAÂ .\nNow, we recall the class of two-way HAA.\nFor a set Xğ‘‹X, â„¬+â€‹(X)superscriptâ„¬ğ‘‹\\mathcal{B}^{+}(X) denotes the set of positive Boolean\nformulas over Xğ‘‹X built from elements in Xğ‘‹X using âˆ¨\\vee and âˆ§\\wedge (we also allow the formulas true and false).\nFor a formula\nÎ¸âˆˆâ„¬+â€‹(X)ğœƒsuperscriptâ„¬ğ‘‹\\theta\\in\\mathcal{B}^{+}(X), a model Yğ‘ŒY of Î¸ğœƒ\\theta is a subset Yğ‘ŒY\nof Xğ‘‹X which satisfies Î¸ğœƒ\\theta. The model Yğ‘ŒY of Î¸ğœƒ\\theta is minimal\nif no strict subset of Yğ‘ŒY satisfies Î¸ğœƒ\\theta. A two-way HAA ğ’œğ’œ\\mathcal{A} over traces on AP\nis a tuple ğ’œ=âŸ¨Q,q0,Î´,Fâˆ’,ğ–¥âŸ©ğ’œğ‘„subscriptğ‘0ğ›¿subscriptğ¹ğ–¥\\mathcal{A}=\\langle Q,q_{0},\\delta,F_{-},\\mathsf{F}\\rangle, where Qğ‘„Q is a\nfinite set of states, q0âˆˆQsubscriptğ‘0ğ‘„q_{0}\\in Q is the initial state, Î´:QÃ—2APâ†’â„¬+â€‹({â†’,â†}Ã—Q):ğ›¿â†’ğ‘„superscript2APsuperscriptâ„¬â†’â†ğ‘„\\delta:Q\\times 2^{\\textsf{AP}}\\rightarrow\\mathcal{B}^{+}(\\{\\rightarrow,\\leftarrow\\}\\times Q) is a transition\nfunction, Fâˆ’âŠ†Qsubscriptğ¹ğ‘„F_{-}\\subseteq Q is the backward acceptance condition, and ğ–¥ğ–¥\\mathsf{F} is a strata family encoding a particular kind of parity acceptance condition and imposing some syntactical constraints on the transition function Î´ğ›¿\\delta.\nBefore defining ğ–¥ğ–¥\\mathsf{F},\nwe give the notion of run which is independent of ğ–¥ğ–¥\\mathsf{F} and Fâˆ’subscriptğ¹F_{-}. We restrict ourselves to\nmemoryless runs, in which the behavior of the automaton\ndepends only on the current input position and current state. Since\nlater we will deal only with parity acceptance conditions,\nmemoryless runs are sufficient (see e.g.Â ).\nFormally, given a pointed trace (Ïƒ,i)ğœğ‘–(\\sigma,i)\nand a state qâ€²âˆˆQsuperscriptğ‘â€²ğ‘„q^{\\prime}\\in Q, an (i,qâ€²)ğ‘–superscriptğ‘â€²(i,q^{\\prime})-run of ğ’œğ’œ\\mathcal{A} over Ïƒğœ\\sigma is a\ndirected graph âŸ¨V,E,v0âŸ©ğ‘‰ğ¸subscriptğ‘£0\\langle V,E,v_{0}\\rangle with set of vertices VâŠ†(Natureâˆª{âˆ’1})Ã—Qğ‘‰Nature1ğ‘„V\\subseteq({\\rm Nature}\\cup\\{-1\\})\\times Q and initial vertex v0=(i,qâ€²)subscriptğ‘£0ğ‘–superscriptğ‘â€²v_{0}=(i,q^{\\prime}). Intuitively, a vertex (j,q)ğ‘—ğ‘(j,q) with jâ‰¥0ğ‘—0j\\geq 0 describes a copy of the automaton which is in state qğ‘q and reads the jtâ€‹hsuperscriptğ‘—ğ‘¡â„j^{th} input position. Additionally, we require that the set of edges Eğ¸E is consistent with the transition function Î´ğ›¿\\delta. Formally,\nfor every vertex v=(j,q)âˆˆVğ‘£ğ‘—ğ‘ğ‘‰v=(j,q)\\in V such that jâ‰¥0ğ‘—0j\\geq 0, there is a minimal model\n{(dir1,q1),â€¦,(dirn,qn)}subscriptdir1subscriptğ‘1â€¦subscriptdirğ‘›subscriptğ‘ğ‘›\\{(\\textit{dir}_{1},q_{1}),\\ldots,(\\textit{dir}_{n},q_{n})\\} of Î´â€‹(q,Ïƒâ€‹(j))ğ›¿ğ‘ğœğ‘—\\delta(q,\\sigma(j)) such that the set of successors of v=(j,q)ğ‘£ğ‘—ğ‘v=(j,q) is {(j1,q1),â€¦,(jn,qn)}subscriptğ‘—1subscriptğ‘1â€¦subscriptğ‘—ğ‘›subscriptğ‘ğ‘›\\{(j_{1},q_{1}),\\ldots,(j_{n},q_{n})\\}, where for all kâˆˆ[1,n]ğ‘˜1ğ‘›k\\in[1,n], jk=j+1subscriptğ‘—ğ‘˜ğ‘—1j_{k}=j+1 if dirk=â†’subscriptdirğ‘˜â†’\\textit{dir}_{k}=\\rightarrow, and jk=jâˆ’1subscriptğ‘—ğ‘˜ğ‘—1j_{k}=j-1 otherwise. An infinite path Ï€ğœ‹\\pi of a run is eventually strictly-forward whenever Ï€ğœ‹\\pi has\na suffix of the form (i,q1),(i+1,q2),â€¦ğ‘–subscriptğ‘1ğ‘–1subscriptğ‘2â€¦(i,q_{1}),(i+1,q_{2}),\\ldots for some iâ‰¥0ğ‘–0i\\geq 0. Now, we formally define ğ–¥ğ–¥\\mathsf{F} and give the semantic notion of acceptance.\nğ–¥ğ–¥\\mathsf{F} is a strata family of the\nform\nğ–¥={âŸ¨Ï1,Q1,F1âŸ©,â€¦,âŸ¨Ïk,Qk,FkâŸ©}ğ–¥subscriptğœŒ1subscriptğ‘„1subscriptğ¹1â€¦subscriptğœŒğ‘˜subscriptğ‘„ğ‘˜subscriptğ¹ğ‘˜\\mathsf{F}=\\{\\langle\\rho_{1},Q_{1},F_{1}\\rangle,\\ldots,\\langle\\rho_{k},Q_{k},F_{k}\\rangle\\},\nwhere Q1,â€¦,Qksubscriptğ‘„1â€¦subscriptğ‘„ğ‘˜Q_{1},\\ldots,Q_{k} is a partition of the set of states Qğ‘„Q of ğ’œğ’œ\\mathcal{A}, and for all iâˆˆ[1,k]ğ‘–1ğ‘˜i\\in[1,k],\nÏiâˆˆ{âˆ’,t,B,C}subscriptğœŒğ‘–tBC\\rho_{i}\\in\\{-,\\texttt{t},\\textsf{B},\\textsf{C}\\} and FiâŠ†Qisubscriptğ¹ğ‘–subscriptğ‘„ğ‘–F_{i}\\subseteq Q_{i}, such that\nFi=âˆ…subscriptğ¹ğ‘–F_{i}=\\emptyset whenever Ïiâˆˆ{t,âˆ’}subscriptğœŒğ‘–t\\rho_{i}\\in\\{\\texttt{t},-\\}. A stratum\nâŸ¨Ïi,Qi,FiâŸ©subscriptğœŒğ‘–subscriptğ‘„ğ‘–subscriptğ¹ğ‘–\\langle\\rho_{i},Q_{i},F_{i}\\rangle is called a negative stratum if Ïi=âˆ’subscriptğœŒğ‘–\\rho_{i}=-, a\ntransient stratum if Ïi=tsubscriptğœŒğ‘–t\\rho_{i}=\\texttt{t}, a BÃ¼chi stratum\n(with BÃ¼chi acceptance condition Fisubscriptğ¹ğ‘–F_{i}) if Ïi=BsubscriptğœŒğ‘–B\\rho_{i}=\\textsf{B}, and a\ncoBÃ¼chi stratum (with coBÃ¼chi acceptance condition\nFisubscriptğ¹ğ‘–F_{i}) if Ïi=CsubscriptğœŒğ‘–C\\rho_{i}=\\textsf{C}. Additionally, there is a\npartial order â‰¤\\leq on the sets Q1,â€¦,Qksubscriptğ‘„1â€¦subscriptğ‘„ğ‘˜Q_{1},\\ldots,Q_{k} such that the\nfollowing holds: Partial order requirement. Moves from states in Qisubscriptğ‘„ğ‘–Q_{i} lead to states in\ncomponents Qjsubscriptğ‘„ğ‘—Q_{j} such that\nQjâ‰¤Qisubscriptğ‘„ğ‘—subscriptğ‘„ğ‘–Q_{j}\\leq Q_{i}; additionally, if Qisubscriptğ‘„ğ‘–Q_{i} belongs to a transient stratum, there are no\nmoves from Qisubscriptğ‘„ğ‘–Q_{i} leading to Qisubscriptğ‘„ğ‘–Q_{i}. Eventually syntactical requirement For all moves (dir,qâ€²)dirsuperscriptğ‘â€²(\\textit{dir},q^{\\prime}) from states qâˆˆQiğ‘subscriptğ‘„ğ‘–q\\in Q_{i} such that qâ€²âˆˆQisuperscriptğ‘â€²subscriptğ‘„ğ‘–q^{\\prime}\\in Q_{i} as well, the following holds:\ndir is â†â†\\leftarrow if the\nstratum of Qisubscriptğ‘„ğ‘–Q_{i} is negative, and dir is\nâ†’â†’\\rightarrow otherwise. Each component Qisubscriptğ‘„ğ‘–Q_{i} satisfies one of the following two requirements: Existential requirement: for all states qiâˆˆQisubscriptğ‘ğ‘–subscriptğ‘„ğ‘–q_{i}\\in Q_{i} and input symbols ağ‘a, if Î´â€‹(q,a)ğ›¿ğ‘ğ‘\\delta(q,a) is rewritten in disjunctive normal form, then each conjunction contains at most one occurrence of a state in Qisubscriptğ‘„ğ‘–Q_{i}. Universal requirement: for all states qiâˆˆQisubscriptğ‘ğ‘–subscriptğ‘„ğ‘–q_{i}\\in Q_{i} and input symbols ağ‘a, if Î´â€‹(q,a)ğ›¿ğ‘ğ‘\\delta(q,a) is rewritten in conjunctive normal form, then each disjunction contains at most one occurrence of a state in Qisubscriptğ‘„ğ‘–Q_{i}. Components of BÃ¼chi strata satisfy the existential requirement, while components of coBÃ¼chi strata satisfy the universal requirement. The partial order requirement ensures\nthat every infinite path Ï€ğœ‹\\pi of a run gets trapped in the component\nQisubscriptğ‘„ğ‘–Q_{i} of some stratum. The\neventually syntactical requirement ensures that Qisubscriptğ‘„ğ‘–Q_{i}\nbelongs to a BÃ¼chi or coBÃ¼chi stratum and that Ï€ğœ‹\\pi is\neventually strictly-forward. Moreover, the existential requirement for a component Qisubscriptğ‘„ğ‘–Q_{i} establishes that\nfrom each state qâˆˆQiğ‘subscriptğ‘„ğ‘–q\\in Q_{i}, at most one copy of the automaton is sent to the next input\nsymbol in component Qisubscriptğ‘„ğ‘–Q_{i} (all the other copies move to states in strata with order lower than Qisubscriptğ‘„ğ‘–Q_{i}). Finally, the\nuniversal requirement corresponds to the dual of the existential requirement.\nNote that transient components trivially satisfy both the existential and the universal requirement.111Is is worth noting that the existential and universal requirements are not considered inÂ . On the other hand, they are crucial in the automata-theoretic approach for QPTL. Now we define when a run is accepting. Let Ï€ğœ‹\\pi be an infinite path\nof a run, âŸ¨Ïi,Qi,FiâŸ©subscriptğœŒğ‘–subscriptğ‘„ğ‘–subscriptğ¹ğ‘–\\langle\\rho_{i},Q_{i},F_{i}\\rangle be\nthe BÃ¼chi or coBÃ¼chi stratum in which Ï€ğœ‹\\pi gets trapped, and\nInfâ€‹(Ï€)Infğœ‹\\textit{Inf}(\\pi) be the states from Qğ‘„Q that occur infinitely many\ntimes in Ï€ğœ‹\\pi. The path Ï€ğœ‹\\pi is accepting whenever\nInfâ€‹(Ï€)âˆ©Fiâ‰ âˆ…Infğœ‹subscriptğ¹ğ‘–\\textit{Inf}(\\pi)\\cap F_{i}\\neq\\emptyset if Ïi=BsubscriptğœŒğ‘–B\\rho_{i}=\\textsf{B} and Infâ€‹(Ï€)âˆ©Fi=âˆ…Infğœ‹subscriptğ¹ğ‘–\\textit{Inf}(\\pi)\\cap F_{i}=\\emptyset otherwise (i.e. Ï€ğœ‹\\pi satisfies the corresponding\nBÃ¼chi or coBÃ¼chi requirement).\nA run is\naccepting if: (i) all its infinite paths are accepting and (ii) for each\nvertex (âˆ’1,q)1ğ‘(-1,q) reachable from the initial vertex, it holds that qâˆˆFâˆ’ğ‘subscriptğ¹q\\in F_{-} (recall that Fâˆ’subscriptğ¹F_{-} is the backward acceptance condition of ğ’œğ’œ\\mathcal{A}).\nThe\nÏ‰ğœ”\\omega-pointed language â„’pâ€‹(ğ’œ)subscriptâ„’ğ‘ğ’œ\\mathcal{L}_{p}(\\mathcal{A}) of ğ’œğ’œ\\mathcal{A} is the set\nof pointed traces (Ïƒ,i)ğœğ‘–(\\sigma,i) such that there is an\naccepting (i,q0)ğ‘–subscriptğ‘0(i,q_{0})-run of ğ’œğ’œ\\mathcal{A} on Ïƒğœ\\sigma. The dual automaton ğ’œ~~ğ’œ\\widetilde{\\mathcal{A}} of a two-way HAA ğ’œ=âŸ¨Q,q0,Î´,Fâˆ’,ğ–¥âŸ©ğ’œğ‘„subscriptğ‘0ğ›¿subscriptğ¹ğ–¥\\mathcal{A}=\\langle Q,q_{0},\\delta,F_{-},\\mathsf{F}\\rangle is defined\nas ğ’œ~=âŸ¨Q,q0,Î´~,Qâˆ–Fâˆ’,ğ–¥~âŸ©~ğ’œğ‘„subscriptğ‘0~ğ›¿ğ‘„subscriptğ¹~ğ–¥\\widetilde{\\mathcal{A}}=\\langle Q,q_{0},\\widetilde{\\delta},Q\\setminus F_{-},\\widetilde{\\mathsf{F}}\\rangle, where\nÎ´~â€‹(q,a)~ğ›¿ğ‘ğ‘\\widetilde{\\delta}(q,a) is the dual formula of Î´â€‹(q,a)ğ›¿ğ‘ğ‘\\delta(q,a) (obtained from Î´â€‹(q,a)ğ›¿ğ‘ğ‘\\delta(q,a) by\nswitching âˆ¨\\vee and âˆ§\\wedge, and switching true and false),\nand ğ–¥~~ğ–¥\\widetilde{\\mathsf{F}} is obtained from ğ–¥ğ–¥\\mathsf{F} by converting\na BÃ¼chi stratum âŸ¨B,Qi,FiâŸ©Bsubscriptğ‘„ğ‘–subscriptğ¹ğ‘–\\langle\\textsf{B},Q_{i},F_{i}\\rangle into the coBÃ¼chi stratum\nâŸ¨C,Qi,FiâŸ©Csubscriptğ‘„ğ‘–subscriptğ¹ğ‘–\\langle\\textsf{C},Q_{i},F_{i}\\rangle and a coBÃ¼chi stratum âŸ¨C,Qi,FiâŸ©Csubscriptğ‘„ğ‘–subscriptğ¹ğ‘–\\langle\\textsf{C},Q_{i},F_{i}\\rangle into\nthe BÃ¼chi stratum âŸ¨B,Qi,FiâŸ©Bsubscriptğ‘„ğ‘–subscriptğ¹ğ‘–\\langle\\textsf{B},Q_{i},F_{i}\\rangle. By construction the dual automaton ğ’œ~~ğ’œ\\widetilde{\\mathcal{A}} of ğ’œğ’œ\\mathcal{A} is\nstill a two-way HAA. Following standard arguments (see\ne.g.Â ), the following holds. The dual automaton ğ’œ~~ğ’œ\\widetilde{\\mathcal{A}} of a two-way HAA ğ’œğ’œ\\mathcal{A} is a two-way HAA accepting the complement of\nâ„’â„˜â€‹(ğ’œ)subscriptâ„’Weierstrass-pğ’œ\\mathcal{L}_{\\wp}(\\mathcal{A}). Note that SNBA correspond to a subclass of two-way HAA. An SNBA ğ’œğ’œ\\mathcal{A} can be converted â€œon the flyâ€ in linear time into a two-way HAA accepting â„’â„˜â€‹(ğ’œ)subscriptâ„’Weierstrass-pğ’œ\\mathcal{L}_{\\wp}(\\mathcal{A}). Additional requirements on components of two-way HAA. Let ğ’œ=âŸ¨Q,q0,Î´,Fâˆ’,ğ–¥âŸ©ğ’œğ‘„subscriptğ‘0ğ›¿subscriptğ¹ğ–¥\\mathcal{A}=\\langle Q,q_{0},\\delta,F_{-},\\mathsf{F}\\rangle be a two-way HAA.\nA component Qisubscriptğ‘„ğ‘–Q_{i} of ğ’œğ’œ\\mathcal{A} is globally nondeterministic if the following inductively holds: Qisubscriptğ‘„ğ‘–Q_{i} satisfies the existential requirement and Qisubscriptğ‘„ğ‘–Q_{i} is not a coBÃ¼chi component; for each component Qksubscriptğ‘„ğ‘˜Q_{k} distinct from Qisubscriptğ‘„ğ‘–Q_{i} such that there are moves from Qksubscriptğ‘„ğ‘˜Q_{k} leading to Qisubscriptğ‘„ğ‘–Q_{i} (hence, Qk>Qisubscriptğ‘„ğ‘˜subscriptğ‘„ğ‘–Q_{k}>Q_{i}), (i) Qksubscriptğ‘„ğ‘˜Q_{k} is globally nondeterministic, and (ii) for each qâˆˆQkğ‘subscriptğ‘„ğ‘˜q\\in Q_{k} and input symbol ağ‘a, if\nÎ´â€‹(q,a)ğ›¿ğ‘ğ‘\\delta(q,a) is rewritten in disjunctive normal form, then each conjunction contains at most one occurrence of a state in Qisubscriptğ‘„ğ‘–Q_{i}. The previous requirement ensures that in each run rğ‘Ÿr and for each input position â„“â„“\\ell, there is at most one copy of the automaton that is in some state\nof Qisubscriptğ‘„ğ‘–Q_{i} reading position â„“â„“\\ell. A state of ğ’œğ’œ\\mathcal{A} is globally nondeterministic if it belongs to some globally nondeterministic component of ğ’œğ’œ\\mathcal{A}. From two-way HAA to SNBAÂ . Two-way HAA can be translated in singly exponential time\ninto equivalent SNBAÂ . The translation inÂ  is a generalization of the Miyano-Hayashi\nconstructionÂ  (for converting by an exponential blowup a BÃ¼chi alternating automaton into an equivalent\nNBA) and exploits the so called ranking constructionÂ  for converting in quadratic time\na coBÃ¼chi alternating automaton into an equivalent BÃ¼chi alternating automaton. The translation can be easily adapted for handling\nglobally nondeterministic components in two-way HAA. Thus, we obtain the following result. Given a two-way HAA ğ’œğ’œ\\mathcal{A}, one can construct â€œon the flyâ€ and in singly\nexponential time a BÃ¼chi SNBA accepting â„’â„˜â€‹(ğ’œ)subscriptâ„’Weierstrass-pğ’œ\\mathcal{L}_{\\wp}(\\mathcal{A}) with\n2Oâ€‹(nâ‹…logâ¡(n+k))superscript2ğ‘‚â‹…ğ‘›ğ‘›ğ‘˜2^{O(n\\cdot\\log(n+k))} states, where kğ‘˜k is the number of states\nin the globally nondeterministic components of ğ’œğ’œ\\mathcal{A}, and nğ‘›n is the number of remaining states of ğ’œğ’œ\\mathcal{A}.\n\nReference markers found: [27]\n\nContext windows for each [ref]:\n[ref]27: into SNBA is based on an intermediate formalism consisting in a two-way extension of the class of (one-way) hesitant alternating automata (HAA, for short) over infinite words introduced inÂ [ref]27.\nWe now recall these two classes of automata. Moreover, for the class of two-way HAA, we consider additional requirements which may be fulfilled by some states of the automaton. These extra\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 27,\n            \"titles\": [\n                \"On the Complexity of Linear Temporal Logic with Team Semantics\",\n                \"A Temporal Logic for Asynchronous Hyperproperties\",\n                \"Second-Order Hyperproperties\",\n                \"Diagnosability of fair transition systems\",\n                \"(Asynchronous) temporal logics for hyperproperties on finite traces\",\n                \"Formal Design of Asynchronous Fault Detection and Identification Components using Temporal Epistemic Logic\",\n                \"Unifying Hyper and Epistemic Temporal Logics\",\n                \"Asynchronous Extensions of HyperLTL\",\n                \"Expressiveness and Decidability of Temporal Logics for Asynchronous Hyperproperties\",\n                \"Temporal Logics for Hyperproperties\",\n                \"Hyperproperties\",\n                \"The hierarchy of hyperlogics\",\n                \"Model Checking Information Flow in Reactive Systems\",\n                \"â€œSometimesâ€ and â€œNot Neverâ€ revisited: on branching versus linear time temporal logic\",\n                \"Reasoning about knowledge, volume 4\",\n                \"Deciding Hyperproperties\",\n                \"The first-order logic of hyperproperties\",\n                \"Propositional Dynamic Logic of Regular Programs\",\n                \"Security Policies and Security Models\",\n                \"Temporal Team Semantics Revisited\",\n                \"Propositional Dynamic Logic for Hyperproperties\",\n                \"Automata and Fixpoints for Asynchronous Hyperproperties\",\n                \"Secrecy in multiagent systems\",\n                \"The Complexity of Reasoning about Knowledge and Time: Extended Abstract\",\n                \"Team Semantics for the Specification and Verification of Hyperproperties\",\n                \"From liveness to promptness\",\n                \"Weak alternating automata are not that weak\",\n                \"An Automata-Theoretic Approach to Branching-Time Model Checking\",\n                \"The Temporal Logic of Reactive and Concurrent Systems - Specification\",\n                \"A General Theory of Composition for a Class of â€œPossibilisticâ€ Properties\",\n                \"Alternating finite automata on Ï‰ğœ”\\\\omega-words\",\n                \"The Temporal Logic of Programs\",\n                \"A temporal logic approach to information-flow control\",\n                \"Diagnosability of discrete-event systems\",\n                \"The Complementation Problem for BÃ¼chi Automata with Applications to Temporal Logic\",\n                \"Model checking knowledge and time in systems with perfect recall (extended abstract)\",\n                \"Reasoning about infinite computations\",\n                \"A temporal fixpoint calculus\",\n                \"Linear-time Temporal Logic with Team Semantics: Expressivity and Complexity\",\n                \"Observational Determinism for Concurrent Program Security\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]27 based on the context and research area of Unifying Asynchronous Logics for Hyperproperties. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}