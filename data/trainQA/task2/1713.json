{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: Exact and Approximate Pattern Counting in Degenerate Graphs: New Algorithms, Hardness Results, and Complexity Dichotomies\n\nPaper Abstract: \n\nPaper Section Text:\nGraphs are simple and without self-loops, unless stated otherwise. Given a graph G=(V,E)𝐺𝑉𝐸G=(V,E), a subgraph of G𝐺G is a graph obtained by deleting edges and vertices, and an induced subgraph of G𝐺G is a graph obtained by deleting vertices only. Given a graph H𝐻H, we write 𝖲𝗎𝖻​(H→G)𝖲𝗎𝖻→𝐻𝐺\\mathsf{Sub}(H\\!\\rightarrow\\!G) (𝖨𝗇𝖽𝖲𝗎𝖻​(H→G)𝖨𝗇𝖽𝖲𝗎𝖻→𝐻𝐺\\mathsf{IndSub}(H\\!\\rightarrow\\!G)) for the set of all subgraphs (induced subgraphs) of G𝐺G isomorphic to H𝐻H.\nGiven a vertex subset S⊆V𝑆𝑉S\\subseteq V, we write G​[S]𝐺delimited-[]𝑆G[S] for the graph induced by S𝑆S, that is V​(G​[S])=S𝑉𝐺delimited-[]𝑆𝑆V(G[S])=S and E​(G​[S])=E​(G)∩S2𝐸𝐺delimited-[]𝑆𝐸𝐺superscript𝑆2E(G[S])=E(G)\\cap S^{2}. Given an edge subset S⊆E𝑆𝐸S\\subseteq E, we write G​[S]𝐺delimited-[]𝑆G[S] for the edge-subgraph (V,S)𝑉𝑆(V,S) of G𝐺G. A homomorphism from a graph H𝐻H to a graph G𝐺G is a mapping φ:V​(H)→V​(G):𝜑→𝑉𝐻𝑉𝐺\\varphi:V(H)\\rightarrow V(G) that preserves the edges, i.e., for each edge {u,v}∈E​(H)𝑢𝑣𝐸𝐻\\{u,v\\}\\in E(H) we have {φ​(u),φ​(v)}∈E​(G)𝜑𝑢𝜑𝑣𝐸𝐺\\{\\varphi(u),\\varphi(v)\\}\\in E(G). An injective homomorphism is called an embedding, and an embedding is called a strong embedding if {u,v}∈E​(H)𝑢𝑣𝐸𝐻\\{u,v\\}\\in E(H) is equivalent to {φ​(u),φ​(v)}∈E​(G)𝜑𝑢𝜑𝑣𝐸𝐺\\{\\varphi(u),\\varphi(v)\\}\\in E(G). We write 𝖧𝗈𝗆​(H→G)𝖧𝗈𝗆→𝐻𝐺\\mathsf{Hom}(H\\!\\rightarrow\\!G), 𝖤𝗆𝖻​(H→G)𝖤𝗆𝖻→𝐻𝐺\\mathsf{Emb}(H\\!\\rightarrow\\!G), and 𝖲𝗍𝗋𝖤𝗆𝖻​(H→G)𝖲𝗍𝗋𝖤𝗆𝖻→𝐻𝐺\\mathsf{StrEmb}(H\\!\\rightarrow\\!G) for the sets of homomorphisms, embeddings, and strong embeddings, respectively, from H𝐻H to G𝐺G. Finally, we write 𝖠𝗎𝗍​(H)𝖠𝗎𝗍𝐻\\mathsf{Aut}(H) for the set of all automorphisms of H𝐻H.\nWe will use the following well-known relationships: For every pair of graphs H𝐻H and G𝐺G, we have |𝖤𝗆𝖻​(H→G)|=|𝖠𝗎𝗍​(H)|⋅|𝖲𝗎𝖻​(H→G)|𝖤𝗆𝖻→𝐻𝐺⋅𝖠𝗎𝗍𝐻𝖲𝗎𝖻→𝐻𝐺|\\mbox{$\\mathsf{Emb}(H\\!\\rightarrow\\!G)$}|=|\\mathsf{Aut}(H)|\\cdot|\\mbox{$\\mathsf{Sub}(H\\!\\rightarrow\\!G)$}| and |𝖲𝗍𝗋𝖤𝗆𝖻​(H→G)|=|𝖠𝗎𝗍​(H)|⋅|𝖨𝗇𝖽𝖲𝗎𝖻​(H→G)|𝖲𝗍𝗋𝖤𝗆𝖻→𝐻𝐺⋅𝖠𝗎𝗍𝐻𝖨𝗇𝖽𝖲𝗎𝖻→𝐻𝐺|\\mbox{$\\mathsf{StrEmb}(H\\!\\rightarrow\\!G)$}|=|\\mathsf{Aut}(H)|\\cdot|\\mbox{$\\mathsf{IndSub}(H\\!\\rightarrow\\!G)$}|. We will also need the following transformations.\nGiven a partition ρ𝜌\\rho of V​(G)𝑉𝐺V(G), the quotient graph (or just the quotient) G/ρ𝐺𝜌G/\\rho is obtained from G𝐺G by identifying all vertices that are in the same block of ρ𝜌\\rho and deleting multiple edges. We point out that G/ρ𝐺𝜌G/\\rho might, a priori, have self-loops, but will usually only consider those quotients without self-loops.111111A quotient without self-loops is called a spasm by some authors, see for instance [ref]20.\nGiven a function f:A×B→C:𝑓→𝐴𝐵𝐶f:A\\times B\\rightarrow C and an element a∈A𝑎𝐴a\\in A, we write f​(a,⋆):B→C:𝑓𝑎⋆→𝐵𝐶f(a,\\star):B\\rightarrow C for the function that maps b∈B𝑏𝐵b\\in B to f​(a,b)𝑓𝑎𝑏f(a,b). Let H𝐻H be a graph. We have where the sum is taken over all partitions of V​(H)𝑉𝐻V(H), ⊥bottom\\bot is the finest partition, and is the Möbius function of the partition lattice of V​(H)𝑉𝐻V(H). Let H𝐻H be a graph. We have where the sum is taken over all (isomorphism classes of) graphs, and {H′⊇H}𝐻superscript𝐻′\\{H^{\\prime}\\supseteq H\\} contains all sets S∈V​(H)2∖E​(H)𝑆𝑉superscript𝐻2𝐸𝐻S\\in V(H)^{2}\\setminus E(H) such that (V​(H),E​(H)∪S)𝑉𝐻𝐸𝐻𝑆(V(H),E(H)\\cup S) is isomorphic to H′superscript𝐻′H^{\\prime}. A graph G𝐺G is H𝐻H-coloured if it comes with a homomorphism c∈𝖧𝗈𝗆​(G→H)𝑐𝖧𝗈𝗆→𝐺𝐻c\\in\\mbox{$\\mathsf{Hom}(G\\!\\rightarrow\\!H)$}, called colouring. A homomorphism φ∈𝖧𝗈𝗆​(H→G)𝜑𝖧𝗈𝗆→𝐻𝐺\\varphi\\in\\mbox{$\\mathsf{Hom}(H\\!\\rightarrow\\!G)$} is colour-prescribed if c​(φ​(v))=v𝑐𝜑𝑣𝑣c(\\varphi(v))=v for all v∈V​(H)𝑣𝑉𝐻v\\in V(H).\nThis means that each v∈V​(H)𝑣𝑉𝐻v\\in V(H) must be mapped to a vertex of G𝐺G that is coloured with v𝑣v. We write 𝖼𝗉​-​𝖧𝗈𝗆​(H→G)𝖼𝗉-𝖧𝗈𝗆→𝐻𝐺\\mathsf{cp}\\textsc{-}\\mathsf{Hom}(H\\!\\rightarrow\\!G) for the set of all colour-prescribed homomorphisms from H𝐻H to G𝐺G. Moreover, φ𝜑\\varphi is called colourful if c​(φ​(V​(H)))=V​(H)𝑐𝜑𝑉𝐻𝑉𝐻c(\\varphi(V(H)))=V(H), that is, each colour is met precisely once. We write 𝖼𝖿​-​𝖧𝗈𝗆​(H→G)𝖼𝖿-𝖧𝗈𝗆→𝐻𝐺\\mathsf{cf}\\textsc{-}\\mathsf{Hom}(H\\!\\rightarrow\\!G) for the set of all colourful homomorphisms from H𝐻H to G𝐺G. We always assume that colourings are surjective, since otherwise 𝖼𝗉​-​𝖧𝗈𝗆​(H→G)=𝖼𝖿​-​𝖧𝗈𝗆​(H→G)=∅𝖼𝗉-𝖧𝗈𝗆→𝐻𝐺𝖼𝖿-𝖧𝗈𝗆→𝐻𝐺\\mathsf{cp}\\textsc{-}\\mathsf{Hom}(H\\!\\rightarrow\\!G)=\\mathsf{cf}\\textsc{-}\\mathsf{Hom}(H\\!\\rightarrow\\!G)=\\emptyset.\nFor any S⊆V​(H)𝑆𝑉𝐻S\\subseteq V(H), let G−S𝐺𝑆G-S be the graph obtained from G𝐺G by deleting all vertices coloured with some vertex in S𝑆S.\nWe will use the following two well-known facts (see for instance [52, Section 2.5]). |𝖼𝗉​-​𝖧𝗈𝗆​(H→G)|=|𝖠𝗎𝗍​(H)|−1⋅|𝖼𝖿​-​𝖧𝗈𝗆​(H→G)|𝖼𝗉-𝖧𝗈𝗆→𝐻𝐺⋅superscript𝖠𝗎𝗍𝐻1𝖼𝖿-𝖧𝗈𝗆→𝐻𝐺|\\mathsf{cp}\\textsc{-}\\mathsf{Hom}(H\\!\\rightarrow\\!G)|=|\\mathsf{Aut}(H)|^{-1}\\cdot|\\mathsf{cf}\\textsc{-}\\mathsf{Hom}(H\\!\\rightarrow\\!G)|. |𝖼𝖿​-​𝖧𝗈𝗆​(H→G)|=∑S⊆V​(H)(−1)|S|⋅|𝖧𝗈𝗆​(H→G−S)|𝖼𝖿-𝖧𝗈𝗆→𝐻𝐺subscript𝑆𝑉𝐻⋅superscript1𝑆𝖧𝗈𝗆→𝐻𝐺𝑆|\\mathsf{cf}\\textsc{-}\\mathsf{Hom}(H\\!\\rightarrow\\!G)|=\\sum_{S\\subseteq V(H)}(-1)^{|S|}\\cdot|\\mbox{$\\mathsf{Hom}(H\\!\\rightarrow\\!G-S)$}|. A graph F𝐹F is a minor of a graph H𝐻H if it can be obtained from H𝐻H by a sequence of edge contractions, edge deletions, and vertex deletions. It is well known that minors can be equivalently defined via models: a model of F𝐹F in H𝐻H is a mapping from V​(F)𝑉𝐹V(F) to nonempty disjoint subsets of V​(H)𝑉𝐻V(H), that we call blocks and denote by {Bu:u∈V​(F)}conditional-setsubscript𝐵𝑢𝑢𝑉𝐹\\{B_{u}:u\\in V(F)\\}, such that H​[Bu]𝐻delimited-[]subscript𝐵𝑢H[B_{u}] is connected for all u∈V​(F)𝑢𝑉𝐹u\\in V(F), and that H𝐻H has an edge between Busubscript𝐵𝑢B_{u} and Bvsubscript𝐵𝑣B_{v} if {u,v}∈E​(F)𝑢𝑣𝐸𝐹\\{u,v\\}\\in E(F). We emphasise that Bu≠∅subscript𝐵𝑢B_{u}\\neq\\emptyset for all u∈V​(F)𝑢𝑉𝐹u\\in V(F).\nA graph F𝐹F is an induced minor of a graph H𝐻H if F𝐹F can be obtained from H𝐻H by a sequence of edge contractions and vertex deletions. Induced minors can be expressed via witness structures (cf. ), which are identical to models save for the fact that H𝐻H has an edge between Busubscript𝐵𝑢B_{u} and Bvsubscript𝐵𝑣B_{v} if and only if {u,v}∈E​(F)𝑢𝑣𝐸𝐹\\{u,v\\}\\in E(F). We give a concise introduction to parameterized counting problems and fine-grained complexity theory. For more details see, e.g., [34, Chapter 14]. A parameterized counting problem is a pair (P,κ)𝑃𝜅(P,\\kappa), where P:{0,1}∗→ℕ:𝑃→superscript01∗ℕP:\\{0,1\\}^{\\ast}\\rightarrow\\mathbb{N} is a counting problem and κ:{0,1}∗→ℕ:𝜅→superscript01∗ℕ\\kappa:\\{0,1\\}^{\\ast}\\rightarrow\\mathbb{N} is a parameterization. For example, the problem #​Clique#Clique\\#\\textsc{Clique} expects as input a graph G𝐺G and a positive integer k𝑘k, and the task is to compute the number of k𝑘k-cliques in G𝐺G, that is, P​(G,k):=|𝖲𝗎𝖻​(Kk→G)|assign𝑃𝐺𝑘𝖲𝗎𝖻→subscript𝐾𝑘𝐺P(G,k):=|\\mbox{$\\mathsf{Sub}(K_{k}\\!\\rightarrow\\!G)$}|. The parameterization is given by k𝑘k, that is, κ​(G,k):=kassign𝜅𝐺𝑘𝑘\\kappa(G,k):=k.\nA parameterized (counting) problem is called fixed-parameter tractable (FPT) if there exists a computable function f𝑓f such that the problem can be solved in time f​(κ​(x))⋅|x|O​(1)⋅𝑓𝜅𝑥superscript𝑥𝑂1f(\\kappa(x))\\cdot|x|^{O(1)}, where x∈{0,1}∗𝑥superscript01∗x\\in\\{0,1\\}^{\\ast} is the input instance. An algorithm running in this time is called an FPT algorithm.\nA parameterized Turing-reduction from (P,κ)𝑃𝜅(P,\\kappa) to (P′,κ′)superscript𝑃′superscript𝜅′(P^{\\prime},\\kappa^{\\prime}) is an FPT algorithm 𝒜𝒜\\mathcal{A} equipped with oracle access to P′superscript𝑃′P^{\\prime} that computes P​(x)𝑃𝑥P(x). Additionally, there must be a computable function f𝑓f such that for any input x𝑥x, the parameter κ′​(y)superscript𝜅′𝑦\\kappa^{\\prime}(y) of each oracle query y𝑦y must be bounded by f​(κ​(x))𝑓𝜅𝑥f(\\kappa(x)). We write (P,κ)≤Tfpt(P′,κ′)subscriptsuperscriptfptT𝑃𝜅superscript𝑃′superscript𝜅′(P,\\kappa)\\leq^{\\mathrm{fpt}}_{\\mathrm{T}}(P^{\\prime},\\kappa^{\\prime}) if a parameterized Turing-reduction exists.\nThe notion of parameterized intractability is given by #​𝖶​#𝖶delimited-[]1\\#\\mathsf{W}-hardness:121212We use the definition via a complete problem and refer the reader to [34, Chapter 14] for a more structural and machine-based definition of #​𝖶​#𝖶delimited-[]1\\#\\mathsf{W}. A parameterized counting problem (P,κ)𝑃𝜅(P,\\kappa) is #​𝖶​#𝖶delimited-[]1\\#\\mathsf{W}-hard if #​Clique≤Tfpt(P,κ)subscriptsuperscriptfptT#Clique𝑃𝜅\\#\\textsc{Clique}\\leq^{\\mathrm{fpt}}_{\\mathrm{T}}(P,\\kappa). It is known that #​𝖶​#𝖶delimited-[]1\\#\\mathsf{W}-hard problems are not fixed-parameter tractable unless ETH, defined below, fails. The Exponential Time Hypothesis (ETH) asserts that the problem 3​-SAT3-SAT3\\textsc{-SAT} cannot be solved in time exp⁡(o​(n))𝑜𝑛\\exp(o(n)) where n𝑛n is the number of variables of the input formula. Our hardness results will rely on the following theorem, which is an immediate consequence of the works of Dalmau and Jonsson  and Marx .\nWe include a proof for the readers’ convenience. Let C𝐶C be a computable class of graphs. If C𝐶C has unbounded treewidth131313We will exclusively rely on treewidth in a black-box manner. Thus we avoid stating the definition and refer the reader e.g. to Chapter 7 in . then #​cp-Hom​(C)#cp-Hom𝐶\\#\\textsc{cp-Hom}(C) is #​𝖶​#𝖶delimited-[]1\\#\\mathsf{W}-hard and cannot be solved in time\nf​(|H|)⋅|G|o​(𝗍𝗐​(H)/log⁡tw⁡(H))⋅𝑓𝐻superscript𝐺𝑜𝗍𝗐𝐻tw𝐻f(|H|)\\cdot|G|^{o(\\mathsf{tw}(H)/\\log\\operatorname{tw}(H))}\nfor any function f𝑓f, unless ETH fails. The #​𝖶​#𝖶delimited-[]1\\#\\mathsf{W}-hardness follows by the #​𝖶​#𝖶delimited-[]1\\#\\mathsf{W}-hardness of #​Hom​(C)#Hom𝐶\\#\\textsc{Hom}(C), see , and by a reduction from #​Hom​(C)#Hom𝐶\\#\\textsc{Hom}(C) to #​cp-Hom​(C)#cp-Hom𝐶\\#\\textsc{cp-Hom}(C), see .\nThe lower bound follows from a result on the partitioned subgraph isomorphism problem, see , which tightly reduces to #​cp-Hom​(C)#cp-Hom𝐶\\#\\textsc{cp-Hom}(C), see [54, Section 2]).\n∎ We will apply Theorem 22 to the following family ℱℱ\\mathcal{F} of regular expanders: There exists a family of graphs ℱ={Fk}k≥1ℱsubscriptsubscript𝐹𝑘𝑘1\\mathcal{F}=\\{F_{k}\\}_{k\\geq 1} and constants k0,c>0subscript𝑘0𝑐0k_{0},c>0 such that for all k≥k0𝑘subscript𝑘0k\\geq k_{0} we have 𝗍𝗐​(Fk)≥k𝗍𝗐subscript𝐹𝑘𝑘\\mathsf{tw}(F_{k})\\geq k and |V​(Fk)|≤c​k𝑉subscript𝐹𝑘𝑐𝑘|V(F_{k})|\\leq ck and |E​(Fk)|≤c​k𝐸subscript𝐹𝑘𝑐𝑘|E(F_{k})|\\leq ck. The degeneracy d​(G)𝑑𝐺d(G) of a graph G𝐺G can be defined as the smallest integer d𝑑d such that there exists an acyclic orientation of G𝐺G with maximum out-degree bounded by d𝑑d. We can assume that such an orientation is given, since it can be found in time O​(|E​(G)|)𝑂𝐸𝐺O(|E(G)|) . Our running time upper bounds rely on the dag tree decomposition of [ref]8 and the dynamic program that it yields. Here, we adopt a generalisation of the original definition of dag tree decomposition. We need this generalisation for some of our results in Section 6.2. Let H=(V,A)subscript𝐻𝑉𝐴{H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}}=(V,A) be any directed acyclic graph. We denote by S=S​(H)𝑆𝑆subscript𝐻S=S({H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}}) the set of sources of Hsubscript𝐻{H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}}, that is, the vertices of indegree zero. For any B⊆V𝐵𝑉B\\subseteq V, we let H​(B)subscript𝐻𝐵{H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}}(B) be the subgraph of Hsubscript𝐻{H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}} induced by all vertices reachable from some vertex in B𝐵B. For any tree 𝒯𝒯\\mathcal{T} and any two vertices B′,B′′superscript𝐵′superscript𝐵′′B^{\\prime},B^{\\prime\\prime} of 𝒯𝒯\\mathcal{T}, we denote by 𝒯​(B′,B′′)𝒯superscript𝐵′superscript𝐵′′\\mathcal{T}(B^{\\prime},B^{\\prime\\prime}) the unique simple path between B′superscript𝐵′B^{\\prime} and B′′superscript𝐵′′B^{\\prime\\prime} in 𝒯𝒯\\mathcal{T}. A (generalised) dag tree decomposition (d.t.d.) of Hsubscript𝐻{H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}} is a rooted tree 𝒯=(ℬ,ℰ)𝒯ℬℰ\\mathcal{T}=(\\mathcal{B},\\mathcal{E}) such that: B⊆V​(H)𝐵𝑉𝐻B\\subseteq V(H) for all B∈ℬ𝐵ℬB\\in\\mathcal{B} ⋃B∈ℬV​(H​(B))=V​(H)subscript𝐵ℬ𝑉subscript𝐻𝐵𝑉𝐻\\bigcup_{B\\in\\mathcal{B}}V({H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}}(B))=V(H) for all B,B1,B2∈ℬ𝐵subscript𝐵1subscript𝐵2ℬB,B_{1},B_{2}\\in\\mathcal{B}, if B∈𝒯​(B1,B2)𝐵𝒯subscript𝐵1subscript𝐵2B\\in\\mathcal{T}(B_{1},B_{2}) then V​(H​(B1))∩V​(H​(B2))⊆V​(H​(B))𝑉subscript𝐻subscript𝐵1𝑉subscript𝐻subscript𝐵2𝑉subscript𝐻𝐵V({H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}}(B_{1}))\\cap V({H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}}(B_{2}))\\subseteq V({H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}}(B)) The width of 𝒯𝒯\\mathcal{T} is τ​(𝒯)=maxB∈𝒯⁡|B|𝜏𝒯subscript𝐵𝒯𝐵\\tau(\\mathcal{T})=\\max_{B\\in\\mathcal{T}}|B|. The (generalised) dag treewidth of Hsubscript𝐻{H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}} is τ​(H)=min𝒯⁡τ​(𝒯)𝜏subscript𝐻subscript𝒯𝜏𝒯\\tau({H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}})=\\min_{\\mathcal{T}}\\tau(\\mathcal{T}) where the minimum is over all possible (generalised) d.t.d.’s of Hsubscript𝐻{H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}}. It is immediate to verify that if 𝒯𝒯\\mathcal{T} is a d.t.d. of Hsubscript𝐻{H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}} according to [ref]8 then 𝒯𝒯\\mathcal{T} is a generalised d.t.d. according to Definition 24 as well. It is easy to verify that the dynamic program of [ref]8 and all subsequent bounds continue to hold when 𝒯𝒯\\mathcal{T} is a generalised d.t.d., too. Hence for our upper bounds we can use τ​(H)𝜏subscript𝐻\\tau({H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}}) with τ𝜏\\tau as in Definition 24. Now let H𝐻H be any simple graph. We let Σ​(H)Σ𝐻\\Sigma(H) be the set of all possible acyclic orientations Hsubscript𝐻{H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}} of H𝐻H. We let R​(H)𝑅𝐻R(H) be the set of all partitions ρ𝜌\\rho of V​(H)𝑉𝐻V(H) such that the quotient H/ρ𝐻𝜌H/\\rho is without self-loops. We let D​(H)𝐷𝐻D(H) be the set of all supergraphs of H𝐻H on the same vertex set V​(H)𝑉𝐻V(H). Following [ref]8, we define: By the discussion above, the parameters τ1,τ2,τ3subscript𝜏1subscript𝜏2subscript𝜏3\\tau_{1},\\tau_{2},\\tau_{3} defined above in terms of Definition 24 are bounded from above by their homologues defined in [ref]8. Therefore from now on we omit the adjective “generalised” unless necessary.\n\nReference markers found: [20]\n\nContext windows for each [ref]:\n[ref]20: might, a priori, have self-loops, but will usually only consider those quotients without self-loops.111111A quotient without self-loops is called a spasm by some authors, see for instance [ref]20.\nGiven a function f:A×B→C:𝑓→𝐴𝐵𝐶f:A\\times B\\rightarrow C and an element a∈A𝑎𝐴a\\in A, we write f​(a,⋆):B→C:𝑓𝑎⋆→𝐵𝐶f(a,\\star):B\\rightarrow C for the function that maps b∈B𝑏𝐵b\\in B to\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 20,\n            \"titles\": [\n                \"Complexity of counting subgraphs: only the boundedness of the vertex-cover number counts\",\n                \"Biomolecular network motif counting and discovery by color coding\",\n                \"Edge orbits and edge-deleted subgraphs\",\n                \"When is Approximate Counting for Conjunctive Queries Tractable?\",\n                \"Approximation Algorithms for Some Parameterized Counting Problems\",\n                \"Linear Time Subgraph Counting, Graph Degeneracy, and the Chasm at Size Six\",\n                \"Near-Linear Time Homomorphism Counting in Bounded Degeneracy Graphs: The Barrier of Long Induced Cycles\",\n                \"Faster Subgraph Counting in Sparse Graphs\",\n                \"Faster algorithms for counting subgraphs in sparse graphs\",\n                \"Current Algorithms for Detecting Subgraphs of Bounded Treewidth are Probably Optimal\",\n                \"Approximate Counting CSP Seen from the Other Side\",\n                \"A Trichotomy in the Complexity of Counting Answers to Conjunctive Queries\",\n                \"Counting Answers to Existential Positive Queries: A Complexity Classification\",\n                \"Tight lower bounds for certain parameterized NP-hard problems\",\n                \"Strong computational lower bounds via parameterized complexity\",\n                \"Understanding the Complexity of Induced Subgraph Isomorphisms\",\n                \"Arboricity and subgraph listing algorithms\",\n                \"Upper bounds to the clique width of graphs\",\n                \"Counting matchings of size k is W[1]-hard\",\n                \"The simple, little and slow things count: On parameterized counting complexity\",\n                \"Homomorphisms are a good basis for counting small subgraphs\",\n                \"Parameterized Algorithms\",\n                \"The complexity of counting homomorphisms seen from the other side\",\n                \"Approximately counting and sampling small witnesses using a colourful decision oracle\",\n                \"Counting Induced Subgraphs: An Algebraic Approach to #W[1]-hardness\",\n                \"Structural Tractability of Counting of Solutions to Conjunctive Queries\",\n                \"An approximation trichotomy for Boolean #CSP\",\n                \"Almost Optimal Bounds for Sublinear-Time Sampling of 𝑘-Cliques: Sampling Cliques is Harder Than Counting\",\n                \"Faster sublinear approximation of the number of k-cliques in low-arboricity graphs\",\n                \"Subgraph Isomorphism in Planar Graphs and Related Problems\",\n                \"Listing all maximal cliques in large sparse real-world graphs\",\n                \"Improved induced matchings in sparse graphs\",\n                \"The Parameterized Complexity of Counting Problems\",\n                \"Parameterized Complexity Theory\",\n                \"Counting Subgraphs in Degenerate Graphs\",\n                \"The complexity of homomorphism and constraint satisfaction problems seen from the other side\",\n                \"On tree width, bramble size, and expansion\",\n                \"On the complexity of SAT\",\n                \"The parameterised complexity of counting connected subgraphs and graph motifs\",\n                \"Dimer Statistics and Phase Transitions\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]20 based on the context and research area of Exact and Approximate Pattern Counting in Degenerate Graphs: New Algorithms, Hardness Results, and Complexity Dichotomies. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}