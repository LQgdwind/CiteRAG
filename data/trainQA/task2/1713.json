{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: Exact and Approximate Pattern Counting in Degenerate Graphs: New Algorithms, Hardness Results, and Complexity Dichotomies\n\nPaper Abstract: \n\nPaper Section Text:\nGraphs are simple and without self-loops, unless stated otherwise. Given a graph G=(V,E)ğºğ‘‰ğ¸G=(V,E), a subgraph of GğºG is a graph obtained by deleting edges and vertices, and an induced subgraph of GğºG is a graph obtained by deleting vertices only. Given a graph Hğ»H, we write ğ–²ğ—ğ–»â€‹(Hâ†’G)ğ–²ğ—ğ–»â†’ğ»ğº\\mathsf{Sub}(H\\!\\rightarrow\\!G) (ğ–¨ğ—‡ğ–½ğ–²ğ—ğ–»â€‹(Hâ†’G)ğ–¨ğ—‡ğ–½ğ–²ğ—ğ–»â†’ğ»ğº\\mathsf{IndSub}(H\\!\\rightarrow\\!G)) for the set of all subgraphs (induced subgraphs) of GğºG isomorphic to Hğ»H.\nGiven a vertex subset SâŠ†Vğ‘†ğ‘‰S\\subseteq V, we write Gâ€‹[S]ğºdelimited-[]ğ‘†G[S] for the graph induced by Sğ‘†S, that is Vâ€‹(Gâ€‹[S])=Sğ‘‰ğºdelimited-[]ğ‘†ğ‘†V(G[S])=S and Eâ€‹(Gâ€‹[S])=Eâ€‹(G)âˆ©S2ğ¸ğºdelimited-[]ğ‘†ğ¸ğºsuperscriptğ‘†2E(G[S])=E(G)\\cap S^{2}. Given an edge subset SâŠ†Eğ‘†ğ¸S\\subseteq E, we write Gâ€‹[S]ğºdelimited-[]ğ‘†G[S] for the edge-subgraph (V,S)ğ‘‰ğ‘†(V,S) of GğºG. A homomorphism from a graph Hğ»H to a graph GğºG is a mapping Ï†:Vâ€‹(H)â†’Vâ€‹(G):ğœ‘â†’ğ‘‰ğ»ğ‘‰ğº\\varphi:V(H)\\rightarrow V(G) that preserves the edges, i.e., for each edge {u,v}âˆˆEâ€‹(H)ğ‘¢ğ‘£ğ¸ğ»\\{u,v\\}\\in E(H) we have {Ï†â€‹(u),Ï†â€‹(v)}âˆˆEâ€‹(G)ğœ‘ğ‘¢ğœ‘ğ‘£ğ¸ğº\\{\\varphi(u),\\varphi(v)\\}\\in E(G). An injective homomorphism is called an embedding, and an embedding is called a strong embedding if {u,v}âˆˆEâ€‹(H)ğ‘¢ğ‘£ğ¸ğ»\\{u,v\\}\\in E(H) is equivalent to {Ï†â€‹(u),Ï†â€‹(v)}âˆˆEâ€‹(G)ğœ‘ğ‘¢ğœ‘ğ‘£ğ¸ğº\\{\\varphi(u),\\varphi(v)\\}\\in E(G). We write ğ–§ğ—ˆğ—†â€‹(Hâ†’G)ğ–§ğ—ˆğ—†â†’ğ»ğº\\mathsf{Hom}(H\\!\\rightarrow\\!G), ğ–¤ğ—†ğ–»â€‹(Hâ†’G)ğ–¤ğ—†ğ–»â†’ğ»ğº\\mathsf{Emb}(H\\!\\rightarrow\\!G), and ğ–²ğ—ğ—‹ğ–¤ğ—†ğ–»â€‹(Hâ†’G)ğ–²ğ—ğ—‹ğ–¤ğ—†ğ–»â†’ğ»ğº\\mathsf{StrEmb}(H\\!\\rightarrow\\!G) for the sets of homomorphisms, embeddings, and strong embeddings, respectively, from Hğ»H to GğºG. Finally, we write ğ– ğ—ğ—â€‹(H)ğ– ğ—ğ—ğ»\\mathsf{Aut}(H) for the set of all automorphisms of Hğ»H.\nWe will use the following well-known relationships: For every pair of graphs Hğ»H and GğºG, we have |ğ–¤ğ—†ğ–»â€‹(Hâ†’G)|=|ğ– ğ—ğ—â€‹(H)|â‹…|ğ–²ğ—ğ–»â€‹(Hâ†’G)|ğ–¤ğ—†ğ–»â†’ğ»ğºâ‹…ğ– ğ—ğ—ğ»ğ–²ğ—ğ–»â†’ğ»ğº|\\mbox{$\\mathsf{Emb}(H\\!\\rightarrow\\!G)$}|=|\\mathsf{Aut}(H)|\\cdot|\\mbox{$\\mathsf{Sub}(H\\!\\rightarrow\\!G)$}| and |ğ–²ğ—ğ—‹ğ–¤ğ—†ğ–»â€‹(Hâ†’G)|=|ğ– ğ—ğ—â€‹(H)|â‹…|ğ–¨ğ—‡ğ–½ğ–²ğ—ğ–»â€‹(Hâ†’G)|ğ–²ğ—ğ—‹ğ–¤ğ—†ğ–»â†’ğ»ğºâ‹…ğ– ğ—ğ—ğ»ğ–¨ğ—‡ğ–½ğ–²ğ—ğ–»â†’ğ»ğº|\\mbox{$\\mathsf{StrEmb}(H\\!\\rightarrow\\!G)$}|=|\\mathsf{Aut}(H)|\\cdot|\\mbox{$\\mathsf{IndSub}(H\\!\\rightarrow\\!G)$}|. We will also need the following transformations.\nGiven a partition ÏğœŒ\\rho of Vâ€‹(G)ğ‘‰ğºV(G), the quotient graph (or just the quotient) G/ÏğºğœŒG/\\rho is obtained from GğºG by identifying all vertices that are in the same block of ÏğœŒ\\rho and deleting multiple edges. We point out that G/ÏğºğœŒG/\\rho might, a priori, have self-loops, but will usually only consider those quotients without self-loops.111111A quotient without self-loops is called a spasm by some authors, see for instanceÂ [ref]20.\nGiven a function f:AÃ—Bâ†’C:ğ‘“â†’ğ´ğµğ¶f:A\\times B\\rightarrow C and an element aâˆˆAğ‘ğ´a\\in A, we write fâ€‹(a,â‹†):Bâ†’C:ğ‘“ğ‘â‹†â†’ğµğ¶f(a,\\star):B\\rightarrow C for the function that maps bâˆˆBğ‘ğµb\\in B to fâ€‹(a,b)ğ‘“ğ‘ğ‘f(a,b). Let Hğ»H be a graph. We have where the sum is taken over all partitions of Vâ€‹(H)ğ‘‰ğ»V(H), âŠ¥bottom\\bot is the finest partition, and is the MÃ¶bius function of the partition lattice of Vâ€‹(H)ğ‘‰ğ»V(H). Let Hğ»H be a graph. We have where the sum is taken over all (isomorphism classes of) graphs, and {Hâ€²âŠ‡H}ğ»superscriptğ»â€²\\{H^{\\prime}\\supseteq H\\} contains all sets SâˆˆVâ€‹(H)2âˆ–Eâ€‹(H)ğ‘†ğ‘‰superscriptğ»2ğ¸ğ»S\\in V(H)^{2}\\setminus E(H) such that (Vâ€‹(H),Eâ€‹(H)âˆªS)ğ‘‰ğ»ğ¸ğ»ğ‘†(V(H),E(H)\\cup S) is isomorphic to Hâ€²superscriptğ»â€²H^{\\prime}. A graph GğºG is Hğ»H-coloured if it comes with a homomorphism câˆˆğ–§ğ—ˆğ—†â€‹(Gâ†’H)ğ‘ğ–§ğ—ˆğ—†â†’ğºğ»c\\in\\mbox{$\\mathsf{Hom}(G\\!\\rightarrow\\!H)$}, called colouring. A homomorphism Ï†âˆˆğ–§ğ—ˆğ—†â€‹(Hâ†’G)ğœ‘ğ–§ğ—ˆğ—†â†’ğ»ğº\\varphi\\in\\mbox{$\\mathsf{Hom}(H\\!\\rightarrow\\!G)$} is colour-prescribed if câ€‹(Ï†â€‹(v))=vğ‘ğœ‘ğ‘£ğ‘£c(\\varphi(v))=v for all vâˆˆVâ€‹(H)ğ‘£ğ‘‰ğ»v\\in V(H).\nThis means that each vâˆˆVâ€‹(H)ğ‘£ğ‘‰ğ»v\\in V(H) must be mapped to a vertex of GğºG that is coloured with vğ‘£v. We write ğ–¼ğ—‰â€‹-â€‹ğ–§ğ—ˆğ—†â€‹(Hâ†’G)ğ–¼ğ—‰-ğ–§ğ—ˆğ—†â†’ğ»ğº\\mathsf{cp}\\textsc{-}\\mathsf{Hom}(H\\!\\rightarrow\\!G) for the set of all colour-prescribed homomorphisms from Hğ»H to GğºG. Moreover, Ï†ğœ‘\\varphi is called colourful if câ€‹(Ï†â€‹(Vâ€‹(H)))=Vâ€‹(H)ğ‘ğœ‘ğ‘‰ğ»ğ‘‰ğ»c(\\varphi(V(H)))=V(H), that is, each colour is met precisely once. We write ğ–¼ğ–¿â€‹-â€‹ğ–§ğ—ˆğ—†â€‹(Hâ†’G)ğ–¼ğ–¿-ğ–§ğ—ˆğ—†â†’ğ»ğº\\mathsf{cf}\\textsc{-}\\mathsf{Hom}(H\\!\\rightarrow\\!G) for the set of all colourful homomorphisms from Hğ»H to GğºG. We always assume that colourings are surjective, since otherwise ğ–¼ğ—‰â€‹-â€‹ğ–§ğ—ˆğ—†â€‹(Hâ†’G)=ğ–¼ğ–¿â€‹-â€‹ğ–§ğ—ˆğ—†â€‹(Hâ†’G)=âˆ…ğ–¼ğ—‰-ğ–§ğ—ˆğ—†â†’ğ»ğºğ–¼ğ–¿-ğ–§ğ—ˆğ—†â†’ğ»ğº\\mathsf{cp}\\textsc{-}\\mathsf{Hom}(H\\!\\rightarrow\\!G)=\\mathsf{cf}\\textsc{-}\\mathsf{Hom}(H\\!\\rightarrow\\!G)=\\emptyset.\nFor any SâŠ†Vâ€‹(H)ğ‘†ğ‘‰ğ»S\\subseteq V(H), let Gâˆ’Sğºğ‘†G-S be the graph obtained from GğºG by deleting all vertices coloured with some vertex in Sğ‘†S.\nWe will use the following two well-known facts (see for instanceÂ [52, SectionÂ 2.5]). |ğ–¼ğ—‰â€‹-â€‹ğ–§ğ—ˆğ—†â€‹(Hâ†’G)|=|ğ– ğ—ğ—â€‹(H)|âˆ’1â‹…|ğ–¼ğ–¿â€‹-â€‹ğ–§ğ—ˆğ—†â€‹(Hâ†’G)|ğ–¼ğ—‰-ğ–§ğ—ˆğ—†â†’ğ»ğºâ‹…superscriptğ– ğ—ğ—ğ»1ğ–¼ğ–¿-ğ–§ğ—ˆğ—†â†’ğ»ğº|\\mathsf{cp}\\textsc{-}\\mathsf{Hom}(H\\!\\rightarrow\\!G)|=|\\mathsf{Aut}(H)|^{-1}\\cdot|\\mathsf{cf}\\textsc{-}\\mathsf{Hom}(H\\!\\rightarrow\\!G)|. |ğ–¼ğ–¿â€‹-â€‹ğ–§ğ—ˆğ—†â€‹(Hâ†’G)|=âˆ‘SâŠ†Vâ€‹(H)(âˆ’1)|S|â‹…|ğ–§ğ—ˆğ—†â€‹(Hâ†’Gâˆ’S)|ğ–¼ğ–¿-ğ–§ğ—ˆğ—†â†’ğ»ğºsubscriptğ‘†ğ‘‰ğ»â‹…superscript1ğ‘†ğ–§ğ—ˆğ—†â†’ğ»ğºğ‘†|\\mathsf{cf}\\textsc{-}\\mathsf{Hom}(H\\!\\rightarrow\\!G)|=\\sum_{S\\subseteq V(H)}(-1)^{|S|}\\cdot|\\mbox{$\\mathsf{Hom}(H\\!\\rightarrow\\!G-S)$}|. A graph Fğ¹F is a minor of a graph Hğ»H if it can be obtained from Hğ»H by a sequence of edge contractions, edge deletions, and vertex deletions. It is well known that minors can be equivalently defined via models: a model of Fğ¹F in Hğ»H is a mapping from Vâ€‹(F)ğ‘‰ğ¹V(F) to nonempty disjoint subsets of Vâ€‹(H)ğ‘‰ğ»V(H), that we call blocks and denote by {Bu:uâˆˆVâ€‹(F)}conditional-setsubscriptğµğ‘¢ğ‘¢ğ‘‰ğ¹\\{B_{u}:u\\in V(F)\\}, such that Hâ€‹[Bu]ğ»delimited-[]subscriptğµğ‘¢H[B_{u}] is connected for all uâˆˆVâ€‹(F)ğ‘¢ğ‘‰ğ¹u\\in V(F), and that Hğ»H has an edge between Busubscriptğµğ‘¢B_{u} and Bvsubscriptğµğ‘£B_{v} if {u,v}âˆˆEâ€‹(F)ğ‘¢ğ‘£ğ¸ğ¹\\{u,v\\}\\in E(F). We emphasise that Buâ‰ âˆ…subscriptğµğ‘¢B_{u}\\neq\\emptyset for all uâˆˆVâ€‹(F)ğ‘¢ğ‘‰ğ¹u\\in V(F).\nA graph Fğ¹F is an induced minor of a graph Hğ»H if Fğ¹F can be obtained from Hğ»H by a sequence of edge contractions and vertex deletions. Induced minors can be expressed via witness structures (cf.Â ), which are identical to models save for the fact that Hğ»H has an edge between Busubscriptğµğ‘¢B_{u} and Bvsubscriptğµğ‘£B_{v} if and only if {u,v}âˆˆEâ€‹(F)ğ‘¢ğ‘£ğ¸ğ¹\\{u,v\\}\\in E(F). We give a concise introduction to parameterized counting problems and fine-grained complexity theory. For more details see, e.g.,Â [34, Chapter 14]. A parameterized counting problem is a pair (P,Îº)ğ‘ƒğœ…(P,\\kappa), where P:{0,1}âˆ—â†’â„•:ğ‘ƒâ†’superscript01âˆ—â„•P:\\{0,1\\}^{\\ast}\\rightarrow\\mathbb{N} is a counting problem and Îº:{0,1}âˆ—â†’â„•:ğœ…â†’superscript01âˆ—â„•\\kappa:\\{0,1\\}^{\\ast}\\rightarrow\\mathbb{N} is a parameterization. For example, the problem #â€‹Clique#Clique\\#\\textsc{Clique} expects as input a graph GğºG and a positive integer kğ‘˜k, and the task is to compute the number of kğ‘˜k-cliques inÂ GğºG, that is, Pâ€‹(G,k):=|ğ–²ğ—ğ–»â€‹(Kkâ†’G)|assignğ‘ƒğºğ‘˜ğ–²ğ—ğ–»â†’subscriptğ¾ğ‘˜ğºP(G,k):=|\\mbox{$\\mathsf{Sub}(K_{k}\\!\\rightarrow\\!G)$}|. The parameterization is given by kğ‘˜k, that is, Îºâ€‹(G,k):=kassignğœ…ğºğ‘˜ğ‘˜\\kappa(G,k):=k.\nA parameterized (counting) problem is called fixed-parameter tractable (FPT) if there exists a computable function fğ‘“f such that the problem can be solved in time fâ€‹(Îºâ€‹(x))â‹…|x|Oâ€‹(1)â‹…ğ‘“ğœ…ğ‘¥superscriptğ‘¥ğ‘‚1f(\\kappa(x))\\cdot|x|^{O(1)}, where xâˆˆ{0,1}âˆ—ğ‘¥superscript01âˆ—x\\in\\{0,1\\}^{\\ast} is the input instance. An algorithm running in this time is called an FPT algorithm.\nA parameterized Turing-reduction from (P,Îº)ğ‘ƒğœ…(P,\\kappa) to (Pâ€²,Îºâ€²)superscriptğ‘ƒâ€²superscriptğœ…â€²(P^{\\prime},\\kappa^{\\prime}) is an FPT algorithm ğ’œğ’œ\\mathcal{A} equipped with oracle access to Pâ€²superscriptğ‘ƒâ€²P^{\\prime} that computes Pâ€‹(x)ğ‘ƒğ‘¥P(x). Additionally, there must be a computable functionÂ fğ‘“f such that for any input xğ‘¥x, the parameter Îºâ€²â€‹(y)superscriptğœ…â€²ğ‘¦\\kappa^{\\prime}(y) of each oracle query yğ‘¦y must be bounded by fâ€‹(Îºâ€‹(x))ğ‘“ğœ…ğ‘¥f(\\kappa(x)). We write (P,Îº)â‰¤Tfpt(Pâ€²,Îºâ€²)subscriptsuperscriptfptTğ‘ƒğœ…superscriptğ‘ƒâ€²superscriptğœ…â€²(P,\\kappa)\\leq^{\\mathrm{fpt}}_{\\mathrm{T}}(P^{\\prime},\\kappa^{\\prime}) if a parameterized Turing-reduction exists.\nThe notion of parameterized intractability is given by #â€‹ğ–¶â€‹#ğ–¶delimited-[]1\\#\\mathsf{W}-hardness:121212We use the definition via a complete problem and refer the reader toÂ [34, Chapter 14] for a more structural and machine-based definition of #â€‹ğ–¶â€‹#ğ–¶delimited-[]1\\#\\mathsf{W}. A parameterized counting problem (P,Îº)ğ‘ƒğœ…(P,\\kappa) is #â€‹ğ–¶â€‹#ğ–¶delimited-[]1\\#\\mathsf{W}-hard if #â€‹Cliqueâ‰¤Tfpt(P,Îº)subscriptsuperscriptfptT#Cliqueğ‘ƒğœ…\\#\\textsc{Clique}\\leq^{\\mathrm{fpt}}_{\\mathrm{T}}(P,\\kappa). It is known that #â€‹ğ–¶â€‹#ğ–¶delimited-[]1\\#\\mathsf{W}-hard problems are not fixed-parameter tractable unless ETH, defined below, fails. The Exponential Time Hypothesis (ETH) asserts that the problem 3â€‹-SAT3-SAT3\\textsc{-SAT} cannot be solved in time expâ¡(oâ€‹(n))ğ‘œğ‘›\\exp(o(n)) where nğ‘›n is the number of variables of the input formula. Our hardness results will rely on the following theorem, which is an immediate consequence of the works of Dalmau and JonssonÂ  and MarxÂ .\nWe include a proof for the readersâ€™ convenience. Let Cğ¶C be a computable class of graphs. If Cğ¶C has unbounded treewidth131313We will exclusively rely on treewidth in a black-box manner. Thus we avoid stating the definition and refer the reader e.g.Â to ChapterÂ 7 inÂ . then #â€‹cp-Homâ€‹(C)#cp-Homğ¶\\#\\textsc{cp-Hom}(C) is #â€‹ğ–¶â€‹#ğ–¶delimited-[]1\\#\\mathsf{W}-hard and cannot be solved in time\nfâ€‹(|H|)â‹…|G|oâ€‹(ğ—ğ—â€‹(H)/logâ¡twâ¡(H))â‹…ğ‘“ğ»superscriptğºğ‘œğ—ğ—ğ»twğ»f(|H|)\\cdot|G|^{o(\\mathsf{tw}(H)/\\log\\operatorname{tw}(H))}\nfor any function fğ‘“f, unless ETH fails. The #â€‹ğ–¶â€‹#ğ–¶delimited-[]1\\#\\mathsf{W}-hardness follows by the #â€‹ğ–¶â€‹#ğ–¶delimited-[]1\\#\\mathsf{W}-hardness of #â€‹Homâ€‹(C)#Homğ¶\\#\\textsc{Hom}(C), seeÂ , and by a reduction from #â€‹Homâ€‹(C)#Homğ¶\\#\\textsc{Hom}(C) to #â€‹cp-Homâ€‹(C)#cp-Homğ¶\\#\\textsc{cp-Hom}(C), seeÂ .\nThe lower bound follows from a result on the partitioned subgraph isomorphism problem, seeÂ , which tightly reduces to #â€‹cp-Homâ€‹(C)#cp-Homğ¶\\#\\textsc{cp-Hom}(C), seeÂ [54, SectionÂ 2]).\nâˆ We will apply TheoremÂ 22 to the following family â„±â„±\\mathcal{F} of regular expanders: There exists a family of graphs â„±={Fk}kâ‰¥1â„±subscriptsubscriptğ¹ğ‘˜ğ‘˜1\\mathcal{F}=\\{F_{k}\\}_{k\\geq 1} and constants k0,c>0subscriptğ‘˜0ğ‘0k_{0},c>0 such that for all kâ‰¥k0ğ‘˜subscriptğ‘˜0k\\geq k_{0} we have ğ—ğ—â€‹(Fk)â‰¥kğ—ğ—subscriptğ¹ğ‘˜ğ‘˜\\mathsf{tw}(F_{k})\\geq k and |Vâ€‹(Fk)|â‰¤câ€‹kğ‘‰subscriptğ¹ğ‘˜ğ‘ğ‘˜|V(F_{k})|\\leq ck and |Eâ€‹(Fk)|â‰¤câ€‹kğ¸subscriptğ¹ğ‘˜ğ‘ğ‘˜|E(F_{k})|\\leq ck. The degeneracy dâ€‹(G)ğ‘‘ğºd(G) of a graph GğºG can be defined as the smallest integer dğ‘‘d such that there exists an acyclic orientation of GğºG with maximum out-degree bounded by dğ‘‘d. We can assume that such an orientation is given, since it can be found in time Oâ€‹(|Eâ€‹(G)|)ğ‘‚ğ¸ğºO(|E(G)|)Â . Our running time upper bounds rely on the dag tree decomposition ofÂ [ref]8 and the dynamic program that it yields. Here, we adopt a generalisation of the original definition of dag tree decomposition. We need this generalisation for some of our results in SectionÂ 6.2. Let H=(V,A)subscriptğ»ğ‘‰ğ´{H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}}=(V,A) be any directed acyclic graph. We denote by S=Sâ€‹(H)ğ‘†ğ‘†subscriptğ»S=S({H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}}) the set of sources of Hsubscriptğ»{H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}}, that is, the vertices of indegree zero. For any BâŠ†Vğµğ‘‰B\\subseteq V, we let Hâ€‹(B)subscriptğ»ğµ{H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}}(B) be the subgraph of Hsubscriptğ»{H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}} induced by all vertices reachable from some vertex in BğµB. For any tree ğ’¯ğ’¯\\mathcal{T} and any two vertices Bâ€²,Bâ€²â€²superscriptğµâ€²superscriptğµâ€²â€²B^{\\prime},B^{\\prime\\prime} of ğ’¯ğ’¯\\mathcal{T}, we denote by ğ’¯â€‹(Bâ€²,Bâ€²â€²)ğ’¯superscriptğµâ€²superscriptğµâ€²â€²\\mathcal{T}(B^{\\prime},B^{\\prime\\prime}) the unique simple path between Bâ€²superscriptğµâ€²B^{\\prime} and Bâ€²â€²superscriptğµâ€²â€²B^{\\prime\\prime} in ğ’¯ğ’¯\\mathcal{T}. A (generalised) dag tree decomposition (d.t.d.) of Hsubscriptğ»{H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}} is a rooted tree ğ’¯=(â„¬,â„°)ğ’¯â„¬â„°\\mathcal{T}=(\\mathcal{B},\\mathcal{E}) such that: BâŠ†Vâ€‹(H)ğµğ‘‰ğ»B\\subseteq V(H) for all Bâˆˆâ„¬ğµâ„¬B\\in\\mathcal{B} â‹ƒBâˆˆâ„¬Vâ€‹(Hâ€‹(B))=Vâ€‹(H)subscriptğµâ„¬ğ‘‰subscriptğ»ğµğ‘‰ğ»\\bigcup_{B\\in\\mathcal{B}}V({H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}}(B))=V(H) for all B,B1,B2âˆˆâ„¬ğµsubscriptğµ1subscriptğµ2â„¬B,B_{1},B_{2}\\in\\mathcal{B}, if Bâˆˆğ’¯â€‹(B1,B2)ğµğ’¯subscriptğµ1subscriptğµ2B\\in\\mathcal{T}(B_{1},B_{2}) then Vâ€‹(Hâ€‹(B1))âˆ©Vâ€‹(Hâ€‹(B2))âŠ†Vâ€‹(Hâ€‹(B))ğ‘‰subscriptğ»subscriptğµ1ğ‘‰subscriptğ»subscriptğµ2ğ‘‰subscriptğ»ğµV({H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}}(B_{1}))\\cap V({H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}}(B_{2}))\\subseteq V({H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}}(B)) The width of ğ’¯ğ’¯\\mathcal{T} is Ï„â€‹(ğ’¯)=maxBâˆˆğ’¯â¡|B|ğœğ’¯subscriptğµğ’¯ğµ\\tau(\\mathcal{T})=\\max_{B\\in\\mathcal{T}}|B|. The (generalised) dag treewidth of Hsubscriptğ»{H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}} is Ï„â€‹(H)=minğ’¯â¡Ï„â€‹(ğ’¯)ğœsubscriptğ»subscriptğ’¯ğœğ’¯\\tau({H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}})=\\min_{\\mathcal{T}}\\tau(\\mathcal{T}) where the minimum is over all possible (generalised) d.t.d.â€™s of Hsubscriptğ»{H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}}. It is immediate to verify that if ğ’¯ğ’¯\\mathcal{T} is a d.t.d.Â of Hsubscriptğ»{H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}} according toÂ [ref]8 then ğ’¯ğ’¯\\mathcal{T} is a generalised d.t.d.Â according to DefinitionÂ 24 as well. It is easy to verify that the dynamic program ofÂ [ref]8 and all subsequent bounds continue to hold when ğ’¯ğ’¯\\mathcal{T} is a generalised d.t.d., too. Hence for our upper bounds we can use Ï„â€‹(H)ğœsubscriptğ»\\tau({H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}}) with Ï„ğœ\\tau as in DefinitionÂ 24. Now let Hğ»H be any simple graph. We let Î£â€‹(H)Î£ğ»\\Sigma(H) be the set of all possible acyclic orientations Hsubscriptğ»{H}_{\\parbox{5.0pt}{\\scalebox{0.8}{ \\leavevmode\\hbox to5.5pt{\\vbox to0.5pt{\\pgfpicture\\makeatletter\\hbox{\\hskip 0.25pt\\lower-0.25pt\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@rgb@stroke{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@color@rgb@fill{0}{0}{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.4pt}\\pgfsys@invoke{ }\\nullfont\\pgfsys@beginscope\\pgfsys@invoke{ }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hbox to0.0pt{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgfstrokecolor}{rgb}{0,0,0}\\pgfsys@color@gray@stroke{0}\\pgfsys@invoke{ }\\pgfsys@setlinewidth{0.5pt}\\pgfsys@invoke{ }{{}{{}}{}\n{{}{}}{}{}{}{}{}{{}}\\pgfsys@moveto{0.0pt}{0.0pt}\\pgfsys@lineto{2.85004pt}{0.0pt}\\pgfsys@stroke\\pgfsys@invoke{ }{{}{{}}{}{}{{}}{{{}}{{{}}{\\pgfsys@beginscope\\pgfsys@invoke{ }\\definecolor[named]{pgffillcolor}{rgb}{0,0,0}\\pgfsys@color@gray@fill{0}\\pgfsys@invoke{ }\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{2.85004pt}{0.0pt}\\pgfsys@invoke{ }\\pgfsys@invoke{  \\lxSVG@closescope  }\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope}}{{}}}}\n}\n\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope{}{}{}\\hss}\\pgfsys@discardpath\\pgfsys@invoke{\\lxSVG@closescope }\\pgfsys@endscope\\hss}}\\lxSVG@closescope\\endpgfpicture}}}}} of Hğ»H. We let Râ€‹(H)ğ‘…ğ»R(H) be the set of all partitions ÏğœŒ\\rho of Vâ€‹(H)ğ‘‰ğ»V(H) such that the quotient H/Ïğ»ğœŒH/\\rho is without self-loops. We let Dâ€‹(H)ğ·ğ»D(H) be the set of all supergraphs of Hğ»H on the same vertex set Vâ€‹(H)ğ‘‰ğ»V(H). FollowingÂ [ref]8, we define: By the discussion above, the parameters Ï„1,Ï„2,Ï„3subscriptğœ1subscriptğœ2subscriptğœ3\\tau_{1},\\tau_{2},\\tau_{3} defined above in terms of DefinitionÂ 24 are bounded from above by their homologues defined inÂ [ref]8. Therefore from now on we omit the adjective â€œgeneralisedâ€ unless necessary.\n\nReference markers found: [20]\n\nContext windows for each [ref]:\n[ref]20: might, a priori, have self-loops, but will usually only consider those quotients without self-loops.111111A quotient without self-loops is called a spasm by some authors, see for instanceÂ [ref]20.\nGiven a function f:AÃ—Bâ†’C:ğ‘“â†’ğ´ğµğ¶f:A\\times B\\rightarrow C and an element aâˆˆAğ‘ğ´a\\in A, we write fâ€‹(a,â‹†):Bâ†’C:ğ‘“ğ‘â‹†â†’ğµğ¶f(a,\\star):B\\rightarrow C for the function that maps bâˆˆBğ‘ğµb\\in B to\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 20,\n            \"titles\": [\n                \"Complexity of counting subgraphs: only the boundedness of the vertex-cover number counts\",\n                \"Biomolecular network motif counting and discovery by color coding\",\n                \"Edge orbits and edge-deleted subgraphs\",\n                \"When is Approximate Counting for Conjunctive Queries Tractable?\",\n                \"Approximation Algorithms for Some Parameterized Counting Problems\",\n                \"Linear Time Subgraph Counting, Graph Degeneracy, and the Chasm at Size Six\",\n                \"Near-Linear Time Homomorphism Counting in Bounded Degeneracy Graphs: The Barrier of Long Induced Cycles\",\n                \"Faster Subgraph Counting in Sparse Graphs\",\n                \"Faster algorithms for counting subgraphs in sparse graphs\",\n                \"Current Algorithms for Detecting Subgraphs of Bounded Treewidth are Probably Optimal\",\n                \"Approximate Counting CSP Seen from the Other Side\",\n                \"A Trichotomy in the Complexity of Counting Answers to Conjunctive Queries\",\n                \"Counting Answers to Existential Positive Queries: A Complexity Classification\",\n                \"Tight lower bounds for certain parameterized NP-hard problems\",\n                \"Strong computational lower bounds via parameterized complexity\",\n                \"Understanding the Complexity of Induced Subgraph Isomorphisms\",\n                \"Arboricity and subgraph listing algorithms\",\n                \"Upper bounds to the clique width of graphs\",\n                \"Counting matchings of size k is W[1]-hard\",\n                \"The simple, little and slow things count: On parameterized counting complexity\",\n                \"Homomorphisms are a good basis for counting small subgraphs\",\n                \"Parameterized Algorithms\",\n                \"The complexity of counting homomorphisms seen from the other side\",\n                \"Approximately counting and sampling small witnesses using a colourful decision oracle\",\n                \"Counting Induced Subgraphs: An Algebraic Approach to #W[1]-hardness\",\n                \"Structural Tractability of Counting of Solutions to Conjunctive Queries\",\n                \"An approximation trichotomy for Boolean #CSP\",\n                \"Almost Optimal Bounds for Sublinear-Time Sampling of ğ‘˜-Cliques: Sampling Cliques is Harder Than Counting\",\n                \"Faster sublinear approximation of the number of k-cliques in low-arboricity graphs\",\n                \"Subgraph Isomorphism in Planar Graphs and Related Problems\",\n                \"Listing all maximal cliques in large sparse real-world graphs\",\n                \"Improved induced matchings in sparse graphs\",\n                \"The Parameterized Complexity of Counting Problems\",\n                \"Parameterized Complexity Theory\",\n                \"Counting Subgraphs in Degenerate Graphs\",\n                \"The complexity of homomorphism and constraint satisfaction problems seen from the other side\",\n                \"On tree width, bramble size, and expansion\",\n                \"On the complexity of SAT\",\n                \"The parameterised complexity of counting connected subgraphs and graph motifs\",\n                \"Dimer Statistics and Phase Transitions\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]20 based on the context and research area of Exact and Approximate Pattern Counting in Degenerate Graphs: New Algorithms, Hardness Results, and Complexity Dichotomies. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}