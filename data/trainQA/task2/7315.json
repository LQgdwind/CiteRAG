{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: Computationally Bounded Robust Compilation and Universally Composable Security\n\nPaper Abstract: \n\nPaper Section Text:\nIn cryptography, universal composability (𝖴𝖢𝖴𝖢\\mathsf{UC})  is a framework for the specification and analysis of cryptographic protocols with a key guarantee about compositionality   :\nIf a protocol is 𝖴𝖢𝖴𝖢\\mathsf{UC}-secure, it behaves like some high-level, secure-by-construction ideal functionality no matter what the protocol interacts with.\nIf that protocol is then used as a building block inside a larger protocol,\nit is safe to replace the smaller protocol with its ideal functionality when reasoning about the security of the larger protocol.\nIn other words, 𝖴𝖢𝖴𝖢\\mathsf{UC} protocols are secure even when composed with larger protocols. Proving that a protocol attains 𝖴𝖢𝖴𝖢\\mathsf{UC} security is notoriously complex and error-prone, so it is important to provide ways to mechanize these proofs.\nPatrignani et al. [ref]43 recently identified a simple and scalable way to define proofs of 𝖴𝖢𝖴𝖢\\mathsf{UC} by relying on a surprising connection between 𝖴𝖢𝖴𝖢\\mathsf{UC} and Robust Compilation (𝑅𝐶𝑅𝐶\\mathit{RC}). 𝑅𝐶𝑅𝐶\\mathit{RC} is a hierarchy of criteria for secure compilation introduced by Abate et al.  .\nThe criteria describe the security of a compiler by which (hyper)properties 1 it preserves. Patrignani et al. [ref]43 identify that 𝖴𝖢𝖴𝖢\\mathsf{UC} security is deeply connected to Robust Hyperproperty-Preserving Compilation (LABEL:cr:\\rhclabel), the 𝑅𝐶𝑅𝐶\\mathit{RC} requirement that a compiler preserve arbitrary hyperproperties.\nUnfortunately, the connection they identify considers only perfect 𝖴𝖢𝖴𝖢\\mathsf{UC} security, where the protocol and ideal functionality exhibit identical behaviors.\nReal cryptographic protocols are almost never perfectly secure, they rely on cryptographic primitives whose security depends on computational hardness assumptions.\nAs a result, real “𝖴𝖢𝖴𝖢\\mathsf{UC}-secure” protocols rely on a computational definition of 𝖴𝖢𝖴𝖢\\mathsf{UC} security, which allows the protocol to behave differently from the ideal functionality, but only in ways that are indistinguishable to a computationally bounded adversary.\nSince the results of Patrignani et al. [ref]43 apply only to the perfect case, they provide little help in verifying the far more prevalent proofs of computational 𝖴𝖢𝖴𝖢\\mathsf{UC} security. For example, consider the following single-bit commitment protocol due to Canetti and Fischlin .\nTo commit to bit b𝑏b, generate a 4​n4𝑛4n-bit pseudo-random value 𝑝𝑟𝑝𝑟\\mathit{pr}, and output 𝑝𝑟𝑝𝑟\\mathit{pr} if b=0𝑏0b=0 and 𝑝𝑟⊕σdirect-sum𝑝𝑟𝜎\\mathit{pr}\\oplus\\sigma if b=1𝑏1b=1 where σ𝜎\\sigma is a public 4​n4𝑛4n-bit truly random value.\nThis protocol does not perfectly 𝖴𝖢𝖴𝖢\\mathsf{UC} emulate a functionality that simply indicates a bit has been committed by does nothing else before opening.\nAn unbounded attacker can simply check if the commitment is one of the (exponentially many) possible pseudo-random values and correctly guess the value of b𝑏b with overwhelming probability.\nThe protocol is, however, computationally 𝖴𝖢𝖴𝖢\\mathsf{UC} secure given a pseudo-random generator with the right structure ,\na proof that relies on a polynomial adversary’s inability to distinguish 𝑝𝑟𝑝𝑟\\mathit{pr} from a truly random value. This work addresses the limitation of Patrignani et al. [ref]43 by lifting their results to the computational case,\nallowing us to consider the security of protocols like Canetti and Fischlin’s commitment.\nTo accomplish this goal, we replace equality of behaviors with computational indistinguishability in both the 𝖴𝖢𝖴𝖢\\mathsf{UC} and 𝑅𝐶𝑅𝐶\\mathit{RC} theories.\nMaking this switch in both the 𝖴𝖢𝖴𝖢\\mathsf{UC} and 𝑅𝐶𝑅𝐶\\mathit{RC} contexts produces a notion of robust compilation that corresponds precisely to the already-established definition of computational 𝖴𝖢𝖴𝖢\\mathsf{UC} security. On the 𝑅𝐶𝑅𝐶\\mathit{RC} side, the change requires two fundamental modifications.\nFirst, Patrignani et al. [ref]43 describe programs as producing probability distributions over possible traces and consider a protocol (or compiler) secure if the ideal functionality (source program) and protocol (compiled program) produce identical distributions.\nComputational indistinguishability, however, does not relate individual distributions.\nIt relates families of distributions {Xn}subscript𝑋𝑛\\{X_{n}\\} and {Yn}subscript𝑌𝑛\\{Y_{n}\\} indexed by a security parameter n𝑛n,\nand requires an adversary’s ability to distinguish between Xnsubscript𝑋𝑛X_{n} and Ynsubscript𝑌𝑛Y_{n} to shrink quickly as n𝑛n grows.\nWe thus expand the definition of program behavior to include explicit security parameters.\nSecond, 𝑅𝐶𝑅𝐶\\mathit{RC} definitions in general define robustness for all programs against all adversaries, while computational 𝖴𝖢𝖴𝖢\\mathsf{UC}-security concerns only polynomial-time programs and attackers.\nWe therefore extend the 𝑅𝐶𝑅𝐶\\mathit{RC} framework to consider specific classes of protocols and attackers. With these two modifications to the 𝑅𝐶𝑅𝐶\\mathit{RC} theory of Abate et al. ,\nwe can define a new class of hyperproperties, 𝐶𝐻𝐶𝐻\\mathit{CH}, where each hyperproperty is the set of behaviors that are computationally indistinguishable from some ideal functionality.\nWe also define a notion of Computationally-Robust Hyperproperty-Preserving Compilation (LABEL:cr:\\comprhclabel), a new notion of 𝑅𝐶𝑅𝐶\\mathit{RC} that preserves 𝐶𝐻𝐶𝐻\\mathit{CH} against polynomial-time attackers.\nFinally, we prove that computational 𝖴𝖢𝖴𝖢\\mathsf{UC} security is equivalent to LABEL:cr:\\comprhclabel. Technically, proving LABEL:cr:\\comprhclabel amounts to proving that some source program (an ideal functionality), linked with an existentially bound attacker (a simulator) is computationally indistinguishable from a target program (a protocol).\nFortunately, existing tools such as CryptoVerif  provide ways to mechanize such proofs.\nThus, we showcase the ability to provide scalable proofs of computational 𝖴𝖢𝖴𝖢\\mathsf{UC} via proofs of LABEL:cr:\\comprhclabel by using CryptoVerif to mechanize a proof of computational indistinguishability for the Wireguard protocol 7. Notably, the results of lifting the connection between 𝖴𝖢𝖴𝖢\\mathsf{UC} and 𝑅𝐶𝑅𝐶\\mathit{RC} to the computational case contain nothing specific about computational indistinguishability and polynomial time.\nAs a result, we are able to substantially generalize the theory\nby using any equivalence ≡\\equiv defining indistinguishable behaviors,\nand an arbitrary predicate Q𝑄\\mathit{Q} on programs and contexts to define the class of programs and contexts.\nDoing so produces a notion of 𝖴𝖢𝖴𝖢\\mathsf{UC} security up-to ≡\\equiv, an 𝑅𝐶𝑅𝐶\\mathit{RC} notion of Q𝑄\\mathit{Q}-robust preservation of ≡\\equiv-hyperproperties, and a proof that the two are equivalent.\nThis result immediately subsumes the original connection of Patrignani et al. [ref]43, using == as ≡\\equiv and the trivial predicates allowing all programs and contexts,\nour lifted result, using computational indistinguishability as the equivalence and polynomial time as the predicate,\nand suggests more definitions and connections to explore. To summarize, the main contributions of this paper are: Section III explicitly models security parameters and computational indistinguishability in the 𝑅𝐶𝑅𝐶\\mathit{RC} framework, and uses these structures to extend the result of Patrignani et al. [ref]43 to computational security. Section IV generalizes the computational result to arbitrary indistinguishability relations, making perfect security, computational security, and many other interesting equivalences special cases of a general theorem. Section VI uses these results to mechanize the proof of 𝖴𝖢𝖴𝖢\\mathsf{UC} for the WireGuard protocol using the CryptoVerif tool, which provides computational security guarantees. The rest of this paper provides background notions related to the main results (Section II),\ninteresting details of the proofs of our main theorems (Section V),\nthe presentation of related work (Section VII), and conclusions (Section VIII). All theorems in Sections III, IV, and V are verified in the Isabelle/HOL theorem prover 2,\nwhile theorems in Section VI are verified in CryptoVerif .\nThe proof development is available at: https://uc-is-sc.github.io/.\n\nReference markers found: [43]\n\nContext windows for each [ref]:\n[ref]43: larger protocols. Proving that a protocol attains 𝖴𝖢𝖴𝖢\\mathsf{UC} security is notoriously complex and error-prone, so it is important to provide ways to mechanize these proofs.\nPatrignani et al. [ref]43 recently identified a simple and scalable way to define proofs of 𝖴𝖢𝖴𝖢\\mathsf{UC} by relying on a surprising connection between 𝖴𝖢𝖴𝖢\\mathsf{UC} and Robust Compilation (𝑅𝐶𝑅𝐶\\mathit{RC}).\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 43,\n            \"titles\": [\n                \"The Foundational Cryptography Framework\",\n                \"When good components go bad: Formally secure compilation despite dynamic compromise\",\n                \"Journey beyond full abstraction: Exploring robust property preservation for secure compilation\",\n                \"An extended account of trace-relating compiler correctness and secure compilation\",\n                \"SSProve: A foundational framework for modular cryptographic proofs in Coq\",\n                \"Cryptographic divergences: New techniques and new applications\",\n                \"Viaduct: An extensible, optimizing compiler for secure distributed programs\",\n                \"The reactive simulatability (RSIM) framework for asynchronous systems\",\n                \"An interactive prover for protocol verification in the computational model\",\n                \"Improved security proofs in lattice-based cryptography: Using the Rényi divergence rather than the statistical distance\",\n                \"Computer-aided security proofs for the working cryptographer\",\n                \"Abstract modeling of system communication in constructive cryptography using CryptHOL\",\n                \"An efficient cryptographic protocol verifier based on prolog rules\",\n                \"CryptoVerif: Cryptographic protocol verifier in the computational model\",\n                \"Proved generation of implementations from computationally secure protocol specifications\",\n                \"iUC: Flexible universal composability made simple\",\n                \"Universally composable security: a new paradigm for cryptographic protocols\",\n                \"Universally composable commitments\",\n                \"EasyUC: Using EasyCrypt to mechanize proofs of universally composable security\",\n                \"Nonmalleable information flow control\",\n                \"DEEPSEC: Deciding equivalence properties in security protocols theory and practice\",\n                \"Hyperproperties\",\n                \"Differential privacy\",\n                \"EasyCrypt: Computer-aided cryptographic proofs\",\n                \"Key confirmation in key exchange: A formal treatment and implications for TLS 1.3\",\n                \"Cryptographically sound implementations for typed information-flow security\",\n                \"Information-flow types for homomorphic encryptions\",\n                \"Owl: Compositional verification of security protocols via an information-flow type system\",\n                \"Security policies and security models\",\n                \"Foundations of Cryptography: Volume 1.\",\n                \"GNUC: A new universal composability framework\",\n                \"Polynomial runtime and composability\",\n                \"Isabelle/HOL proof assistant\",\n                \"Robust constant-time cryptography\",\n                \"Secure composition of robust and optimising compilers\",\n                \"The IITM model: a simple and expressive model for universal composability\",\n                \"ILC: A calculus for composable, computational cryptography\",\n                \"A mechanised cryptographic proof of the WireGuard virtual private network protocol\",\n                \"Proving noninterference and functional correctness using traces\",\n                \"Gaussian sampling over the integers: Efficient, generic, constant-time\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]43 based on the context and research area of Computationally Bounded Robust Compilation and Universally Composable Security. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}