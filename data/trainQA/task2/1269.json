{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: Quantum learning algorithms imply circuit lower bounds\n\nPaper Abstract: \n\nPaper Section Text:\nLet ℭℭ\\mathfrak{C} be a circuit class, and suppose that polynomial-size concepts from ℭℭ\\mathfrak{C} can be learned with error parameter ε≤1/2−γ𝜀12𝛾\\varepsilon\\leq 1/2-\\gamma in quantum time o​(γ2⋅2n/n)𝑜⋅superscript𝛾2superscript2𝑛𝑛o(\\gamma^{2}\\cdot 2^{n}/n). For a given k≥1𝑘1k\\geq 1, we argue that there is a language L∈𝖡𝖰𝖤=𝖡𝖰𝖳𝖨𝖬𝖤​[2O​(n)]𝐿𝖡𝖰𝖤𝖡𝖰𝖳𝖨𝖬𝖤delimited-[]superscript2𝑂𝑛L\\in\\mathsf{BQE}=\\mathsf{BQTIME}[2^{O(n)}] such that L∉ℭ​[nk]𝐿ℭdelimited-[]superscript𝑛𝑘L\\notin\\mathfrak{C}[n^{k}]. In contrast with known proofs of existing learning-to-lower-bound connections, our black-box “𝖯𝖱𝖦𝖯𝖱𝖦\\mathsf{PRG}-based” approach relies on the following basic principle from the theory of pseudorandomness: If we have a property 𝒫𝒫\\mathcal{P} of objects that is “dense” in the set of all possible objects, and a 𝖯𝖱𝖦𝖯𝖱𝖦\\mathsf{PRG} G𝐺G that is able to “fool” a class of “tests” that contain 𝒫𝒫\\mathcal{P} (e.g., when 𝒫𝒫\\mathcal{P} is easy to compute and G𝐺G fools predicates of bounded complexity), then some output of G𝐺G must be an object that satisfies 𝒫𝒫\\mathcal{P}. For us, 𝒫𝒫\\mathcal{P} is simply the class of functions that are not in ℭ​[nk]ℭdelimited-[]superscript𝑛𝑘\\mathfrak{C}[n^{k}]. We would like to find a (fixed) function in 𝒫𝒫\\mathcal{P} and compute according to it in 𝖡𝖰𝖳𝖨𝖬𝖤​[2O​(n)]𝖡𝖰𝖳𝖨𝖬𝖤delimited-[]superscript2𝑂𝑛\\mathsf{BQTIME}[2^{O(n)}]. We start off with the “ideal” plan for the proof, then discuss difficulties when implementing this strategy and how to overcome them.\n Ideal plan for the proof of Theorem 1: From a quantum learning algorithm 𝒜𝒜\\mathcal{A} that finds “structure”, we get a (uniform) quantum algorithm ℬℬ\\mathcal{B} that decides the “absence of structure” on an input string f∈{0,1}2n𝑓superscript01superscript2𝑛f\\in\\{0,1\\}^{2^{n}}. (Since a typical random string is “unstructured”, a pseudorandom string is likely to be accepted by ℬℬ\\mathcal{B}.) Assuming that there exists a 𝖯𝖱𝖦𝖯𝖱𝖦\\mathsf{PRG} G:{0,1}O​(n)→{0,1}2n:𝐺→superscript01𝑂𝑛superscript01superscript2𝑛G\\colon\\{0,1\\}^{O(n)}\\to\\{0,1\\}^{2^{n}} secure against uniform quantum computations, we use it with ℬℬ\\mathcal{B} as a “test” to find a function hn:{0,1}n→{0,1}:subscriptℎ𝑛→superscript01𝑛01h_{n}\\colon\\{0,1\\}^{n}\\to\\{0,1\\} that is not in ℭ​[nk]ℭdelimited-[]superscript𝑛𝑘\\mathfrak{C}[n^{k}], i.e., a function that “lacks structure”. Given an n𝑛n-bit input x𝑥x, the hard language L𝐿L outputs hn​(x)subscriptℎ𝑛𝑥h_{n}(x). We show that a pseudorandom generator G𝐺G with the desired parameters and guarantees exists. Intuitively, if we could implement these steps then L𝐿L would indeed be a hard function, and the time complexity of L𝐿L can be bounded using upper bounds on the complexities of computing G𝐺G and ℬℬ\\mathcal{B}. In order to formalize Step 1, we introduce the notion of (promise) quantum natural properties, a generalization of the central concept from  to quantum computations. Informally, a natural property (useful) against a class ℭℭ\\mathfrak{C} of functions is an algorithm B𝐵B that: (a) rejects every function g∈ℭ𝑔ℭg\\in\\mathfrak{C}, when g𝑔g is viewed as a 2nsuperscript2𝑛2^{n}-bit string; (b) the set of strings accepted by B𝐵B is dense in {0,1}2nsuperscript01superscript2𝑛\\{0,1\\}^{2^{n}}; and (c) B𝐵B runs in time 𝗉𝗈𝗅𝗒​(2n)=2O​(n)𝗉𝗈𝗅𝗒superscript2𝑛superscript2𝑂𝑛\\mathsf{poly}(2^{n})=2^{O(n)} on an input string f∈{0,1}2n𝑓superscript01superscript2𝑛f\\in\\{0,1\\}^{2^{n}}. Due to these properties, algorithm B𝐵B can be seen as a way to efficiently tell apart “structured” strings (those that encode functions from ℭℭ\\mathfrak{C}) from a dense set of “unstructured” strings. A quantum natural property against ℭℭ\\mathfrak{C} is simply a natural property against ℭℭ\\mathfrak{C} that is decided by a quantum algorithm. To our knowledge, this is the first time that quantum natural properties are considered in the literature. We show that quantum learners with parameters as in Theorem 1 imply the existence of quantum natural properties against ℭ​[nk]ℭdelimited-[]superscript𝑛𝑘\\mathfrak{C}[n^{k}]. The argument follows an idea that has appeared in a few different works (e.g.,    ): to test if an input string f∈{0,1}2n𝑓superscript01superscript2𝑛f\\in\\{0,1\\}^{2^{n}} is not in ℭ​[nk]ℭdelimited-[]superscript𝑛𝑘\\mathfrak{C}[n^{k}], one can simulate the learning algorithm 𝒜𝒜\\mathcal{A} when its oracle computes according to f𝑓f (now viewed as function), and accepts if the hypothesis output by 𝒜𝒜\\mathcal{A} and f𝑓f have agreement estimated to be less than 1/2+γ12𝛾1/2+\\gamma. For a function f∈ℭ​[nk]𝑓ℭdelimited-[]superscript𝑛𝑘f\\in\\mathfrak{C}[n^{k}], when 𝒜𝒜\\mathcal{A} learns f𝑓f its hypothesis will have a larger correlation with f𝑓f, and so f𝑓f is rejected. On the other hand, it is possible to prove that if 𝒜𝒜\\mathcal{A} runs in quantum time o​(γ2⋅2n/n)𝑜⋅superscript𝛾2superscript2𝑛𝑛o(\\gamma^{2}\\cdot 2^{n}/n), then a dense set of Boolean functions are not learned by 𝒜𝒜\\mathcal{A} even with a large error ε=1/2−γ𝜀12𝛾\\varepsilon=1/2-\\gamma (simply because such functions cannot be approximated by hypotheses of size o​(γ2⋅2n/n)𝑜⋅superscript𝛾2superscript2𝑛𝑛o(\\gamma^{2}\\cdot 2^{n}/n)). Consequently, any such function will pass the low-correlation test with high probability and be accepted, no matter how many times the learner is simulated. We directly extend this idea to the quantum setting in Section 3.1 while also addressing a subtlety that arises in the case of randomized and quantum learners. The resulting quantum algorithm ℬℬ\\mathcal{B} computing a natural property against ℭ​[nk]ℭdelimited-[]superscript𝑛𝑘\\mathfrak{C}[n^{k}] might accept some input strings f∈{0,1}2n𝑓superscript01superscript2𝑛f\\in\\{0,1\\}^{2^{n}} with a probability that is not bounded away from 1/2121/2. This happens because we cannot control the behavior of the algorithm 𝒜𝒜\\mathcal{A} on functions near the “border” of ℭ​[nk]ℭdelimited-[]superscript𝑛𝑘\\mathfrak{C}[n^{k}] (i.e., those inputs that are not as hard as a “random” function but are not in ℭ​[nk]ℭdelimited-[]superscript𝑛𝑘\\mathfrak{C}[n^{k}]). Hence, we only get a promise quantum natural property: we are guaranteed that strings from the dense set are accepted with high probability and strings corresponding to functions in ℭ​[nk]ℭdelimited-[]superscript𝑛𝑘\\mathfrak{C}[n^{k}] are rejected with high probability. Unfortunately, the strategy described in Step 2 is problematic for a number of reasons: The 𝖯𝖱𝖦𝖯𝖱𝖦\\mathsf{PRG} G𝐺G constructed in Step 3 requires a hardness assumption, while Step 2 needs a language L𝐿L that is unconditionally not in ℭ​[nk]ℭdelimited-[]superscript𝑛𝑘\\mathfrak{C}[n^{k}]. This can only be achieved if G𝐺G provably works (i.e. it does not depend on an unproven assumption). Since ℬℬ\\mathcal{B} only computes a promise quantum natural property, it is not immediately clear how to use the output of G𝐺G and the test ℬℬ\\mathcal{B} to fix with high probability a unique “hard” function hnsubscriptℎ𝑛h_{n}. This is needed so the language L𝐿L is well defined. The (conditional) 𝖯𝖱𝖦𝖯𝖱𝖦\\mathsf{PRG} G𝐺G that we are able to construct in Step 3 is much weaker: it will stretch 𝗉𝗈𝗅𝗒​(n)𝗉𝗈𝗅𝗒𝑛\\mathsf{poly}(n) bits to m​(n)=2nλ𝑚𝑛superscript2superscript𝑛𝜆m(n)=2^{n^{\\lambda}} bits for some λ>0𝜆0\\lambda>0, and it is only guaranteed to fool uniform quantum computations of time 𝗉𝗈𝗅𝗒​(m)𝗉𝗈𝗅𝗒𝑚\\mathsf{poly}(m) on infinitely many choices of n𝑛n. These issues create technical difficulties that are addressed in Section 3.2 with some modifications to our original plan, as we explain next.\n Issue (i). To resolve this and relax the conditions on the 𝖯𝖱𝖦𝖯𝖱𝖦\\mathsf{PRG}, we consider two possible scenarios: Classical computations performed in polynomial space can be simulated by quantum algorithms running in sub-exponential time 2no​(1)superscript2superscript𝑛𝑜12^{n^{o(1)}}. Item (a) does not hold, i.e., there is a language L∈𝖯𝖲𝖯𝖠𝖢𝖤𝐿𝖯𝖲𝖯𝖠𝖢𝖤L\\in\\mathsf{PSPACE} and α>0𝛼0\\alpha>0 such that L∉𝖡𝖰𝖳𝖨𝖬𝖤​[2nα]𝐿𝖡𝖰𝖳𝖨𝖬𝖤delimited-[]superscript2superscript𝑛𝛼L\\notin~{}\\mathsf{BQTIME}[2^{n^{\\alpha}}]. While we cannot currently decide which of the two scenarios holds, we obtain lower bounds against ℭ​[nk]ℭdelimited-[]superscript𝑛𝑘\\mathfrak{C}[n^{k}] in each scenario, which is sufficient for the purpose of proving Theorem 1.\n(We note that such “win-win” arguments have appeared in many previous works, including [ref]21  .) In more detail, if (a) holds, we employ standard diagonalization techniques from complexity theory to get a language L∈𝖯𝖲𝖯𝖠𝖢𝖤∖ℭ​[nk]𝐿𝖯𝖲𝖯𝖠𝖢𝖤ℭdelimited-[]superscript𝑛𝑘L\\in\\mathsf{PSPACE}\\setminus\\mathfrak{C}[n^{k}], then show that L∈𝖡𝖰𝖤𝐿𝖡𝖰𝖤L\\in\\mathsf{BQE} via a sub-exponential time quantum simulation that is granted to exist by assumption (a). We can therefore assume for the rest of the proof that (b) holds. In other words, we have a hardness hypothesis against quantum computations that we can hope to use to construct a pseudorandom generator.\n Issue (ii).\nWe fix this issue as follows. Suppose, for simplicity, that we did manage to construct a 𝖯𝖱𝖦𝖯𝖱𝖦\\mathsf{PRG} G:{0,1}O​(n)→{0,1}2n:𝐺→superscript01𝑂𝑛superscript01superscript2𝑛G\\colon\\{0,1\\}^{O(n)}\\to\\{0,1\\}^{2^{n}} of exponential stretch that is computable in time exponential in n𝑛n.\nA 2nsuperscript2𝑛2^{n} bit string output by G𝐺G can be seen as the truth table for a function hnsubscriptℎ𝑛h_{n}. Since each seed for G𝐺G produces a corresponding function, G𝐺G encodes a collection of functions. What we know from the pseudorandomness of G𝐺G and the existence of the promise quantum natural property is that at least one of these functions must lie outside ℭ​[nk]ℭdelimited-[]superscript𝑛𝑘\\mathfrak{C}[n^{k}].\nThen, the hard language L𝐿L could be defined by, say, the “first” of the hnsubscriptℎ𝑛h_{n} that lies outside of ℭ​[nk]ℭdelimited-[]superscript𝑛𝑘\\mathfrak{C}[n^{k}] – the set of “easy functions”. However, finding the hnsubscriptℎ𝑛h_{n} that satisfies this condition in 𝖡𝖰𝖳𝖨𝖬𝖤​[2O​(n)]𝖡𝖰𝖳𝖨𝖬𝖤delimited-[]superscript2𝑂𝑛\\mathsf{BQTIME}[2^{O(n)}] remains problematic.444This is because ℬℬ\\mathcal{B} computes a promise natural property, and we cannot easily estimate the exact probability that ℬℬ\\mathcal{B} accepts a string to consistently compute the “first” such string.\nInstead, we define a language L𝐿L over O​(n)+n𝑂𝑛𝑛O(n)+n input bits that simultaneously computes according to all output functions of G𝐺G.\nMore precisely, the hard language L𝐿L is defined over a pair of input strings w𝑤w and x𝑥x, where w𝑤w is a seed for G𝐺G of length O​(n)𝑂𝑛O(n), and x𝑥x is an n𝑛n-bit string. We then set L​(w,x)=fw​(x)𝐿𝑤𝑥subscript𝑓𝑤𝑥L(w,x)=f_{w}(x), where fwsubscript𝑓𝑤f_{w} is the function defined by G​(w)∈{0,1}2n𝐺𝑤superscript01superscript2𝑛G(w)\\in\\{0,1\\}^{2^{n}}.\nAs explained above, given that the 𝖯𝖱𝖦𝖯𝖱𝖦\\mathsf{PRG} G𝐺G is secure against the uniform quantum computation performed by ℬℬ\\mathcal{B}, it must produce at least one string y=G​(w)𝑦𝐺𝑤y=G(w) encoding a function hnsubscriptℎ𝑛h_{n} which lies outside the set ℭ​[nk]ℭdelimited-[]superscript𝑛𝑘\\mathfrak{C}[n^{k}]. Since L𝐿L computes hnsubscriptℎ𝑛h_{n} when we fix its first input string to its corresponding string w𝑤w, L𝐿L cannot be computed by ℭℭ\\mathfrak{C}-circuits of size nksuperscript𝑛𝑘n^{k}.\n Issue (iii). Finally, this issue is handled using a more careful description of the hard language L𝐿L. The proof makes use of the fact that we are able to get a quantum natural property against ℭ​[nd]ℭdelimited-[]superscript𝑛𝑑\\mathfrak{C}[n^{d}] for each fixed choice of d𝑑d, since by assumption we have learning algorithms for arbitrarily large polynomial-size concepts from ℭℭ\\mathfrak{C}.\nThus, a potential loss in the stretch of the generator (from 2nsuperscript2𝑛2^{n} to just 2nλsuperscript2superscript𝑛𝜆2^{n^{\\lambda}} for some λ>0𝜆0\\lambda>0) can be compensated by considering a natural property against harder functions, together with standard translation arguments from complexity theory. The weaker infinitely often guarantee of the generator can also be addressed with a careful implementation, and we refer to the formal proof for these technical details. We highlight that the construction of better (conditional) pseudorandom generators immediately leads to a tighter connection between the circuit size in the lower bound and the circuit size in the learning assumption.555Indeed, this has happened in practice, where techniques employed to design a better 𝖯𝖱𝖦𝖯𝖱𝖦\\mathsf{PRG} also led to a new learning-to-lower-bound connection . Our work shows that this is not a coincidence, i.e., better 𝖯𝖱𝖦𝖯𝖱𝖦\\mathsf{PRG}s lead to better connections in a black-box way. This leaves us with the last and most technical part of the proof: the construction of a 𝖯𝖱𝖦𝖯𝖱𝖦\\mathsf{PRG} of sub-exponential stretch 2nΩ​(1)superscript2superscript𝑛Ω12^{n^{\\Omega(1)}} that fools uniform quantum computations infinitely often, assuming 𝖯𝖲𝖯𝖠𝖢𝖤⊈𝖡𝖰𝖲𝖴𝖡𝖤𝖷𝖯not-subset-of-nor-equals𝖯𝖲𝖯𝖠𝖢𝖤𝖡𝖰𝖲𝖴𝖡𝖤𝖷𝖯\\mathsf{PSPACE}\\nsubseteq\\mathsf{BQSUBEXP} (obtained from Item (b) above). In Section 1.2.1, we explained that establishing this result in the quantum setting is more delicate than in the classical scenario. Here we focus on the different components employed in the proof and how they fit together in the 𝖯𝖱𝖦𝖯𝖱𝖦\\mathsf{PRG} construction. First, we stress that our 𝖯𝖱𝖦𝖯𝖱𝖦\\mathsf{PRG} Gn:{0,1}ℓ​(n)→{0,1}m​(n):subscript𝐺𝑛→superscript01ℓ𝑛superscript01𝑚𝑛G_{n}\\colon\\{0,1\\}^{\\ell(n)}\\to\\{0,1\\}^{m(n)} is defined classically, i.e., it is computed by a deterministic algorithm running in time exponential in ℓℓ\\ell. The extension to\nquantum circuits lies in its security analysis, where we argue that if there is a sequence {Cm}subscript𝐶𝑚\\{C_{m}\\} of uniform quantum circuits of size 𝗉𝗈𝗅𝗒​(m)𝗉𝗈𝗅𝗒𝑚\\mathsf{poly}(m) that distinguish the output of G𝐺G from random, then 𝖯𝖲𝖯𝖠𝖢𝖤⊆𝖡𝖰𝖲𝖴𝖡𝖤𝖷𝖯𝖯𝖲𝖯𝖠𝖢𝖤𝖡𝖰𝖲𝖴𝖡𝖤𝖷𝖯\\mathsf{PSPACE}\\subseteq\\mathsf{BQSUBEXP}. As alluded to above, we employ the hardness versus randomness paradigm. More precisely, our construction relies on the beautiful insight of Impagliazzo and Wigderson  on how to extend this paradigm to the uniform case, where the non-uniform advice appearing in the security proof can be eliminated via a clever recursive approach. This allows one to prove security based on a uniform hardness assumption. Following , in order to achieve this we also base the generator on a problem that is downward-self-reducible and self-correctable (such properties are useful to eliminate advice). However, we deviate from their work in terms of some other technical tools and parameters of our 𝖯𝖱𝖦𝖯𝖱𝖦\\mathsf{PRG} construction, which is formally shown in Section 5. In more detail, we construct a family of generators Gnλsuperscriptsubscript𝐺𝑛𝜆G_{n}^{\\lambda}, each parameterized by a fixed λ>0𝜆0\\lambda>0. Each Gnλsuperscriptsubscript𝐺𝑛𝜆G_{n}^{\\lambda} employs a special 𝖯𝖲𝖯𝖠𝖢𝖤𝖯𝖲𝖯𝖠𝖢𝖤\\mathsf{PSPACE}-complete language L⋆superscript𝐿⋆L^{\\star} on n𝑛n input bits from Trevisan and Vadhan 3 (which has the self-reducibiliy properties cited above), and applies the well-known Nisan-Wigderson generator  with sub-exponential stretch m​(n)=2nλ𝑚𝑛superscript2superscript𝑛𝜆m(n)=2^{n^{\\lambda}} to an “amplified” version 𝖠𝗆𝗉​(L⋆)𝖠𝗆𝗉superscript𝐿⋆\\mathsf{Amp}(L^{\\star}) of L⋆superscript𝐿⋆L^{\\star} defined over 𝗉𝗈𝗅𝗒​(n)𝗉𝗈𝗅𝗒𝑛\\mathsf{poly}(n) input bits. 𝖠𝗆𝗉​(L⋆)𝖠𝗆𝗉superscript𝐿⋆\\mathsf{Amp}(L^{\\star}) is obtained from L⋆superscript𝐿⋆L^{\\star} as follows. First, we consider its k𝑘k-product (L⋆)k:{0,1}k​n→{0,1}k:superscriptsuperscript𝐿⋆𝑘→superscript01𝑘𝑛superscript01𝑘(L^{\\star})^{k}\\colon\\{0,1\\}^{kn}\\to\\{0,1\\}^{k}, which is discussed in Section 1.2.2 in the context of hardness amplification and a result from . Then, we convert (L⋆)ksuperscriptsuperscript𝐿⋆𝑘(L^{\\star})^{k} into a Boolean function by a standard application of the Goldreich-Levin construction , which XORs the output of (L⋆)ksuperscriptsuperscript𝐿⋆𝑘(L^{\\star})^{k} with a new input string r∈{0,1}k𝑟superscript01𝑘r\\in\\{0,1\\}^{k}. This completes the sketch of the definition of Gnλsuperscriptsubscript𝐺𝑛𝜆G_{n}^{\\lambda}. By a careful choice of parameters k=𝗉𝗈𝗅𝗒​(n)𝑘𝗉𝗈𝗅𝗒𝑛k=\\mathsf{poly}(n) and seed length ℓ​(n)=𝗉𝗈𝗅𝗒​(n)ℓ𝑛𝗉𝗈𝗅𝗒𝑛\\ell(n)=\\mathsf{poly}(n), it is not hard to prove that Gnλ:{0,1}ℓ​(n)→{0,1}m​(n):superscriptsubscript𝐺𝑛𝜆→superscript01ℓ𝑛superscript01𝑚𝑛G_{n}^{\\lambda}\\colon\\{0,1\\}^{\\ell(n)}\\to\\{0,1\\}^{m(n)} can be computed in time 2O​(ℓ​(n))superscript2𝑂ℓ𝑛2^{O(\\ell(n))}. The non-trivial aspect here is to prove that Gnλsuperscriptsubscript𝐺𝑛𝜆G_{n}^{\\lambda} is quantum secure for some choice of λ𝜆\\lambda. It is enough to argue that, if for every λ>0𝜆0\\lambda>0 the generator Gnλsuperscriptsubscript𝐺𝑛𝜆G_{n}^{\\lambda} can be broken, then L⋆∈𝖡𝖰𝖳𝖨𝖬𝖤​[2no​(1)]superscript𝐿⋆𝖡𝖰𝖳𝖨𝖬𝖤delimited-[]superscript2superscript𝑛𝑜1L^{\\star}\\in\\mathsf{BQTIME}[2^{n^{o(1)}}]. Since this language is 𝖯𝖲𝖯𝖠𝖢𝖤𝖯𝖲𝖯𝖠𝖢𝖤\\mathsf{PSPACE}-complete, this violates our uniform hardness assumption. So we focus next on a fixed λ>0𝜆0\\lambda>0 and its corresponding generator Gnλsuperscriptsubscript𝐺𝑛𝜆G_{n}^{\\lambda}, and assume that there is a uniform sequence of quantum circuits {Cm}subscript𝐶𝑚\\{C_{m}\\} of size 𝗉𝗈𝗅𝗒​(m)𝗉𝗈𝗅𝗒𝑚\\mathsf{poly}(m) that distinguishes its output from random. Our goal is to conclude that L⋆∈𝖡𝖰𝖳𝖨𝖬𝖤​[2nO​(λ)]superscript𝐿⋆𝖡𝖰𝖳𝖨𝖬𝖤delimited-[]superscript2superscript𝑛𝑂𝜆L^{\\star}\\in\\mathsf{BQTIME}[2^{n^{O(\\lambda)}}]. To achieve this, we need quantum analogues of the “reconstruction” procedures of    implemented in a uniform way as in .\n Quantum Nisan-Wigderson reconstruction.\nWe observe that the original analysis of  can be adapted without difficulty in our setting. In Section 4.1, we first verify the result in the intermediate model of inherently probabilistic circuits and then extend it to the quantum case.\n Quantum Goldreich-Levin reconstruction.\nWe observe that a quantum analogue of  was established by Adcock and Cleve [ref]3. In Section 4.2, we adapt their argument to match our notation and setting of parameters. For this reason, we do not use inherently probabilistic computations here, which are convenient in the investigation of the other building blocks of our 𝖯𝖱𝖦𝖯𝖱𝖦\\mathsf{PRG} construction.\n Quantum Impagliazzo-Jaiswal-Kabanets-Wigderson reconstruction. As explained above, this turns out to be the most complicated aspect of the security proof, since it is non-trivial to extend the original analysis from  to the quantum setting. We refer to Section 1.2.2 above for an informal explanation, and to Section 4.3 for more details. We remark that it is not hard to quantize the well-known XOR Lemma for hardness amplification (e.g., Impagliazzo’s proof ), but in this work we need a uniform hardness amplification result with near-optimal parameters.\n It remains to put together these tools to conclude that the existence of a quantum distinguisher {Cm}subscript𝐶𝑚\\{C_{m}\\} implies that L⋆∈𝖡𝖰𝖳𝖨𝖬𝖤​[2nO​(λ)]superscript𝐿⋆𝖡𝖰𝖳𝖨𝖬𝖤delimited-[]superscript2superscript𝑛𝑂𝜆L^{\\star}\\in\\mathsf{BQTIME}[2^{n^{O(\\lambda)}}]. As explained above, this is done in a uniform way following the approach of . However, controlling the uniformity of the final sequence of quantum circuits that compute L⋆superscript𝐿⋆L^{\\star} is delicate. Recall that to show that L⋆∈𝖡𝖰𝖳𝖨𝖬𝖤​[T]superscript𝐿⋆𝖡𝖰𝖳𝖨𝖬𝖤delimited-[]𝑇L^{\\star}\\in\\mathsf{BQTIME}[T] we need to produce in uniform deterministic time T𝑇T, the description of a quantum circuit Qnsubscript𝑄𝑛Q_{n} for L⋆superscript𝐿⋆L^{\\star} on inputs of length n𝑛n. In the recursive construction of  that provides an algorithm to compute L⋆superscript𝐿⋆L^{\\star} on an input string x∈{0,1}n𝑥superscript01𝑛x\\in\\{0,1\\}^{n}, one “learns” how to compute L⋆superscript𝐿⋆L^{\\star} on every input length from 111 to n𝑛n, by producing a sequence of randomized circuits D1,…,Dnsubscript𝐷1…subscript𝐷𝑛D_{1},\\ldots,D_{n} that compute L∩{0,1}i𝐿superscript01𝑖L\\cap\\{0,1\\}^{i} for i∈{1,…,n}𝑖1…𝑛i\\in\\{1,\\ldots,n\\}. In order to compute Disubscript𝐷𝑖D_{i} from Di−1subscript𝐷𝑖1D_{i-1}, it is necessary to simulate Di−1subscript𝐷𝑖1D_{i-1} on some inputs, which requires randomness. Similarly, the natural way to proceed in the quantum case is by generating a uniform sequence of quantum circuits Q1,…,Qnsubscript𝑄1…subscript𝑄𝑛Q_{1},\\ldots,Q_{n} as above. Note that simulating Qi−1subscript𝑄𝑖1Q_{i-1} to produce Qisubscript𝑄𝑖Q_{i} now requires a quantum computation. However, we must be able to deterministically produce the code of quantum circuits in order to show that L⋆∈𝖡𝖰𝖳𝖨𝖬𝖤​[T]superscript𝐿⋆𝖡𝖰𝖳𝖨𝖬𝖤delimited-[]𝑇L^{\\star}\\in\\mathsf{BQTIME}[T]. We address this issue in Section 4.4 by going to another “meta-level” in this simulation, where the circuit Qisubscript𝑄𝑖Q_{i} “incorporates” this recursive process from i𝑖i to 111 by manipulating the codes of quantum circuits Qi−1subscript𝑄𝑖1Q_{i-1} to Q1subscript𝑄1Q_{1}. (Formally, this is not too different from , which also manipulates descriptions of circuits, but in the quantum case one needs to be more explicit.) We observe that it is not hard to implement this idea if the uniform versions of the quantum reconstruction procedures described above are stated in a convenient way. This completes the sketch of Step 3, and our overview of the proof of Theorem 1.\n\nReference markers found: [21]\n\nContext windows for each [ref]:\n[ref]21: in each scenario, which is sufficient for the purpose of proving Theorem 1.\n(We note that such “win-win” arguments have appeared in many previous works, including [ref]21  .) In more detail, if (a) holds, we employ standard diagonalization techniques from complexity theory to get a language\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 21,\n            \"titles\": [\n                \"Learning with Errors is easy with quantum samples\",\n                \"Computational Complexity: A Modern Approach\",\n                \"Machine learning in a quantum world\",\n                \"A quantum Goldreich-Levin theorem with cryptographic applications\",\n                \"Two new results about quantum exact learning\",\n                \"Quantum hardness of learning shallow classical circuits\",\n                \"A simple proof that Toffoli and Hadamard are quantum universal\",\n                \"Improved bounds on quantum learning algorithms\",\n                \"Quantum algorithms for learning and testing juntas\",\n                \"The Probabilistic Method\",\n                \"Guest column: A survey of quantum learning theory\",\n                \"Optimal Quantum Sample Complexity of Learning Algorithms\",\n                \"Efficient universal quantum circuits\",\n                \"Torus polynomials: an algebraic approach to ACC lower bounds\",\n                \"Learning DNF over the uniform distribution using a quantum example oracle\",\n                \"On ACC\",\n                \"Learning algorithms from natural proofs\",\n                \"Almost-everywhere circuit lower bounds from non-trivial derandomization\",\n                \"An average-case lower bound against ACC0\",\n                \"Strong average-case lower bounds from non-trivial derandomization\",\n                \"On exponential-time hypotheses, derandomization, and circuit lower bounds\",\n                \"Efficient learning algorithms yield circuit lower bounds\",\n                \"A hard-core predicate for all one-way functions\",\n                \"A fast quantum mechanical algorithm for database search\",\n                \"Exact learning algorithms, betting games, and circuit lower bounds\",\n                \"Probability inequalities for sums of bounded random variables\",\n                \"Uniform direct product theorems: simplified, optimized, and derandomized\",\n                \"Hard-core distributions for somewhat hard problems\",\n                \"Randomness vs time: Derandomization under a uniform assumption\",\n                \"Random Graphs\",\n                \"Boolean Function Complexity - Advances and Frontiers\",\n                \"Cryptographic hardness of distribution-specific learning\",\n                \"Constructing hard functions using learning algorithms\",\n                \"Efficient distribution-free learning of probabilistic concepts\",\n                \"An Introduction to Computational Learning Theory\",\n                \"Constant depth circuits, Fourier transform, and learnability\",\n                \"Circuit lower bounds for nondeterministic quasi-polytime: an easy witness lemma for NP and NQP\",\n                \"Quantum Computation and Quantum Information: 10th Anniversary Edition\",\n                \"Synthesizers and their application to the parallel construction of pseudo-random functions\",\n                \"Hardness vs randomness\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]21 based on the context and research area of Quantum learning algorithms imply circuit lower bounds. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}