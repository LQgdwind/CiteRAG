{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: Realizing the Maximal Analytic Display Fragment of Labeled Sequent Calculi for Tense LogicsThis research was supported by the European Research Council European Research Council (Grant Agreement no. 771779, DeciGUT).\n\nPaper Abstract: \n\nPaper Section Text:\nLabeled sequents generalize the syntax of Gentzen-style sequents through the incorporation of labels and semantic elements. This idea is rooted in the work of KangerÂ , who employed spotted formulae in the construction of sequent systems for modal logics. Since then, large classes of modal and constructive logics have been supplemented with labeled sequent systemsÂ [ref]9    . The labeled formalism has been successful in generating modular systems that cover extensive classes of logics in a uniform manner, i.e. through the inclusion or exclusion of structural rules, one labeled system for a logic may be transformed into a labeled system for another logicÂ  . Moreover, general results exist (e.g.Â  ) which show that labeled systems commonly possess favorable properties such as admissible structural rules, invertible logical rules, and cut-admissibility (we formally define these properties below). In this section, we introduce labeled calculi with primitive tense structural rules. The base calculus for the logic ğ–ªğ—subscriptğ–ªğ—\\mathsf{K_{t}} is a notational variant of Borettiâ€™sÂ  labeled calculus ğ–¦ğŸ¥ğ–ªğ—subscriptğ–¦ğŸ¥ğ–ªğ—\\mathsf{G3K_{t}}, though the primitive tense structural rules we define are entirely new.222We employ a schematic representation of labeled calculi whereby rules are instantiated by means of substitutions to better match the display formalism. We let Lab={w,u,v,â€¦}Labğ‘¤ğ‘¢ğ‘£â€¦\\mathrm{Lab}=\\{w,u,v,\\ldots\\} be a denumerable set of labels. A labeled sequent is defined to be a formula of the form â„›,Î“â‡’Î”â‡’â„›Î“Î”\\mathcal{R},\\Gamma\\Rightarrow\\Delta, where â„›â„›\\mathcal{R} is a (potentially empty) set of relational atoms of the form Râ€‹wâ€‹uğ‘…ğ‘¤ğ‘¢Rwu, and Î“Î“\\Gamma and Î”Î”\\Delta are (potentially empty) multisets of labeled formulae of the form w:A:ğ‘¤ğ´w:A, where wğ‘¤w and uğ‘¢u range over LabLab\\mathrm{Lab}, and Ağ´A ranges over â„’â„’\\mathcal{L}.333Usually labeled calculi employ multisets of relational atoms. However, since weakenings and contractions are admissible over relational atoms in our setting, it is well-known that sets can be used instead of multisets. We use â„›â„›\\mathcal{R} to denote sets of relational atoms, Î“Î“\\Gamma and Î”Î”\\Delta to denote multisets of labeled formulae, and Î»ğœ†\\lambda to denote labeled sequents, as well as use annotated versions of these symbols. We let Labâ€‹(â„›)Labâ„›\\mathrm{Lab}(\\mathcal{R}), Labâ€‹(Î“)LabÎ“\\mathrm{Lab}(\\Gamma), and Labâ€‹(Î»)Labğœ†\\mathrm{Lab}(\\lambda) indicate the set of all labels in a set â„›â„›\\mathcal{R}, a multiset Î“Î“\\Gamma, or a labeled sequent Î»ğœ†\\lambda, respectively. We define the length of a labeled sequent â„›,Î“â‡’Î”â‡’â„›Î“Î”\\mathcal{R},\\Gamma\\Rightarrow\\Delta to be â„“â€‹(â„›,Î“â‡’Î”)=|â„›|+|Î“|+|Î”|â„“â‡’â„›Î“Î”â„›Î“Î”\\ell(\\mathcal{R},\\Gamma\\Rightarrow\\Delta)=|\\mathcal{R}|+|\\Gamma|+|\\Delta|, where |â„›|â„›|\\mathcal{R}|, |Î“|Î“|\\Gamma|, and |Î”|Î”|\\Delta| denote the cardinality of each (multi)set. Given two labeled sequents Î»1:=â„›1,Î“1â‡’Î”1formulae-sequenceassignsubscriptğœ†1subscriptâ„›1â‡’subscriptÎ“1subscriptÎ”1\\lambda_{1}:=\\mathcal{R}_{1},\\Gamma_{1}\\Rightarrow\\Delta_{1} and Î»2:=â„›2,Î“2â‡’Î”2formulae-sequenceassignsubscriptğœ†2subscriptâ„›2â‡’subscriptÎ“2subscriptÎ”2\\lambda_{2}:=\\mathcal{R}_{2},\\Gamma_{2}\\Rightarrow\\Delta_{2}, we define the sequent composition Î»1âŠ—Î»2:=â„›1,â„›2,Î“1,Î“2â‡’Î”1,Î”2formulae-sequenceassigntensor-productsubscriptğœ†1subscriptğœ†2subscriptâ„›1subscriptâ„›2subscriptÎ“1â‡’subscriptÎ“2subscriptÎ”1subscriptÎ”2\\lambda_{1}\\otimes\\lambda_{2}:=\\mathcal{R}_{1},\\mathcal{R}_{2},\\Gamma_{1},\\Gamma_{2}\\Rightarrow\\Delta_{1},\\Delta_{2}. It follows by definition that sequent compositions are (1) associative, i.e. (Î»1âŠ—Î»2)âŠ—Î»3=Î»1âŠ—(Î»2âŠ—Î»3)tensor-producttensor-productsubscriptğœ†1subscriptğœ†2subscriptğœ†3tensor-productsubscriptğœ†1tensor-productsubscriptğœ†2subscriptğœ†3(\\lambda_{1}\\otimes\\lambda_{2})\\otimes\\lambda_{3}=\\lambda_{1}\\otimes(\\lambda_{2}\\otimes\\lambda_{3}), and (2) commutative, i.e. Î»1âŠ—Î»2=Î»2âŠ—Î»1tensor-productsubscriptğœ†1subscriptğœ†2tensor-productsubscriptğœ†2subscriptğœ†1\\lambda_{1}\\otimes\\lambda_{2}=\\lambda_{2}\\otimes\\lambda_{1}. Due to the associative property, we will often omit parentheses when writing successive sequent compositions. If {A1,â€¦,An}âŠ‚â„’subscriptğ´1â€¦subscriptğ´ğ‘›â„’\\{A_{1},\\ldots,A_{n}\\}\\subset\\mathcal{L}, we define w:{A1,â€¦,An}:=w:A1,â€¦,w:An:ğ‘¤assignsubscriptğ´1â€¦subscriptğ´ğ‘›ğ‘¤:subscriptğ´1â€¦ğ‘¤:subscriptğ´ğ‘›w:\\{A_{1},\\ldots,A_{n}\\}:=w:A_{1},\\ldots,w:A_{n}. As in the display setting, we utilize variables in the formulation of our inference rules and calculi. In particular, we let wË™,uË™,vË™,â€¦Ë™ğ‘¤Ë™ğ‘¢Ë™ğ‘£â€¦\\dot{w},\\dot{u},\\dot{v},\\ldots denote label variables, which will be instantiated with labels, we define schematic relational atoms to be formulae of the form Râ€‹wË™â€‹uË™ğ‘…Ë™ğ‘¤Ë™ğ‘¢R\\dot{w}\\dot{u} with wË™Ë™ğ‘¤\\dot{w} and uË™Ë™ğ‘¢\\dot{u} label variables, and we define schematic labeled formulae to be formulae of the form wË™:â„±:Ë™ğ‘¤â„±\\dot{w}:\\mathcal{F} where wË™Ë™ğ‘¤\\dot{w} is a label variable and â„±â„±\\mathcal{F} is generated by the following grammar in BNF: with â–½âˆˆ{Â¬,[ğ–¦],âŸ¨ğ–¥âŸ©,[ğ–§],âŸ¨ğ–¯âŸ©}â–½delimited-[]ğ–¦delimited-âŸ¨âŸ©ğ–¥delimited-[]ğ–§delimited-âŸ¨âŸ©ğ–¯\\triangledown\\in\\{\\neg,[\\mathsf{G}],\\langle\\mathsf{F}\\rangle,[\\mathsf{H}],\\langle\\mathsf{P}\\rangle\\}, âŠ™âˆˆ{âˆ§,âˆ¨,â†’}\\odot\\in\\{\\land,\\lor,\\rightarrow\\}, pË™Ë™ğ‘\\dot{p} an atomic variable, and AË™,BË™Ë™ğ´Ë™ğµ\\dot{A},\\dot{B} formula variables. We use Î»Ë™Ë™ğœ†\\dot{\\lambda} and annotated versions thereof to denote labeled sequent variables, which will be instantiated with labeled sequents. Last, we define schematic labeled sequents to be formulae of the form where, for each 1â‰¤iâ‰¤n1ğ‘–ğ‘›1\\leq i\\leq n and 1â‰¤jâ‰¤k1ğ‘—ğ‘˜1\\leq j\\leq k, â„›Ë™isubscriptË™â„›ğ‘–\\dot{\\mathcal{R}}_{i} is a (potentially empty) set of schematic relational atoms, Î“Ë™isubscriptË™Î“ğ‘–\\dot{\\Gamma}_{i} and Î”Ë™isubscriptË™Î”ğ‘–\\dot{\\Delta}_{i} are (potentially empty) multisets of schematic labeled formulae, and Î»Ë™jsubscriptË™ğœ†ğ‘—\\dot{\\lambda}_{j} is a labeled sequent variable. We sometimes denote schematic labeled sequents by Î›Ë™Ë™Î›\\dot{\\Lambda} and annotated versions thereof. As can be seen in FiguresÂ 5â€“7, schematic labeled sequents are used to define inference rules, instances of which, are obtained via applications of substitutions. A substitution Ïƒğœ\\sigma is defined to be a function (written in postfix notation) that satisfies the following: wË™â€‹ÏƒâˆˆLabË™ğ‘¤ğœLab\\dot{w}\\sigma\\in\\mathrm{Lab}, pË™â€‹ÏƒâˆˆPropË™ğ‘ğœProp\\dot{p}\\sigma\\in\\mathrm{Prop}, AË™â€‹Ïƒâˆˆâ„’Ë™ğ´ğœâ„’\\dot{A}\\sigma\\in\\mathcal{L}, and Î»Ë™â€‹ÏƒË™ğœ†ğœ\\dot{\\lambda}\\sigma is a labeled sequent. We extend a substitution Ïƒğœ\\sigma to sets of schematic relational atoms, multisets of schematic labeled formulae, and schematic labeled sequents in the expected way by applying Ïƒğœ\\sigma to each label variable, atomic variable, formula variable, and labeled sequent variable occurring therein. If we want to indicate what variables are mapped to which labeled sequents, formulae, atoms, or labels then we write a substitution Ïƒğœ\\sigma as indicating that Î»Ë™sâ€‹Ïƒ=Î»ssubscriptË™ğœ†ğ‘ ğœsubscriptğœ†ğ‘ \\dot{\\lambda}_{s}\\sigma=\\lambda_{s}, AË™iâ€‹Ïƒ=AisubscriptË™ğ´ğ‘–ğœsubscriptğ´ğ‘–\\dot{A}_{i}\\sigma=A_{i}, pË™jâ€‹Ïƒ=pjsubscriptË™ğ‘ğ‘—ğœsubscriptğ‘ğ‘—\\dot{p}_{j}\\sigma=p_{j}, and wË™tâ€‹Ïƒ=wtsubscriptË™ğ‘¤ğ‘¡ğœsubscriptğ‘¤ğ‘¡\\dot{w}_{t}\\sigma=w_{t} for sâˆˆ{1,â€¦,r}ğ‘ 1â€¦ğ‘Ÿs\\in\\{1,\\ldots,r\\}, iâˆˆ{1,â€¦,n}ğ‘–1â€¦ğ‘›i\\in\\{1,\\ldots,n\\}, jâˆˆ{1,â€¦,k}ğ‘—1â€¦ğ‘˜j\\in\\{1,\\ldots,k\\}, and tâˆˆ{1,â€¦,m}ğ‘¡1â€¦ğ‘št\\in\\{1,\\ldots,m\\}. It follows from the above definition that applying a substitution to a schematic labeled sequent yields a labeled sequent as the result. We define a rule or inference rule to be a schema utilizing schematic labeled sequents, which produces a rule instance or rule application when a substitution is applied to each schematic labeled sequent occurring in the rule (see ExampleÂ 2 below). When a substitution Ïƒğœ\\sigma is applied to a rule, we assume that every label variable, atomic variable, formula variable, and labeled sequent variable occurring in the rule is within the domain of Ïƒğœ\\sigma. The labeled calculus ğ–¦ğŸ¥ğ–ªğ—subscriptğ–¦ğŸ¥ğ–ªğ—\\mathsf{G3K_{t}} is defined to be set of the inference rules presented in FiguresÂ 5 and 6. ğ–¦ğŸ¥ğ–ªğ—subscriptğ–¦ğŸ¥ğ–ªğ—\\mathsf{G3K_{t}} contains the initial rules (iâ€‹d)ğ‘–ğ‘‘(id), (âŠ¥l)subscriptbottomğ‘™(\\bot_{l}), and (âŠ¤r)subscripttopğ‘Ÿ(\\top_{r}), as well as logical rules for Â¬\\neg, âˆ¨\\lor, âˆ§\\land, and â†’â†’\\rightarrow, all of which are shown in FigureÂ 5. We refer to each rule (iâ€‹d)ğ‘–ğ‘‘(id), (âŠ¥l)subscriptbottomğ‘™(\\bot_{l}), and (âŠ¤r)subscripttopğ‘Ÿ(\\top_{r}) as an initial rule and refer to any labeled sequent generated by an initial rule as an initial sequent. The rules governing the introduction of modal formulae are provided in FigureÂ 6, and we note that ([ğ–¦]r)subscriptdelimited-[]ğ–¦ğ‘Ÿ([\\mathsf{G}]_{r}), ([ğ–§]r)subscriptdelimited-[]ğ–§ğ‘Ÿ([\\mathsf{H}]_{r}), (âŸ¨ğ–¥âŸ©l)subscriptdelimited-âŸ¨âŸ©ğ–¥ğ‘™(\\langle\\mathsf{F}\\rangle_{l}), and (âŸ¨ğ–¯âŸ©l)subscriptdelimited-âŸ¨âŸ©ğ–¯ğ‘™(\\langle\\mathsf{P}\\rangle_{l}) have a side condition, namely, for any application of the rule with a substitution Ïƒğœ\\sigma, uË™â€‹ÏƒË™ğ‘¢ğœ\\dot{u}\\sigma must be fresh, i.e must not occur in the conclusion of the rule application. As in the display setting, the explicitly presented formula(e) in the premise(s) of a rule is (are) referred to as auxiliary and the explicitly presented formula(e) in the conclusion is (are) called principal. We also note that the labeled sequent variable Î»Ë™Ë™ğœ†\\dot{\\lambda} in each inference rule provides the context of the rule when instantiated. This formulation of labeled sequent rules is new and will be helpful in studying and defining translations with display calculi later on since substitutions may be explicitly taken into account in translations. To provide the reader with intuition concerning the application of rules, we give two examples. First, let Î»=(â„›,Î“â‡’Î”)ğœ†â‡’â„›Î“Î”\\lambda=(\\mathcal{R},\\Gamma\\Rightarrow\\Delta) and Ïƒ=[Î»/Î»Ë™,q/pË™,u/wË™]ğœğœ†Ë™ğœ†ğ‘Ë™ğ‘ğ‘¢Ë™ğ‘¤\\sigma=[\\lambda/\\dot{\\lambda},q/\\dot{p},u/\\dot{w}]. Applying Ïƒğœ\\sigma to the rule (iâ€‹d)ğ‘–ğ‘‘(id) (shown below left) yields the rule instance below right. Second, let Î»=(â„›,Î“â‡’Î”)ğœ†â‡’â„›Î“Î”\\lambda=(\\mathcal{R},\\Gamma\\Rightarrow\\Delta) and Ïƒ=[Î»/Î»Ë™,âŸ¨ğ–¯âŸ©â€‹p/AË™,w/wË™,v/uË™]ğœğœ†Ë™ğœ†delimited-âŸ¨âŸ©ğ–¯ğ‘Ë™ğ´ğ‘¤Ë™ğ‘¤ğ‘£Ë™ğ‘¢\\sigma=[\\lambda/\\dot{\\lambda},\\langle\\mathsf{P}\\rangle p/\\dot{A},w/\\dot{w},v/\\dot{u}]. Applying Ïƒâ€²superscriptğœâ€²\\sigma^{\\prime} to the rule ([ğ–¦]r)subscriptdelimited-[]ğ–¦ğ‘Ÿ([\\mathsf{G}]_{r}) (shown below left) yields the rule instance below right. Proofs are defined in the usual, inductive way: each instance of an initial rule is a proof, and applying a rule to the conclusion of a proof, or between conclusions of proofs, yields a proof. We use Î Î \\Uppi and annotated versions thereof to denote labeled proofs. A labeled sequent is derivable iff it is the conclusion of a proof. As with display proofs, we use various metrics to quantify the size of, or certain aspects of, proofs. We define the quantity, width, and size of a proof just as in DefinitionÂ 9 (though relative to labeled proofs), i.e. the quantity of a proof is equal to the number of sequents it contains, the width is defined to be the maximal length among all labeled sequents occurring in the proof, and the size is defined to be the product of the quantity and the width of the proof. For a labeled proof Î Î \\Uppi, we let qâ€‹(Î )ğ‘Î q(\\Uppi) denote the quantity, wâ€‹(Î )ğ‘¤Î w(\\Uppi) denote the width, and sâ€‹(Î )ğ‘ Î s(\\Uppi) denote the size. A rule is (quantity-preserving) admissible in a calculus iff for any instance of the rule, if each premise Î»isubscriptğœ†ğ‘–\\lambda_{i} with 1â‰¤iâ‰¤n1ğ‘–ğ‘›1\\leq i\\leq n is derivable with a proof Î isubscriptÎ ğ‘–\\Uppi_{i}, then the conclusion is derivable with a proof Î Î \\Uppi (such that qâ€‹(Î )â‰¤maxâ¡{qâ€‹(Î i)| 1â‰¤iâ‰¤n}ğ‘Î conditionalğ‘subscriptÎ ğ‘–1ğ‘–ğ‘›q(\\Uppi)\\leq\\max\\{q(\\Uppi_{i})\\ |\\ 1\\leq i\\leq n\\}). To simplify terminology, we write qp-admissible rather than quantity-preserving admissible. The (qp-)admissible structural rules for ğ–¦ğŸ¥ğ–ªğ—subscriptğ–¦ğŸ¥ğ–ªğ—\\mathsf{G3K_{t}} are shown in FigureÂ 7. More specifically, the rules (lâ€‹s)ğ‘™ğ‘ (ls), (cl)subscriptğ‘ğ‘™(c_{l}), (cr)subscriptğ‘ğ‘Ÿ(c_{r}), and (w)ğ‘¤(w) rules are qp-admissible in ğ–¦ğŸ¥ğ–ªğ—subscriptğ–¦ğŸ¥ğ–ªğ—\\mathsf{G3K_{t}} and (câ€‹uâ€‹t)ğ‘ğ‘¢ğ‘¡(cut) is admissibleÂ . The (lâ€‹s)ğ‘™ğ‘ (ls) rule is called the labeled substitution rule because it applies a label substitution (w/u)ğ‘¤ğ‘¢(w/u) to any instance of the premise to obtain the conclusion. As usual, a label substitution (w/u)ğ‘¤ğ‘¢(w/u) replaces each label uğ‘¢u occurring in a labeled sequent by a label wğ‘¤w (seeÂ ). For example, (Ruv,w:Aâ‡’u:B)(w/u)=(Rwv,w:Aâ‡’w:B)(Ruv,w:A\\Rightarrow u:B)(w/u)=(Rwv,w:A\\Rightarrow w:B). To provide the reader with intuition, we give two examples of applications of structural rules. First, let Î»=(Ruv,w:Aâ‡’u:B)\\lambda=(Ruv,w:A\\Rightarrow u:B) and Ïƒ=[Î»/Î»Ë™,w/wË™,u/vË™]ğœğœ†Ë™ğœ†ğ‘¤Ë™ğ‘¤ğ‘¢Ë™ğ‘£\\sigma=[\\lambda/\\dot{\\lambda},w/\\dot{w},u/\\dot{v}]. Applying Ïƒğœ\\sigma to the rule (lâ€‹s)ğ‘™ğ‘ (ls) (shown below left) yields the rule instance below right. Second, let Î»=(â„›,Î“â‡’Î”)ğœ†â‡’â„›Î“Î”\\lambda=(\\mathcal{R},\\Gamma\\Rightarrow\\Delta), Î»â€²=(Rwuâ‡’w:A)\\lambda^{\\prime}=(Rwu\\Rightarrow w:A), and Ïƒ=[Î»/Î»Ë™,Î»â€²/Î»Ë™â€²]ğœğœ†Ë™ğœ†superscriptğœ†â€²superscriptË™ğœ†â€²\\sigma=[\\lambda/\\dot{\\lambda},\\lambda^{\\prime}/\\dot{\\lambda}^{\\prime}]. Applying Ïƒâ€²superscriptğœâ€²\\sigma^{\\prime} to the rule (w)ğ‘¤(w) (shown below left) yields the rule instance below right. As in the display setting, we not only want to provide a calculus for the minimal tense logic ğ–ªğ—subscriptğ–ªğ—\\mathsf{K_{t}}, but also for extensions of ğ–ªğ—subscriptğ–ªğ—\\mathsf{K_{t}} with (simplified) primitive tense axioms, i.e. for any tense logic ğ–ªğ—â€‹ğ–¯subscriptğ–ªğ—ğ–¯\\mathsf{K_{t}P}. To accomplish this goal, we define labeled versions of primitive tense structural rules, which have hitherto been undefined for labeled sequent calculi. Such rules are obtained in a similar fashion as in the display setting by means of transforming a simplified primitive tense axiom into a rule. This transformation is carried out via a translation function Ï†wË™subscriptğœ‘Ë™ğ‘¤\\varphi_{\\dot{w}}. We recursively define the translation function Ï†wË™subscriptğœ‘Ë™ğ‘¤\\varphi_{\\dot{w}} that maps formulae to schematic labeled sequents. Ï†wË™â€‹(âŠ¤):=(âˆ…â‡’âˆ…)assignsubscriptğœ‘Ë™ğ‘¤topâ‡’\\varphi_{\\dot{w}}(\\top):=(\\emptyset\\Rightarrow\\emptyset) Ï†wË™â€‹(p):=Î»Ë™pwË™assignsubscriptğœ‘Ë™ğ‘¤ğ‘superscriptsubscriptË™ğœ†ğ‘Ë™ğ‘¤\\varphi_{\\dot{w}}(p):=\\dot{\\lambda}_{p}^{\\dot{w}} Ï†wË™â€‹(Aâˆ§B):=Ï†wË™â€‹(A)âŠ—Ï†wË™â€‹(B)assignsubscriptğœ‘Ë™ğ‘¤ğ´ğµtensor-productsubscriptğœ‘Ë™ğ‘¤ğ´subscriptğœ‘Ë™ğ‘¤ğµ\\varphi_{\\dot{w}}(A\\land B):=\\varphi_{\\dot{w}}(A)\\otimes\\varphi_{\\dot{w}}(B) Ï†wË™â€‹(âŸ¨ğ–¥âŸ©â€‹A):=(Râ€‹wË™â€‹uË™â‡’âˆ…)âŠ—Ï†uË™â€‹(A)assignsubscriptğœ‘Ë™ğ‘¤delimited-âŸ¨âŸ©ğ–¥ğ´tensor-productâ‡’ğ‘…Ë™ğ‘¤Ë™ğ‘¢subscriptğœ‘Ë™ğ‘¢ğ´\\varphi_{\\dot{w}}(\\langle\\mathsf{F}\\rangle A):=(R\\dot{w}\\dot{u}\\Rightarrow\\emptyset)\\otimes\\varphi_{\\dot{u}}(A) with uË™Ë™ğ‘¢\\dot{u} a new label variable Ï†wâ€‹(âŸ¨ğ–¯âŸ©â€‹A):=(Râ€‹uË™â€‹wË™â‡’âˆ…)âŠ—Ï†uË™â€‹(A)assignsubscriptğœ‘ğ‘¤delimited-âŸ¨âŸ©ğ–¯ğ´tensor-productâ‡’ğ‘…Ë™ğ‘¢Ë™ğ‘¤subscriptğœ‘Ë™ğ‘¢ğ´\\varphi_{w}(\\langle\\mathsf{P}\\rangle A):=(R\\dot{u}\\dot{w}\\Rightarrow\\emptyset)\\otimes\\varphi_{\\dot{u}}(A) with uË™Ë™ğ‘¢\\dot{u} a new label variable We note that each occurrence of Î»Ë™pwË™superscriptsubscriptË™ğœ†ğ‘Ë™ğ‘¤\\dot{\\lambda}_{p}^{\\dot{w}} is taken to be a unique labeled sequent variable; e.g. both occurrences of Î»Ë™pwË™superscriptsubscriptË™ğœ†ğ‘Ë™ğ‘¤\\dot{\\lambda}_{p}^{\\dot{w}} in Ï†wË™â€‹(pâˆ§p)=Î»Ë™pwË™âŠ—Î»Ë™pwË™subscriptğœ‘Ë™ğ‘¤ğ‘ğ‘tensor-productsuperscriptsubscriptË™ğœ†ğ‘Ë™ğ‘¤superscriptsubscriptË™ğœ†ğ‘Ë™ğ‘¤\\varphi_{\\dot{w}}(p\\land p)=\\dot{\\lambda}_{p}^{\\dot{w}}\\otimes\\dot{\\lambda}_{p}^{\\dot{w}} are taken to be unique labeled sequent variables. Labeled sequent variables obtained from the translation Ï†wË™subscriptğœ‘Ë™ğ‘¤\\varphi_{\\dot{w}} are annotated with label variables and atoms. This information is crucial for defining primitive tense structural rules in the labeled setting. First, the label variables tell us which labels must be fresh in a rule instance. Second, the atoms annotating labeled sequent variables tell us what substitutions are applicable, viz. labeled sequent variables annotated with the same atom must be instantiated with isomorphic labeled sequents (see DefinitionÂ 18 below). These are restrictions on what substitutions may be applied to a primitive tense structural rule and they ensure the soundness of rule applications. Let Î»1=â„›1,Î“1â‡’Î”1formulae-sequencesubscriptğœ†1subscriptâ„›1â‡’subscriptÎ“1subscriptÎ”1\\lambda_{1}=\\mathcal{R}_{1},\\Gamma_{1}\\Rightarrow\\Delta_{1} and Î»2=â„›2,Î“2â‡’Î”2formulae-sequencesubscriptğœ†2subscriptâ„›2â‡’subscriptÎ“2subscriptÎ”2\\lambda_{2}=\\mathcal{R}_{2},\\Gamma_{2}\\Rightarrow\\Delta_{2} be two labeled sequent. They are isomorphic, written Î»1â‰…Î»2subscriptğœ†1subscriptğœ†2\\lambda_{1}\\cong\\lambda_{2}, iff there exists a function f:Labâ€‹(Î»1)â†’Labâ€‹(Î»2):ğ‘“â†’Labsubscriptğœ†1Labsubscriptğœ†2f:\\mathrm{Lab}(\\lambda_{1})\\to\\mathrm{Lab}(\\lambda_{2}) such that fğ‘“f is bijective, Râ€‹wâ€‹uâˆˆâ„›1ğ‘…ğ‘¤ğ‘¢subscriptâ„›1Rwu\\in\\mathcal{R}_{1} iff Râ€‹fâ€‹(w)â€‹fâ€‹(u)âˆˆâ„›2ğ‘…ğ‘“ğ‘¤ğ‘“ğ‘¢subscriptâ„›2Rf(w)f(u)\\in\\mathcal{R}_{2}, w:AâˆˆÎ“1:ğ‘¤ğ´subscriptÎ“1w:A\\in\\Gamma_{1} iff fâ€‹(w):AâˆˆÎ“2:ğ‘“ğ‘¤ğ´subscriptÎ“2f(w):A\\in\\Gamma_{2}, w:AâˆˆÎ”1:ğ‘¤ğ´subscriptÎ”1w:A\\in\\Delta_{1} iff fâ€‹(w):AâˆˆÎ”2:ğ‘“ğ‘¤ğ´subscriptÎ”2f(w):A\\in\\Delta_{2}. Let us now define primitive tense structural rules in the labeled setting. Every simplified primitive tense axiom can be transformed into a primitive tense structural rule, dubbed (pâ€‹tÎ»)ğ‘subscriptğ‘¡ğœ†(pt_{\\lambda}). By extending ğ–¦ğŸ¥ğ–ªğ—subscriptğ–¦ğŸ¥ğ–ªğ—\\mathsf{G3K_{t}} with the set of (pâ€‹tÎ»)ğ‘subscriptğ‘¡ğœ†(pt_{\\lambda}) rules corresponding to a set ğ–¯ğ–¯\\mathsf{P} of (simplified) primitive tense axioms, we obtain a labeled calculus for a primitive tense logic ğ–ªğ—â€‹ğ–¯subscriptğ–ªğ—ğ–¯\\mathsf{K_{t}P}. Each simplified primitive tense axiom of the form shown below left corresponds to a primitive tense structural rule of the following form shown below right: The side condition â€ â€ {\\dagger} stipulates that for any instance of the rule under a substitution Ïƒğœ\\sigma, the following conditions must be satisfied: for each 1â‰¤iâ‰¤m1ğ‘–ğ‘š1\\leq i\\leq m, if the label variable uË™Ë™ğ‘¢\\dot{u} occurs in Ï†wË™â€‹(Bi)subscriptğœ‘Ë™ğ‘¤subscriptğµğ‘–\\varphi_{\\dot{w}}(B_{i}), but does not occur in some labeled sequent variable, then uË™â€‹ÏƒË™ğ‘¢ğœ\\dot{u}\\sigma must be fresh. for any two labeled sequent variables of the form Î»Ë™puË™superscriptsubscriptË™ğœ†ğ‘Ë™ğ‘¢\\dot{\\lambda}_{p}^{\\dot{u}} and Î»Ë™pvË™superscriptsubscriptË™ğœ†ğ‘Ë™ğ‘£\\dot{\\lambda}_{p}^{\\dot{v}} (i.e. for any two labeled sequent variables annotated with the same atom) occurring in the rule, Î»Ë™puË™â€‹Ïƒâ‰…Î»Ë™pvË™â€‹ÏƒsuperscriptsubscriptË™ğœ†ğ‘Ë™ğ‘¢ğœsuperscriptsubscriptË™ğœ†ğ‘Ë™ğ‘£ğœ\\dot{\\lambda}_{p}^{\\dot{u}}\\sigma\\cong\\dot{\\lambda}_{p}^{\\dot{v}}\\sigma. for any labeled sequent variable Î»Ë™pvË™superscriptsubscriptË™ğœ†ğ‘Ë™ğ‘£\\dot{\\lambda}_{p}^{\\dot{v}}, if Î»Ë™pvË™â€‹Ïƒâ‰ (âˆ…â‡’âˆ…)superscriptsubscriptË™ğœ†ğ‘Ë™ğ‘£ğœâ‡’\\dot{\\lambda}_{p}^{\\dot{v}}\\sigma\\neq(\\emptyset\\Rightarrow\\emptyset), then vË™â€‹ÏƒâˆˆLabâ€‹(Î»Ë™pvË™â€‹Ïƒ)Ë™ğ‘£ğœLabsuperscriptsubscriptË™ğœ†ğ‘Ë™ğ‘£ğœ\\dot{v}\\sigma\\in\\mathrm{Lab}(\\dot{\\lambda}_{p}^{\\dot{v}}\\sigma). Contrary to the display setting, each (pâ€‹tÎ»)ğ‘subscriptğ‘¡ğœ†(pt_{\\lambda}) rule retains a copy of Ï†wË™â€‹(A)subscriptğœ‘Ë™ğ‘¤ğ´\\varphi_{\\dot{w}}(A) in its premises, that is, the principal formulae are bottom-up preserved in rule applications. Formulating rules in this manner permits the qp-admissibility of contractions, so long as our calculus abides by the so-called â€˜closure conditionâ€™ (cf.Â [5, p.Â 29]). To define the closure condition, let us take a (pâ€‹tÎ»)ğ‘subscriptğ‘¡ğœ†(pt_{\\lambda}) rule as in DefinitionÂ 19 above and suppose that we substitute certain label variables occurring in Ï†wË™â€‹(A)subscriptğœ‘Ë™ğ‘¤ğ´\\varphi_{\\dot{w}}(A) by other label variables occurring in Ï†wË™â€‹(A)subscriptğœ‘Ë™ğ‘¤ğ´\\varphi_{\\dot{w}}(A). If, after this substitution, all premises and the conclusion mutually contain (1) at least two copies of a schematic relational atom of the form (Râ€‹wË™â€‹uË™â‡’âˆ…)â‡’ğ‘…Ë™ğ‘¤Ë™ğ‘¢(R\\dot{w}\\dot{u}\\Rightarrow\\emptyset) or (2) at least two copies of a labeled sequent variable of the form Î»pwË™superscriptsubscriptğœ†ğ‘Ë™ğ‘¤\\lambda_{p}^{\\dot{w}}, then we define a contraction of (pâ€‹tÎ»)ğ‘subscriptğ‘¡ğœ†(pt_{\\lambda}) to be the rule obtained by deleting one of the duplicate copies, respectively. We then say that an extension of ğ–¦ğŸ¥ğ–ªğ—subscriptğ–¦ğŸ¥ğ–ªğ—\\mathsf{G3K_{t}} with a set of primitive tense structural rules and contractions thereof satisfies the closure condition iff the calculus is closed under the contraction of every primitive tense structural rule and every contraction thereof. We note that if we close the primitive tense structural rules of an extension of ğ–¦ğŸ¥ğ–ªğ—subscriptğ–¦ğŸ¥ğ–ªğ—\\mathsf{G3K_{t}} under contractions, then the resulting calculus is still finite. This follows from the fact that (1) we only consider extensions of ğ–¦ğŸ¥ğ–ªğ—subscriptğ–¦ğŸ¥ğ–ªğ—\\mathsf{G3K_{t}} with finitely many primitive tense structural rules, and (2) because each primitive tense structural rule has only finitely many contractions as only a finite number of label variable substitutions (as described above) are possible. To make the closure condition clearer, we provide an example of a primitive tense structural rule and a contraction of the rule. Let us consider the Euclidean axiom âŸ¨ğ–¯âŸ©â€‹âŸ¨ğ–¥âŸ©â€‹pâ†’âŸ¨ğ–¥âŸ©â€‹pâ†’delimited-âŸ¨âŸ©ğ–¯delimited-âŸ¨âŸ©ğ–¥ğ‘delimited-âŸ¨âŸ©ğ–¥ğ‘\\langle\\mathsf{P}\\rangle\\langle\\mathsf{F}\\rangle p\\rightarrow\\langle\\mathsf{F}\\rangle p (which is a simplified primitive tense axiom). The axiomâ€™s corresponding primitive tense structural rule is as follows: \n\nÂ Â (RuË™wË™â‡’âˆ…)âŠ—(RuË™vË™â‡’âˆ…)âŠ—Î»Ë™pvË™âŠ—(RwË™zË™â‡’)âŠ—Î»Ë™pzË™âŠ—Î»Ë™(R\\dot{u}\\dot{w}\\Rightarrow\\emptyset)\\otimes(R\\dot{u}\\dot{v}\\Rightarrow\\emptyset)\\otimes\\dot{\\lambda}_{p}^{\\dot{v}}\\otimes(R\\dot{w}\\dot{z}\\Rightarrow)\\otimes\\dot{\\lambda}_{p}^{\\dot{z}}\\otimes\\dot{\\lambda}\nÂ  â€„(eâ€‹uâ€‹c)ğ‘’ğ‘¢ğ‘(euc)\nÂ Â Â Â Â Â Â Â Â Â Â (Râ€‹uË™â€‹wË™â‡’âˆ…)âŠ—(Râ€‹uË™â€‹vË™â‡’âˆ…)âŠ—Î»Ë™pvË™âŠ—Î»Ë™tensor-productâ‡’ğ‘…Ë™ğ‘¢Ë™ğ‘¤â‡’ğ‘…Ë™ğ‘¢Ë™ğ‘£superscriptsubscriptË™ğœ†ğ‘Ë™ğ‘£Ë™ğœ†(R\\dot{u}\\dot{w}\\Rightarrow\\emptyset)\\otimes(R\\dot{u}\\dot{v}\\Rightarrow\\emptyset)\\otimes\\dot{\\lambda}_{p}^{\\dot{v}}\\otimes\\dot{\\lambda}\n If we substitute the label wË™Ë™ğ‘¤\\dot{w} for uË™Ë™ğ‘¢\\dot{u} and vË™Ë™ğ‘£\\dot{v}, then we obtain the following: \n\nÂ Â (RwË™wË™â‡’âˆ…)âŠ—(RwË™wË™â‡’âˆ…)âŠ—Î»Ë™pwË™âŠ—(RwË™zË™â‡’)âŠ—Î»Ë™pzË™âŠ—Î»Ë™(R\\dot{w}\\dot{w}\\Rightarrow\\emptyset)\\otimes(R\\dot{w}\\dot{w}\\Rightarrow\\emptyset)\\otimes\\dot{\\lambda}_{p}^{\\dot{w}}\\otimes(R\\dot{w}\\dot{z}\\Rightarrow)\\otimes\\dot{\\lambda}_{p}^{\\dot{z}}\\otimes\\dot{\\lambda}\nÂ  \nÂ Â Â Â Â Â Â Â Â Â Â (Râ€‹wË™â€‹wË™â‡’âˆ…)âŠ—(Râ€‹wË™â€‹wË™â‡’âˆ…)âŠ—Î»Ë™pwË™âŠ—Î»Ë™tensor-productâ‡’ğ‘…Ë™ğ‘¤Ë™ğ‘¤â‡’ğ‘…Ë™ğ‘¤Ë™ğ‘¤superscriptsubscriptË™ğœ†ğ‘Ë™ğ‘¤Ë™ğœ†(R\\dot{w}\\dot{w}\\Rightarrow\\emptyset)\\otimes(R\\dot{w}\\dot{w}\\Rightarrow\\emptyset)\\otimes\\dot{\\lambda}_{p}^{\\dot{w}}\\otimes\\dot{\\lambda}\n Since the schematic labeled sequent (Râ€‹wË™â€‹wË™â‡’âˆ…)â‡’ğ‘…Ë™ğ‘¤Ë™ğ‘¤(R\\dot{w}\\dot{w}\\Rightarrow\\emptyset) occurs twice, a contraction of (eâ€‹uâ€‹c)ğ‘’ğ‘¢ğ‘(euc) can be obtained by deleting the additional copy, yielding the following: \n\nÂ Â (RwË™wË™â‡’âˆ…)âŠ—Î»Ë™pwË™âŠ—(RwË™zË™â‡’)âŠ—Î»Ë™pzË™âŠ—Î»Ë™(R\\dot{w}\\dot{w}\\Rightarrow\\emptyset)\\otimes\\dot{\\lambda}_{p}^{\\dot{w}}\\otimes(R\\dot{w}\\dot{z}\\Rightarrow)\\otimes\\dot{\\lambda}_{p}^{\\dot{z}}\\otimes\\dot{\\lambda}\nÂ  â€„(eâ€‹uâ€‹c)â€²superscriptğ‘’ğ‘¢ğ‘â€²(euc)^{\\prime}\nÂ Â Â Â Â Â Â Â Â Â Â (Râ€‹wË™â€‹wË™â‡’âˆ…)âŠ—Î»Ë™pwË™âŠ—Î»Ë™tensor-productâ‡’ğ‘…Ë™ğ‘¤Ë™ğ‘¤superscriptsubscriptË™ğœ†ğ‘Ë™ğ‘¤Ë™ğœ†(R\\dot{w}\\dot{w}\\Rightarrow\\emptyset)\\otimes\\dot{\\lambda}_{p}^{\\dot{w}}\\otimes\\dot{\\lambda}\n We note that no contractions exist of the (eâ€‹uâ€‹c)â€²superscriptğ‘’ğ‘¢ğ‘â€²(euc)^{\\prime} rule as no substitution of label variables can produce duplications. As specified above, contractions are only possible when all premises and the conclusion share duplicate formulae of the form (Râ€‹wË™â€‹uË™â‡’âˆ…)â‡’ğ‘…Ë™ğ‘¤Ë™ğ‘¢(R\\dot{w}\\dot{u}\\Rightarrow\\emptyset) or Î»Ë™pwË™superscriptsubscriptË™ğœ†ğ‘Ë™ğ‘¤\\dot{\\lambda}_{p}^{\\dot{w}}, yet, the conclusion of (eâ€‹uâ€‹c)â€²superscriptğ‘’ğ‘¢ğ‘â€²(euc)^{\\prime} is of a form that precludes this possibility. Let ğ–ªğ—â€‹ğ–¯subscriptğ–ªğ—ğ–¯\\mathsf{K_{t}P} be a primitive tense logic. We define ğ–¦ğŸ¥ğ–ªğ—â€‹ğ–¯subscriptğ–¦ğŸ¥ğ–ªğ—ğ–¯\\mathsf{G3K_{t}P} to be ğ–¦ğŸ¥ğ–ªğ—subscriptğ–¦ğŸ¥ğ–ªğ—\\mathsf{G3K_{t}} extended with a (pâ€‹tÎ»)ğ‘subscriptğ‘¡ğœ†(pt_{\\lambda}) rule and all contractions thereof, for each simplified primitive tense axiom in ğ–¯ğ–¯\\mathsf{P}. We indicate that a labeled sequent Î»ğœ†\\lambda is provable in ğ–¦ğŸ¥ğ–ªğ—â€‹ğ–¯subscriptğ–¦ğŸ¥ğ–ªğ—ğ–¯\\mathsf{G3K_{t}P} with a labeled proof Î Î \\Uppi by writing ğ–¦ğŸ¥ğ–ªğ—â€‹ğ–¯,Î âŠ©Î»forcessubscriptğ–¦ğŸ¥ğ–ªğ—ğ–¯Î ğœ†\\mathsf{G3K_{t}P},\\Uppi\\Vdash\\lambda. The (lâ€‹s)ğ‘™ğ‘ (ls), (w)ğ‘¤(w), (cl)subscriptğ‘ğ‘™(c_{l}), and (cr)subscriptğ‘ğ‘Ÿ(c_{r}) rules are qp-admissible in ğ–¦ğŸ¥ğ–ªğ—â€‹ğ–¯subscriptğ–¦ğŸ¥ğ–ªğ—ğ–¯\\mathsf{G3K_{t}P} and (câ€‹uâ€‹t)ğ‘ğ‘¢ğ‘¡(cut) is admissible. Follows from LemmaÂ 2.3.4, TheoremÂ 2.3.6, TheoremÂ 2.3.8, and TheoremÂ 2.3.10 of . The qp-admissibility of (lâ€‹s)ğ‘™ğ‘ (ls), (w)ğ‘¤(w), (cl)subscriptğ‘ğ‘™(c_{l}), and (cr)subscriptğ‘ğ‘Ÿ(c_{r}) is proven in ğ–¦ğŸ¥ğ–ªğ—â€‹ğ–¯subscriptğ–¦ğŸ¥ğ–ªğ—ğ–¯\\mathsf{G3K_{t}P} by showing that each rule can be permuted upward in any proof and deleted at initial rules (while preserving the quantity of the proof). Therefore, this method of proof, which relies on rule permutations, shows the existence of an algorithm that takes a proof with structural rules as input and returns a proof without such rules as output. Such proof transformations are computable in PTIMEPTIME\\mathrm{PTIME} in the size of the input proof. This is because if our input proof is Î Î \\Uppi, then there are most qâ€‹(Î )ğ‘Î q(\\Uppi) occurrences of structural rules in Î Î \\Uppi, and for each such occurrence at most qâ€‹(Î )ğ‘Î q(\\Uppi) many permutations need to be made, showing that the algorithm performs at most qâ€‹(Î )Ã—qâ€‹(Î )â‰¤sâ€‹(Î )2ğ‘Î ğ‘Î ğ‘ superscriptÎ 2q(\\Uppi)\\times q(\\Uppi)\\leq s(\\Uppi)^{2} many permutations. Moreover, the width of the output proof will always be bounded by qâ€‹(Î )Ã—wâ€‹(Î )=sâ€‹(Î )ğ‘Î ğ‘¤Î ğ‘ Î q(\\Uppi)\\times w(\\Uppi)=s(\\Uppi). This is straightforward to verify in the (lâ€‹s)ğ‘™ğ‘ (ls), (cl)subscriptğ‘ğ‘™(c_{l}), and (cr)subscriptğ‘ğ‘Ÿ(c_{r}) cases, which may reduce the length of labeled sequents when permuted upward; in the case of (w)ğ‘¤(w), which weakens in a labeled sequent Î»ğœ†\\lambda, â„“â€‹(Î»)â‰¤wâ€‹(Î )â„“ğœ†ğ‘¤Î \\ell(\\lambda)\\leq w(\\Uppi), so permuting numerous instances of (w)ğ‘¤(w) upward may increase the length of the â€˜longestâ€™ labeled sequent occurring in Î Î \\Uppi, and thus, the width of the output proof will be at most qâ€‹(Î )Ã—wâ€‹(Î )ğ‘Î ğ‘¤Î q(\\Uppi)\\times w(\\Uppi). Since (lâ€‹s)ğ‘™ğ‘ (ls), (w)ğ‘¤(w), (cl)subscriptğ‘ğ‘™(c_{l}), and (cr)subscriptğ‘ğ‘Ÿ(c_{r}) are qp-admissible, this shows that the size of the output proof is polynomial in the size of the input proof and that the proof transformations eliminating (lâ€‹s)ğ‘™ğ‘ (ls), (w)ğ‘¤(w), (cl)subscriptğ‘ğ‘™(c_{l}), and (cr)subscriptğ‘ğ‘Ÿ(c_{r}) instances are computable in PTIMEPTIME\\mathrm{PTIME}.\n\nReference markers found: [9]\n\nContext windows for each [ref]:\n[ref]9: who employed spotted formulae in the construction of sequent systems for modal logics. Since then, large classes of modal and constructive logics have been supplemented with labeled sequent systemsÂ [ref]9    . The labeled formalism has been successful in generating modular systems that cover extensive classes of logics in a uniform manner, i.e. through the inclusion or exclusion of structural\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 9,\n            \"titles\": [\n                \"Display to Labeled Proofs and Back Again for Tense Logics\",\n                \"The method of hypersequents in the proof theory of propositional non-classical logics\",\n                \"Introduction to Description Logic\",\n                \"Display logic\",\n                \"Modal Logic, volume 53 of Cambridge Tracts in Theoretical Computer Science\",\n                \"Proof Analysis in Temporal Logic\",\n                \"Bunched logics displayed\",\n                \"A cut-free sequent calculus for bi-intuitionistic logic\",\n                \"Cut elimination for propositional dynamic logic without *\",\n                \"A systematic presentation of quantified modal logics\",\n                \"The chase revisited\",\n                \"Contraction-free sequent calculi for intuitionistic logic\",\n                \"Tableau methods of proof for modal logics\",\n                \"Labelled deductive systems, volume 33 of Oxford Logic guides\",\n                \"Untersuchungen Ã¼ber das logische schlieÃŸen. i.\",\n                \"Untersuchungen Ã¼ber das logische schlieÃŸen. ii.\",\n                \"Linear logic\",\n                \"Substructural logics on display\",\n                \"Geometric theories and proof theory of modal logic\",\n                \"Graphs and Homomorphisms\",\n                \"Provability in logic\",\n                \"Cut-free sequent calculi for some tense logics\",\n                \"Power and weakness of the modal display calculus\",\n                \"Semantical considerations on modal logic\",\n                \"Linear nested sequents, 2-sequents and hypersequents\",\n                \"Syntactic Interpolation for Tense Logics and Bi-Intuitionistic Logic via Nested Sequents\",\n                \"On the interpolation theorem of craig\",\n                \"Interpolation and model checking\",\n                \"Indexed systems of sequents and cut-elimination\",\n                \"Uniform, cut-free formulations of t, s4 and s5\",\n                \"Time and Modality\",\n                \"Comparing modal sequent systems\",\n                \"The proof theory and semantics of intuitionistic modal logic\",\n                \"Minlog: A minimal logic theorem prover\",\n                \"First-Order Logic\",\n                \"The design of modal proof theories: The case of s5\",\n                \"Reasoning with and about norms in logical argumentation\",\n                \"Labelled Non-Classical Logics\",\n                \"Sequent calculi for normal modal propositional logics\",\n                \"On logics with coimplication\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]9 based on the context and research area of Realizing the Maximal Analytic Display Fragment of Labeled Sequent Calculi for Tense LogicsThis research was supported by the European Research Council European Research Council (Grant Agreement no. 771779, DeciGUT).. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}