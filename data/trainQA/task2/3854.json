{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: Chromatic ğ‘˜-Nearest Neighbor Queries\n\nPaper Abstract: \n\nPaper Section Text:\nIn this section, we present the data structure of ChanÂ et al.Â [ref]12 for finding the mode color among points in query disks.\nThis data structure can then be used in conjunction with that of SectionÂ 3.2 to get a data structure for chromatic kğ‘˜k-nearest neighbors queries. We first transform the problem, by performing a lifting map and\nsubsequently dualizing the points. For the lifting map, we map\neach point pâˆˆPğ‘ğ‘ƒp\\in P to the point\np^=(px,py,px2+py2)^ğ‘subscriptğ‘ğ‘¥subscriptğ‘ğ‘¦superscriptsubscriptğ‘ğ‘¥2superscriptsubscriptğ‘ğ‘¦2\\hat{p}=(p_{x},p_{y},p_{x}^{2}+p_{y}^{2}), essentially lifting the points\nof Pğ‘ƒP to the three-dimensional unit paraboloid. Call the set of\nlifted points P^^ğ‘ƒ\\hat{P}. In the following lemma, we will show\nthat a disk D=Dâ€‹(q,r)ğ·ğ·ğ‘ğ‘ŸD=D(q,r) corresponds to the halfspace\nhâˆ’â€‹(q,r):zâ‰¤2â€‹qxâ€‹x+2â€‹qyâ€‹yâˆ’qx2âˆ’qy2+r2:superscriptâ„ğ‘ğ‘Ÿğ‘§2subscriptğ‘ğ‘¥ğ‘¥2subscriptğ‘ğ‘¦ğ‘¦superscriptsubscriptğ‘ğ‘¥2superscriptsubscriptğ‘ğ‘¦2superscriptğ‘Ÿ2h^{-}(q,r):z\\leq 2q_{x}x+2q_{y}y-q_{x}^{2}-q_{y}^{2}+r^{2}.\nSee FigureÂ 6 for an illustration\nof this fact. Let D=Dâ€‹(q,r)ğ·ğ·ğ‘ğ‘ŸD=D(q,r) be a disk in â„2superscriptâ„2\\mathbb{R}^{2}.\nA point pâˆˆâ„2ğ‘superscriptâ„2p\\in\\mathbb{R}^{2} lies in Dğ·D if and only if\np^âˆˆâ„3^ğ‘superscriptâ„3\\hat{p}\\in\\mathbb{R}^{3} lies in Hâ€‹(q,r)ğ»ğ‘ğ‘ŸH(q,r). Let pâˆˆDğ‘ğ·p\\in D be a point. Then we have that\n(pxâˆ’qx)2+(pyâˆ’qy)2â‰¤r2superscriptsubscriptğ‘ğ‘¥subscriptğ‘ğ‘¥2superscriptsubscriptğ‘ğ‘¦subscriptğ‘ğ‘¦2superscriptğ‘Ÿ2(p_{x}-q_{x})^{2}+(p_{y}-q_{y})^{2}\\leq r^{2}. This implies that\npx2+py2â‰¤2â€‹qxâ€‹px+2â€‹qyâ€‹pyâˆ’qx2âˆ’qy2+r2superscriptsubscriptğ‘ğ‘¥2superscriptsubscriptğ‘ğ‘¦22subscriptğ‘ğ‘¥subscriptğ‘ğ‘¥2subscriptğ‘ğ‘¦subscriptğ‘ğ‘¦superscriptsubscriptğ‘ğ‘¥2superscriptsubscriptğ‘ğ‘¦2superscriptğ‘Ÿ2p_{x}^{2}+p_{y}^{2}\\leq 2q_{x}p_{x}+2q_{y}p_{y}-q_{x}^{2}-q_{y}^{2}+r^{2},\nfrom which it can be seen that p^âˆˆHâ€‹(q,r)^ğ‘ğ»ğ‘ğ‘Ÿ\\hat{p}\\in H(q,r).\nFollowing the reasoning backwards completes the proof. Let hâˆ—superscriptâ„h^{*} be the point dual to the plane hâ„h bounding hâˆ’â€‹(q,r)superscriptâ„ğ‘ğ‘Ÿh^{-}(q,r).\nBy taking the dual of P^^ğ‘ƒ\\hat{P}, a set of planes Hğ»H is obtained,\nsuch that the points inside Dğ·D correspond to the planes below\nhâˆ—superscriptâ„h^{*}.\nWe will build a data structure on the set of planes Hğ»H, that can find the mode color among these planes. The data structure is based on the following observation by KrizancÂ et al.Â : Let Ağ´A and BğµB be multisets.\nIf cğ‘c is a mode of AâˆªBğ´ğµA\\cup B, and câˆ‰Ağ‘ğ´c\\notin A, then cğ‘c is a mode of BğµB. We apply this observation to 1r1ğ‘Ÿ\\frac{1}{r}-cuttings.\nA 1r1ğ‘Ÿ\\frac{1}{r}-cutting ÎÎ\\Xi of ğ’œâ€‹(H)ğ’œğ»\\mathcal{A}(H) is a set of simplices with\ndisjoint interiors, that together cover â„3superscriptâ„3\\mathbb{R}^{3}, such that the interior of\na simplex in ÎÎ\\Xi is intersected by at most n/rğ‘›ğ‘Ÿn/r planes in Hğ»H.\nNow let qâˆˆâ„3ğ‘superscriptâ„3q\\in\\mathbb{R}^{3}\nbe a query point. Given a 1r1ğ‘Ÿ\\frac{1}{r}-cutting ÎÎ\\Xi of ğ’œâ€‹(H)ğ’œğ»\\mathcal{A}(H), let\nÎ”âˆˆÎÎ”Î\\Delta\\in\\Xi be a simplex containing qğ‘q, for which there is a\npoint in Î”Î”\\Delta strictly above qğ‘q. The mode color among the planes\nbelow qğ‘q is then either the color of a plane in the conflict list\nHÎ”subscriptğ»Î”H_{\\Delta} of Î”Î”\\Delta (multiset Ağ´A), or it is the mode color among\nthe planes below Î”Î”\\Delta (multiset BğµB). Note that Chan\net al.Â [ref]12 use slightly\ndifferent sets. Our choice makes extending the result to the\nLâˆsubscriptğ¿L_{\\infty} metric (as we do in SectionÂ 4.2) slightly easier. For the data structure, we now create a 1r1ğ‘Ÿ\\frac{1}{r}-cutting ÎÎ\\Xi on Hğ»H, and for every\nsimplex Î”âˆˆÎÎ”Î\\Delta\\in\\Xi, we compute and store the mode color among the planes below Î”Î”\\Delta.\nAside from this cutting, we construct a point-location data structure for quickly finding the\nsimplex containing a query point. We also need the conflict lists of the simplices.\nHowever, as they have a total size of Oâ€‹(nâ€‹r2)ğ‘‚ğ‘›superscriptğ‘Ÿ2O(nr^{2}), we will use a seperate data structure\nthat computes the conflict list during a query. LemmaÂ 4.6 states our results on cuttings and\ncomputing their conflict lists. The following lemma is used to speed up the\ncomputation of the conflict lists for our problem, where the planes of Hğ»H\noriginate from two-dimensional points. Let aâˆˆR3ğ‘superscriptğ‘…3a\\in R^{3} be a point. We can construct, in constant time, a disk\nDasubscriptğ·ğ‘D_{a} in â„2superscriptâ„2\\mathbb{R}^{2}, such that the points of Pğ‘ƒP inside Dasubscriptğ·ğ‘D_{a} correspond to\nthose planes of Hğ»H below ağ‘a. Let m=(âˆ’ax/2,âˆ’ay/2)ğ‘šsubscriptğ‘ğ‘¥2subscriptğ‘ğ‘¦2m=(-a_{x}/2,-a_{y}/2) and r=azâˆ’ax2+ay24ğ‘Ÿsubscriptğ‘ğ‘§superscriptsubscriptğ‘ğ‘¥2superscriptsubscriptğ‘ğ‘¦24r=\\sqrt{a_{z}-\\frac{a_{x}^{2}+a_{y}^{2}}{4}}.\nThe disk Da=Dâ€‹(m,r)subscriptğ·ğ‘ğ·ğ‘šğ‘ŸD_{a}=D(m,r) with center mğ‘šm and radius rğ‘Ÿr is then lifted to the\nhalfspace The plane bounding this halfspace is dual to the point (ax,ay,az)=asubscriptğ‘ğ‘¥subscriptğ‘ğ‘¦subscriptğ‘ğ‘§ğ‘(a_{x},a_{y},a_{z})=a.\nThus, the points of Pğ‘ƒP inside Dasubscriptğ·ğ‘D_{a} correspond to the planes of Hğ»H\nbelow ağ‘a. Let râˆˆ[1,n]ğ‘Ÿ1ğ‘›r\\in[1,n] a parameter. We can store\na 1r1ğ‘Ÿ\\frac{1}{r}-cutting of ğ’œâ€‹(H)ğ’œğ»\\mathcal{A}(H) of Oâ€‹(r3)ğ‘‚superscriptğ‘Ÿ3O(r^{3}) size in a data structure of Oâ€‹(n+r3)ğ‘‚ğ‘›superscriptğ‘Ÿ3O(n+r^{3}) size,\nso that the simplex Î”âˆˆÎÎ”Î\\Delta\\in\\Xi containing a query point can be found in\nOâ€‹(logâ¡r)ğ‘‚ğ‘ŸO(\\log r) time, and so that reporting the conflict list of Î”Î”\\Delta takes\nOâ€‹(n1/2â€‹polylogâ¡n+n/r)ğ‘‚superscriptğ‘›12polylogğ‘›ğ‘›ğ‘ŸO(n^{1/2}\\operatorname{polylog}n+n/r) time. Building the data\nstructure takes expected Oâ€‹(n1+Î´+nâ€‹r2)ğ‘‚superscriptğ‘›1ğ›¿ğ‘›superscriptğ‘Ÿ2O(n^{1+\\delta}+nr^{2}) time. Using the result of ChazelleÂ , we can construct,\nin Oâ€‹(nâ€‹r2)ğ‘‚ğ‘›superscriptğ‘Ÿ2O(nr^{2}) time, a 1r1ğ‘Ÿ\\frac{1}{r}-cutting ÎÎ\\Xi of Oâ€‹(r3)ğ‘‚superscriptğ‘Ÿ3O(r^{3}) size, along with a\npoint-location data structure, also of Oâ€‹(r3)ğ‘‚superscriptğ‘Ÿ3O(r^{3}) size, that answers queries in\nOâ€‹(logâ¡r)ğ‘‚ğ‘ŸO(\\log r) time. We now present a data structure for reporting the planes intersecting a simplex Î”Î”\\Delta, following the ideas of ChanÂ et al.Â [ref]12.\nAny plane intersecting the interior of Î”Î”\\Delta intersects the interior of an edge of Î”Î”\\Delta (without containing the edge).\nBeause Î”Î”\\Delta has only Oâ€‹(1)ğ‘‚1O(1) edges, we will report the planes\nintersecting an edge eğ‘’e of Î”Î”\\Delta for all edges of Î”Î”\\Delta\nindividually. As we will then show, the number of planes reported\nthis way will still be Oâ€‹(n/r)ğ‘‚ğ‘›ğ‘ŸO(n/r), even though we might report a\nplane multiple times. Let aâ€‹bÂ¯Â¯ğ‘ğ‘\\overline{ab} be a line segment in â„3superscriptâ„3\\mathbb{R}^{3}, of which we want to\nreport the planes intersecting it. Note that a plane intersects\nthe interior of aâ€‹bÂ¯Â¯ğ‘ğ‘\\overline{ab}\nif and only if it is either strictly above ağ‘a and strictly below bğ‘b, or\nstrictly below ağ‘a and strictly above bğ‘b. The first set of planes (and\nsimilarly, the second set,) can be reported using two-dimensional\nsemialgebraic range reporting, using LemmaÂ 4.4.\nLet Dasubscriptğ·ğ‘D_{a} and Dbsubscriptğ·ğ‘D_{b} be the two disks in â„2superscriptâ„2\\mathbb{R}^{2}, such that the points inside\nthe disks correspond to the planes below ağ‘a and bğ‘b, respectively.\nUsing the result of AgarwalÂ et al.Â ,\nwe can construct a linear-size data structure in Oâ€‹(n1+Î´)ğ‘‚superscriptğ‘›1ğ›¿O(n^{1+\\delta})\nexpected time, which reports the kâ€²superscriptğ‘˜â€²k^{\\prime} points strictly outside Dasubscriptğ·ğ‘D_{a} and strictly\ninside Dbsubscriptğ·ğ‘D_{b}, and thus the kâ€²superscriptğ‘˜â€²k^{\\prime} planes intersecting the interior of aâ€‹bÂ¯Â¯ğ‘ğ‘\\overline{ab},\nin Oâ€‹(n1/2â€‹polylogâ¡n+kâ€²)ğ‘‚superscriptğ‘›12polylogğ‘›superscriptğ‘˜â€²O(n^{1/2}\\operatorname{polylog}n+k^{\\prime}) time. Performing two of the above reporting queries per edge of Î”Î”\\Delta,\nwe obtain a query time of Oâ€‹(n1/2â€‹polylogâ¡n+kâ€²)ğ‘‚superscriptğ‘›12polylogğ‘›superscriptğ‘˜â€²O(n^{1/2}\\operatorname{polylog}n+k^{\\prime}), where kâ€²superscriptğ‘˜â€²k^{\\prime}\nis the number of planes (including duplicates) reported in total.\nNote that we only report planes that intersect the interior of an edge\nof Î”Î”\\Delta, and thus we only report planes in the conflict list of\nÎ”Î”\\Delta. Furthermore, because we perform only a constant number of\nreporting queries, kâ€²superscriptğ‘˜â€²k^{\\prime} will be at most a constant factor greater than\nthe size of HÎ”subscriptğ»Î”H_{\\Delta}. This gives a total query time of Oâ€‹(n1/2â€‹polylogâ¡n+n/r)ğ‘‚superscriptğ‘›12polylogğ‘›ğ‘›ğ‘ŸO(n^{1/2}\\operatorname{polylog}n+n/r), proving the lemma. Finally, we build a number of data structures for level queries.\nOne is build on each set of planes in Hğ»H that share the same color.\nFor these data structures, we use LemmaÂ 4.4 to handle\nthe queries with two-dimensional semialgebraic range counting.\nWe use the linear-space solution of AgarwalÂ et al.Â ,\nwhich can be constructed in Oâ€‹(n1+Î´)ğ‘‚superscriptğ‘›1ğ›¿O(n^{1+\\delta}) expected time and answers\nqueries in Oâ€‹(n1/2â€‹polylogâ¡n)ğ‘‚superscriptğ‘›12polylogğ‘›O(n^{1/2}\\operatorname{polylog}n) time. We now show how to compute the colors stored in the simplices. This can be done in\nOâ€‹(nâ€‹r3)ğ‘‚ğ‘›superscriptğ‘Ÿ3O(nr^{3}) time, after we created pointers from each plane to a counter counting\nthe frequency of the planeâ€™s color. The color of a simplex can then be computed\nby scanning through all planes, upping a planeâ€™s colorâ€™s frequency if the plane\nlies below the simplex, and keeping track of the color with the highest\nfrequency. This takes Oâ€‹(n)ğ‘‚ğ‘›O(n) time per simplex, totalling Oâ€‹(nâ€‹r3)ğ‘‚ğ‘›superscriptğ‘Ÿ3O(nr^{3}) time.\nThis brings the total size of the data structure to Oâ€‹(n+r3)ğ‘‚ğ‘›superscriptğ‘Ÿ3O(n+r^{3}), and the total expected preprocessing time to Oâ€‹(n1+Î´+nâ€‹r3)ğ‘‚superscriptğ‘›1ğ›¿ğ‘›superscriptğ‘Ÿ3O(n^{1+\\delta}+nr^{3}). Querying the structure with a point qğ‘q is done by first finding a simplex Î”âˆˆÎÎ”Î\\Delta\\in\\Xi containing qğ‘q, for which there is a point in Î”Î”\\Delta strictly above qğ‘q.\nThis can be done in Oâ€‹(logâ¡r)ğ‘‚ğ‘ŸO(\\log r) time.\nThen, the conflict list of Î”Î”\\Delta is reported, taking Oâ€‹(n1/2â€‹polylogâ¡n+n/r)ğ‘‚superscriptğ‘›12polylogğ‘›ğ‘›ğ‘ŸO(n^{1/2}\\operatorname{polylog}n+n/r) time.\nFinally, for each color cğ‘c of the Oâ€‹(n/r)ğ‘‚ğ‘›ğ‘ŸO(n/r) reported planes, as well as for the color stored in Î”Î”\\Delta, the number of planes below qğ‘q that have color cğ‘c is counted.\nRecall that this can be done using level queries.\nThe mode color among the planes below qğ‘q is the color with the highest count. Let Hcsubscriptğ»ğ‘H_{c} be the set of planes with color cğ‘c, and let CÎ”subscriptğ¶Î”C_{\\Delta} be the set of colors for which we perform a level query.\nNote that |CÎ”|=Oâ€‹(n/r)subscriptğ¶Î”ğ‘‚ğ‘›ğ‘Ÿ|C_{\\Delta}|=O(n/r).\nHÃ¶lders inequality now states that for any two sequences x1,â€¦,xmsubscriptğ‘¥1â€¦subscriptğ‘¥ğ‘šx_{1},\\dots,x_{m} and y1,â€¦,ymsubscriptğ‘¦1â€¦subscriptğ‘¦ğ‘šy_{1},\\dots,y_{m} and any two positive values ağ‘a and bğ‘b.\nApplied to the level queries, we find that the level queries take a total of time. In total, the query time of the data structure is thus\nOâ€‹((n/r1/2)â€‹polylogâ¡n)ğ‘‚ğ‘›superscriptğ‘Ÿ12polylogğ‘›O((n/r^{1/2})\\operatorname{polylog}n). We thus get the following result\n(essentially Theorem 17 of Chan\net al.Â [ref]12 in the case of halfspaces\nin â„3superscriptâ„3\\mathbb{R}^{3}, though slightly improved for the case of two-dimensional circular ranges): Let Pğ‘ƒP be a set of nğ‘›n colored points in â„2superscriptâ„2\\mathbb{R}^{2} and râˆˆ[1,n]ğ‘Ÿ1ğ‘›r\\in[1,n]\na parameter. In Oâ€‹(n1+Î´+nâ€‹r3)ğ‘‚superscriptğ‘›1ğ›¿ğ‘›superscriptğ‘Ÿ3O(n^{1+\\delta}+nr^{3}) expected time, we can build a\ndata structure of Oâ€‹(n+r3)ğ‘‚ğ‘›superscriptğ‘Ÿ3O(n+r^{3}) size, that reports the mode color\namong the points in a query disk in Oâ€‹((n/r1/2)â€‹polylogâ¡n)ğ‘‚ğ‘›superscriptğ‘Ÿ12polylogğ‘›O((n/r^{1/2})\\operatorname{polylog}n)\ntime.\n\nReference markers found: [12]\n\nContext windows for each [ref]:\n[ref]12: In this section, we present the data structure of ChanÂ et al.Â [ref]12 for finding the mode color among points in query disks.\nThis data structure can then be used in conjunction with that of SectionÂ 3.2 to get a data structure for chromatic kğ‘˜k-nearest\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 12,\n            \"titles\": [\n                \"Further Results on Colored Range Searching\",\n                \"Vertical decomposition of shallow levels in 3-dimensional arrangements and its applications\",\n                \"On range searching with semialgebraic sets\",\n                \"On range searching with semialgebraic sets. II\",\n                \"Data classification: algorithms and applications\",\n                \"Tight lower bounds for halfspace range searching\",\n                \"Regularity lemmas and combinatorial algorithms\",\n                \"Multidimensional divide-and-conquer\",\n                \"On the complexity of higher order abstract voronoi diagrams\",\n                \"Approximate range mode and range median queries\",\n                \"Optimal partition trees\",\n                \"Speeding up the four russians algorithm by about one more logarithmic factor\",\n                \"Linear-space data structures for range mode query in arrays\",\n                \"Cutting hyperplanes for divide-and-conquer\",\n                \"A singly exponential stratification scheme for real semi-algebraic varieties and its applications\",\n                \"New applications of random sampling in computational geometry\",\n                \"Nearest neighbor pattern classification\",\n                \"Ray Shooting, Depth Orders and Hidden Surface Removal, volume 703 of Lecture Notes in Computer Science\",\n                \"Cuttings and applications\",\n                \"The upper envelope of piecewise linear functions: Tight bounds on the number of faces\",\n                \"Simulation of simplicity: a technique to cope with degenerate cases in geometric algorithms\",\n                \"A general approach to removing degeneracies\",\n                \"Boolean matrix multiplication and transitive closure\",\n                \"An algorithm for finding best matches in logarithmic expected time\",\n                \"Approximating the k-level in three-dimensional plane arrangements\",\n                \"A kğ‘˜k-nearest-neighbour classifier for assessing consumer credit risk\",\n                \"Dynamic planar voronoi diagrams for general distance functions and their algorithmic applications\",\n                \"Almost tight upper bounds for vertical decompositions in four dimensions\",\n                \"Range mode and range median queries on lists and trees\",\n                \"An adaptive nearest neighbor classification algorithm for data streams\",\n                \"Two-dimensional voronoi diagrams in the lp-metric\",\n                \"On k-nearest neighbor voronoi diagrams in the plane\",\n                \"Nearly Optimal Planar ğ‘˜ Nearest Neighbors Queries under General Distance Functions\",\n                \"The k-nearest-neighbor voronoi diagram revisited\",\n                \"Range searching with efficient hierarchical cuttings\",\n                \"Combinatorial optimization with rational objective functions\",\n                \"Applying parallel computation algorithms in the design of serial algorithms\",\n                \"Chromatic nearest neighbor searching: A query sensitive approach\",\n                \"The upper envelope of piecewise linear functions and the boundary of a region enclosed by convex plates: Combinatorial analysis\",\n                \"Planar point location using persistent search trees\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]12 based on the context and research area of Chromatic ğ‘˜-Nearest Neighbor Queries. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}