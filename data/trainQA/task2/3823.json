{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: Approximation Algorithms for Interdiction Problem with Packing Constraints\n\nPaper Abstract: \n\nPaper Section Text:\nIn recent years, there is an increasing interest in adopting the Stackelberg competition modelÂ  to address the critical security concern that arises in protecting our ports, airports, transportation, and other critical national infrastructures (see, e.g.,Â   ). In these problems, the attackerâ€™s target is to maximize the illicit gain, while the defender tries to mitigate the attack by minimizing the attackerâ€™s objective through deploying defending resources. In this paper, we consider an abstract model for general defending problems called interdiction with packing constraints (IPC). In IPC, given are a set of items, together with a leader and a follower. Both the leader and the follower have their own (multi-dimensional) budgets, respectively. Each item is associated with a profit, which is the same to the leader and the follower, and will consume the leaderâ€™s (followerâ€™s) budget if it is selected by the leader (follower). The leader and the follower will select items in a sequential way: First, the leader selects items within the leaderâ€™s budget. Then the follower selects items from the remaining items within the followerâ€™s budget. The goal of the leader is to minimize the maximum profit that the follower can obtain. IPC captures the general setting where the follower is the attacker who gets profit by attacking items, and the leader is the defender who tries to minimize the attackerâ€™s gain by protecting a subset of items. IPC can be formulated as a bilevel integer program (IP) as follows. Denote by I={1,2,â‹¯,n}ğ¼12â‹¯ğ‘›I=\\{1,2,\\cdots,n\\} the set of items. Each item jâˆˆIğ‘—ğ¼j\\in I is associated with a profit pjâˆˆâ„š>0subscriptğ‘ğ‘—subscriptâ„šabsent0p_{j}\\in\\mathbb{Q}_{>0}, an sAsubscriptğ‘ ğ´s_{A}-dimensional cost vector ğ€jâˆˆâ„šâ‰¥0sAsubscriptğ€ğ‘—superscriptsubscriptâ„šabsent0subscriptğ‘ ğ´\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf A$}}{\\mbox{\\boldmath$\\textstyle\\bf A$}}{\\mbox{\\boldmath$\\scriptstyle\\bf A$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf A$}}_{j}\\in\\mathbb{Q}_{\\geq 0}^{s_{A}} to the leader and an sBsubscriptğ‘ ğµs_{B}-dimensional weight vector ğjâˆˆâ„šâ‰¥0sBsubscriptğğ‘—superscriptsubscriptâ„šabsent0subscriptğ‘ ğµ\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf B$}}{\\mbox{\\boldmath$\\textstyle\\bf B$}}{\\mbox{\\boldmath$\\scriptstyle\\bf B$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf B$}}_{j}\\in\\mathbb{Q}_{\\geq 0}^{s_{B}} to the follower. The leader and the follower have their own budget vectors, denoted by ğšâˆˆâ„šâ‰¥0sAğšsuperscriptsubscriptâ„šabsent0subscriptğ‘ ğ´{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf a$}}{\\mbox{\\boldmath$\\textstyle\\bf a$}}{\\mbox{\\boldmath$\\scriptstyle\\bf a$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf a$}}}\\in\\mathbb{Q}_{\\geq 0}^{s_{A}} and ğ›âˆˆâ„šâ‰¥0sBğ›superscriptsubscriptâ„šabsent0subscriptğ‘ ğµ{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf b$}}{\\mbox{\\boldmath$\\textstyle\\bf b$}}{\\mbox{\\boldmath$\\scriptstyle\\bf b$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf b$}}}\\in\\mathbb{Q}_{\\geq 0}^{s_{B}}, respectively. We introduce 0-1 variables xjsubscriptğ‘¥ğ‘—x_{j} and yjsubscriptğ‘¦ğ‘—y_{j} for each jâˆˆIğ‘—ğ¼j\\in I as the decision variables for the leader and the follower. More precisely, if the leader chooses item jğ‘—j, then xj=1subscriptğ‘¥ğ‘—1x_{j}=1, otherwise xj=0subscriptğ‘¥ğ‘—0x_{j}=0. Similarly, yj=1subscriptğ‘¦ğ‘—1y_{j}=1 if the follower chooses item jğ‘—j and yj=0subscriptğ‘¦ğ‘—0y_{j}=0 otherwise. Denote by ğ±=(x1,x2,â€¦,xn)ğ±subscriptğ‘¥1subscriptğ‘¥2â€¦subscriptğ‘¥ğ‘›{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf x$}}{\\mbox{\\boldmath$\\textstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf x$}}}=(x_{1},x_{2},\\dots,x_{n}), ğ²=(y1,y2,â€¦,yn)ğ²subscriptğ‘¦1subscriptğ‘¦2â€¦subscriptğ‘¦ğ‘›{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf y$}}{\\mbox{\\boldmath$\\textstyle\\bf y$}}{\\mbox{\\boldmath$\\scriptstyle\\bf y$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf y$}}}=(y_{1},y_{2},\\dots,y_{n}), ğ©=(p1,p2,â€¦,pn)ğ©subscriptğ‘1subscriptğ‘2â€¦subscriptğ‘ğ‘›{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf p$}}{\\mbox{\\boldmath$\\textstyle\\bf p$}}{\\mbox{\\boldmath$\\scriptstyle\\bf p$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf p$}}}=(p_{1},p_{2},\\dots,p_{n}) and ğŸ=(1,â€¦,1âŸn)1subscriptâŸ1â€¦1ğ‘›\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf 1$}}{\\mbox{\\boldmath$\\textstyle\\bf 1$}}{\\mbox{\\boldmath$\\scriptstyle\\bf 1$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf 1$}}=(\\underbrace{1,\\dots,1}_{n}). IPC can be formulated as a bilevel program IPC(I,ğš,ğ›)ğ¼ğšğ›(I,{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf a$}}{\\mbox{\\boldmath$\\textstyle\\bf a$}}{\\mbox{\\boldmath$\\scriptstyle\\bf a$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf a$}}},{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf b$}}{\\mbox{\\boldmath$\\textstyle\\bf b$}}{\\mbox{\\boldmath$\\scriptstyle\\bf b$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf b$}}}) as follows: where ğ€=(ğ€1,â‹¯,ğ€n)ğ€subscriptğ€1â‹¯subscriptğ€ğ‘›\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf A$}}{\\mbox{\\boldmath$\\textstyle\\bf A$}}{\\mbox{\\boldmath$\\scriptstyle\\bf A$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf A$}}=(\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf A$}}{\\mbox{\\boldmath$\\textstyle\\bf A$}}{\\mbox{\\boldmath$\\scriptstyle\\bf A$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf A$}}_{1},\\cdots,\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf A$}}{\\mbox{\\boldmath$\\textstyle\\bf A$}}{\\mbox{\\boldmath$\\scriptstyle\\bf A$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf A$}}_{n}) and ğ=(ğ1,â‹¯,ğn)ğsubscriptğ1â‹¯subscriptğğ‘›\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf B$}}{\\mbox{\\boldmath$\\textstyle\\bf B$}}{\\mbox{\\boldmath$\\scriptstyle\\bf B$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf B$}}=(\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf B$}}{\\mbox{\\boldmath$\\textstyle\\bf B$}}{\\mbox{\\boldmath$\\scriptstyle\\bf B$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf B$}}_{1},\\cdots,\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf B$}}{\\mbox{\\boldmath$\\textstyle\\bf B$}}{\\mbox{\\boldmath$\\scriptstyle\\bf B$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf B$}}_{n}) are sAÃ—nsubscriptğ‘ ğ´ğ‘›s_{A}\\times n and sBÃ—nsubscriptğ‘ ğµğ‘›s_{B}\\times n non-negative rational matrices, respectively. The most relevant prior work to our IPC model is the well-known knapsack interdiction problem introduced by DeNegreÂ 3, which is the special case of IPC where sA=1subscriptğ‘ ğ´1s_{A}=1 and sB=1subscriptğ‘ ğµ1s_{B}=1. Very recently, Caprara et al.Â  proved that DeNegreâ€™s knapsack interdiction problem is âˆ‘2psuperscriptsubscript2ğ‘\\sum_{2}^{p}-complete and strongly NP-hard, which also implies the âˆ‘2psuperscriptsubscript2ğ‘\\sum_{2}^{p}-completeness and strongly NP-hardness for IPC. Caprara et al. showed a polynomial time approximation scheme (PTAS) for a special case of knapsack interdiction problem where the profit of an item is equal to its weight to the follower. Except for the knapsack interdiction problem, we are not aware of any approximation algorithms for other special cases of IPC. However, if we relax the followerâ€™s problem by allowing ğ²ğ²\\textstyle\\bf y to take fractional value, then there are several research works in the literature. The most relevant work is the packing interdiction problem studied by Dinitz and GuptaÂ 4, where the followerâ€™s problem is given by maxâ¡{âˆ‘jpjâ€‹(1âˆ’xj)â€‹yj:Bâ€‹ğ²â‰¤ğ›,ğ²â‰¥ğŸ}:subscriptğ‘—subscriptğ‘ğ‘—1subscriptğ‘¥ğ‘—subscriptğ‘¦ğ‘—formulae-sequenceğµğ²ğ›ğ²0\\max\\{\\sum_{j}p_{j}(1-x_{j})y_{j}:B{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf y$}}{\\mbox{\\boldmath$\\textstyle\\bf y$}}{\\mbox{\\boldmath$\\scriptstyle\\bf y$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf y$}}}\\leq{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf b$}}{\\mbox{\\boldmath$\\textstyle\\bf b$}}{\\mbox{\\boldmath$\\scriptstyle\\bf b$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf b$}}},{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf y$}}{\\mbox{\\boldmath$\\textstyle\\bf y$}}{\\mbox{\\boldmath$\\scriptstyle\\bf y$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf y$}}}\\geq\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf 0$}}{\\mbox{\\boldmath$\\textstyle\\bf 0$}}{\\mbox{\\boldmath$\\scriptstyle\\bf 0$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf 0$}}\\}, while the leaderâ€™s constraints are the same as (1b) and (1c) except that sA=1subscriptğ‘ ğ´1s_{A}=1. Dinitz and Gupta provided an approximation algorithm whose ratio depends on the sparsity of the matrix BğµB. Their techniques crucially rely on the fact that ğ²ğ²\\textstyle\\bf y can take fractional value, and therefore duality theory can be applied to the followerâ€™s problem, allowing the bilevel problem to be transformed to a single level problem. Besides the packing interdiction problem, quite a few graph interdiction problems have been studied in the literature, where the followerâ€™s problem is a standard graph optimization problem, and the leader can remove edges or vertices to minimize the followerâ€™s optimal objective value on the graph after edge-removal or vertex-removal. On planar graphs, polynomial time approximation schemes (PTASs) were obtained for network flow interdictionÂ  and matching interdictionÂ . On general graphs, approximation algorithms were also obtained for, e.g., connectivity interdictionÂ 8, minimum spanning tree interdictionÂ , matching interdiction 4, network flow interdictionÂ [ref]8Â Â , etc. All of these algorithms crucially rely on the followerâ€™s specific graph optimization problem and do not apply directly to IPC. The main contribution of this paper is an (sB+Ïµ)subscriptğ‘ ğµitalic-Ïµ(s_{B}+\\epsilon)-approximation polynomial time algorithm for IPC when sAsubscriptğ‘ ğ´s_{A} and sBsubscriptğ‘ ğµs_{B} are both constant. In particular, when sB=1subscriptğ‘ ğµ1s_{B}=1, our algorithm is a PTAS. Since the knapsack interdiction problem is a special case of IPC when sA=sB=1subscriptğ‘ ğ´subscriptğ‘ ğµ1s_{A}=s_{B}=1, our result gives the first ğ’ªâ€‹(1)ğ’ª1{\\mathcal{O}}(1)-approximation algorithm for this problem. To complement our result, we also show that IPC does not admit any (4/3âˆ’Ïµ)43italic-Ïµ({4}/{3}-\\epsilon)-approximation algorithm even if sB=2subscriptğ‘ ğµ2s_{B}=2 and sA=1subscriptğ‘ ğ´1s_{A}=1, assuming Pâ‰ Nâ€‹Pğ‘ƒğ‘ğ‘ƒP\\neq NP. This implies that the PTAS for sB=1subscriptğ‘ ğµ1s_{B}=1 cannot be further extended to the case of sBâ‰¥2subscriptğ‘ ğµ2s_{B}\\geq 2. We also consider a natural variant of IPC where the leaderâ€™s budget can be violated. For this variant we obtain a (Ï1âˆ’Î±,1Î±)ğœŒ1ğ›¼1ğ›¼(\\frac{\\rho}{1-\\alpha},\\frac{1}{\\alpha})-bicriteria approximation algorithm for any Î±âˆˆ(0,1)ğ›¼01\\alpha\\in(0,1), which runs in polynomial time when sAsubscriptğ‘ ğ´s_{A} and sBsubscriptğ‘ ğµs_{B} are arbitrary (not necessarily polynomial in the input size). More precisely, the algorithm takes as input two oracles, a ÏğœŒ\\rho-approximation algorithm to the followerâ€™s optimization problem maxâ¡{ğ©ğ²:ğğ²â‰¤ğ›,ğ²âˆˆ{0,1}n}:ğ©ğ²formulae-sequenceğğ²ğ›ğ²superscript01ğ‘›\\max\\{{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf p$}}{\\mbox{\\boldmath$\\textstyle\\bf p$}}{\\mbox{\\boldmath$\\scriptstyle\\bf p$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf p$}}}{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf y$}}{\\mbox{\\boldmath$\\textstyle\\bf y$}}{\\mbox{\\boldmath$\\scriptstyle\\bf y$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf y$}}}:\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf B$}}{\\mbox{\\boldmath$\\textstyle\\bf B$}}{\\mbox{\\boldmath$\\scriptstyle\\bf B$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf B$}}{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf y$}}{\\mbox{\\boldmath$\\textstyle\\bf y$}}{\\mbox{\\boldmath$\\scriptstyle\\bf y$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf y$}}}\\leq{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf b$}}{\\mbox{\\boldmath$\\textstyle\\bf b$}}{\\mbox{\\boldmath$\\scriptstyle\\bf b$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf b$}}},{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf y$}}{\\mbox{\\boldmath$\\textstyle\\bf y$}}{\\mbox{\\boldmath$\\scriptstyle\\bf y$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf y$}}}\\in\\{0,1\\}^{n}\\}; and a separation oracle for the leaderâ€™s problem that given any ğ±=ğ±0ğ±superscriptğ±0{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf x$}}{\\mbox{\\boldmath$\\textstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf x$}}}={\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf x$}}{\\mbox{\\boldmath$\\textstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf x$}}}^{0}, it either asserts that ğ€ğ±0â‰¤ğšsuperscriptğ€ğ±0ğš\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf A$}}{\\mbox{\\boldmath$\\textstyle\\bf A$}}{\\mbox{\\boldmath$\\scriptstyle\\bf A$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf A$}}{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf x$}}{\\mbox{\\boldmath$\\textstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf x$}}}^{0}\\leq{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf a$}}{\\mbox{\\boldmath$\\textstyle\\bf a$}}{\\mbox{\\boldmath$\\scriptstyle\\bf a$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf a$}}} or returns a violating constraint. Then in polynomial oracle time the algorithm returns a solution ğ±âˆ—superscriptğ±{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf x$}}{\\mbox{\\boldmath$\\textstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf x$}}}^{*} for the leader such that ğ€ğ±âˆ—â‰¤1Î±â€‹ğšsuperscriptğ€ğ±1ğ›¼ğš\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf A$}}{\\mbox{\\boldmath$\\textstyle\\bf A$}}{\\mbox{\\boldmath$\\scriptstyle\\bf A$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf A$}}{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf x$}}{\\mbox{\\boldmath$\\textstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf x$}}}^{*}\\leq\\frac{1}{\\alpha}{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf a$}}{\\mbox{\\boldmath$\\textstyle\\bf a$}}{\\mbox{\\boldmath$\\scriptstyle\\bf a$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf a$}}}, and the objective value is at most Ïâ€‹Tâˆ—1âˆ’Î±ğœŒsuperscriptğ‘‡1ğ›¼\\frac{\\rho T^{*}}{1-\\alpha}, where Tâˆ—superscriptğ‘‡T^{*} is the optimal objective value with the leaderâ€™s budget being ğšğš\\textstyle\\bf a. When we take, e.g., Î±=1/2ğ›¼12\\alpha=1/2, we achieve an objective of 2â€‹Ïâ€‹Tâˆ—2ğœŒsuperscriptğ‘‡2\\rho T^{*} with the leaderâ€™s budget augmented to 2â€‹ğš2ğš2{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf a$}}{\\mbox{\\boldmath$\\textstyle\\bf a$}}{\\mbox{\\boldmath$\\scriptstyle\\bf a$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf a$}}}. In terms of techniques, our main contribution is a general method for bilevel optimization problems where the leaderâ€™s and followerâ€™s decision variables are both integral. Most prior works on bilevel optimization require followerâ€™s decision variables to take fractional values, which accommodates the application of LP duality to transform the bilevel optimization problem to a standard (single level) optimization, and are thus inapplicable when the followerâ€™s decision variables become integral. A common technique used in many single level optimization problems is to first classify items into large and small based on whether they can make a significant contribution to the objective value, then guess out large items via enumeration, and handle small items fractionally via LP (see, e.g.,Â   . However, such a technique encounters a fundamental challenge in IPC: we can guess out all large items selected by the leader, however, the follower may still select arbitrarily from the remaining large items. In other word, the followerâ€™s choice on large items can never be guessed out, and therefore we cannot apply duality to the followerâ€™s problem. We overcome the challenge based on the following two ideas: First, we show that given leaderâ€™s choice on large items, there is a fixed number of â€dominant choicesâ€ such that the followerâ€™s choice on remaining large items always belong to the dominant choices. Second, we show that there exists a subset of â€critical itemsâ€ such that the followerâ€™s choice on small items can be characterized through linear constraints given that these critical items are known. The two observations allow us to transform the bilevel program for IPC to an LP without utilizing duality. The characterization of dominant choices and critical items become sophisticated in the general case when sBsubscriptğ‘ ğµs_{B} is an arbitrary constant, but is much simpler in the special case sB=1subscriptğ‘ ğµ1s_{B}=1. Hence, for ease of presentation, in the main part we present our algorithm for the special case to give an overview on the technical insights, and meanwhile provide a proof sketch towards generalizing the algorithm for the general case. Our techniques may be of separate interest to other bilevel optimization problems. Our IPC problem lies generally in the area of bilevel optimization, which has received extensive research in the literature. JeroslowÂ  showed that in general, bilevel optimization problems are NP-hard even when the objectives and the constraints are linear. We refer readers toÂ Colson et al.Â 0 for a comprehensive survey on bilevel optimization. Within the area of bilevel optimization, Mixed-Integer Bilevel Linear Problem (MIBLP) is related to our IPC. MIBLP is a bilevel optimization problem where the objective functions and the constraints for the leader and follower are both linear. MIBLP has been studied extensively in the literature, see, e.g.,Â 5Â 9Â 8. We also refer the reader to 7 for an overview on MIBLP solvers and related applications. Most of these algorithmic results are for finding exact solutions through, e.g., branch and bound based approach. For DeNegreâ€™s knapsack interdiction problem, an improved exact algorithm was derived by Federico Della Croce and Rosario Scatamacchia 1. It is worth mentioning that besides DeNegreâ€™s knapsack interdiction problem (i.e., sA=sB=1subscriptğ‘ ğ´subscriptğ‘ ğµ1s_{A}=s_{B}=1 in IPC), other variants of bilevel knapsack problems have also been studied in which the leader interferes the followerâ€™s program in a different way. One kind of bilevel knapsack problem was introduced by Dempe and RichterÂ 2 where two players hold one knapsack, the leader determines the knapsackâ€™s capacity while the follower picks items into the knapsack to maximize his own total profit. The goal is to maximize the objective of the leader. Brotcorne et al.Â  gave a dynamic programming algorithm for both cases of this model. Chen and ZhangÂ [ref]7 proposed a bilevel knapsack variant where two players hold their own knapsacks and the leader can only influence the profit of the items. The follower is interested in his own revenue while the leader aims at maximizing the total profit of both players. The improved approximation results for this problem were derived by Xian Qiu and Walter KernÂ 4. Another bilevel knapsack variant occurred in the work of Pferschy et al.Â 0 where the leader controls the weights of a subset of the followerâ€™s items and the follower aims at maximizing his own profit. The leaderâ€™s payoff is the total weight of the items he controls and selected by the follower. Very recently, Pferschy et al.1 tackled a â€œsymmetricalâ€ problem in which the leader can control the profits instead of item weights. In addition to these works, a matrix interdiction problem was studied by Kasiviswanathan and PanÂ 4. It is also worth mentioning that the continuous version of DeNegreâ€™s knapsack interdiction problem, where the leader and the follower can both fractionally choose an item, has also been studied in recent years. Carvalho et al.Â  gave the first polynomial time optimal algorithm. Later on, a faster optimal algorithm was proposed by Woeginger and FischerÂ 6. Some notations.\nWe write column vectors in boldface, e.g. ğ±,ğ²ğ±ğ²{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf x$}}{\\mbox{\\boldmath$\\textstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf x$}}},{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf y$}}{\\mbox{\\boldmath$\\textstyle\\bf y$}}{\\mbox{\\boldmath$\\scriptstyle\\bf y$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf y$}}}, and their entries in normal font. For a vector ğ±ğ±\\textstyle\\bf x, we either denote its entries by ğ±=(x1,x2,â‹¯,xn)ğ±subscriptğ‘¥1subscriptğ‘¥2â‹¯subscriptğ‘¥ğ‘›{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf x$}}{\\mbox{\\boldmath$\\textstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf x$}}}=(x_{1},x_{2},\\cdots,x_{n}), or by ğ±=(ğ±â€‹,ğ±â€‹,â‹¯,ğ±â€‹[n])ğ±ğ±delimited-[]1ğ±delimited-[]2â‹¯ğ±delimited-[]ğ‘›{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf x$}}{\\mbox{\\boldmath$\\textstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf x$}}}=({\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf x$}}{\\mbox{\\boldmath$\\textstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf x$}}},{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf x$}}{\\mbox{\\boldmath$\\textstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf x$}}},\\cdots,{\\mathchoice{\\mbox{\\boldmath$\\displaystyle\\bf x$}}{\\mbox{\\boldmath$\\textstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptstyle\\bf x$}}{\\mbox{\\boldmath$\\scriptscriptstyle\\bf x$}}}[n]). Given two vectors ğ±ğ±\\textstyle\\bf x and ğ²ğ²\\textstyle\\bf y with the same dimension, their dot product is âˆ‘jxjâ€‹yjsubscriptğ‘—subscriptğ‘¥ğ‘—subscriptğ‘¦ğ‘—\\sum_{j}x_{j}y_{j}, which we denote by ğ±ğ±\\textstyle\\bf xğ²ğ²\\textstyle\\bf y.\n\nReference markers found: [8]\n\nContext windows for each [ref]:\n[ref]8: On general graphs, approximation algorithms were also obtained for, e.g., connectivity interdictionÂ 8, minimum spanning tree interdictionÂ , matching interdiction 4, network flow interdictionÂ [ref]8Â Â , etc. All of these algorithms crucially rely on the followerâ€™s specific graph optimization problem and do not apply directly to IPC. The main contribution of this paper is an\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 8,\n            \"titles\": [\n                \"Interdicting Structured Combinatorial Optimization Problems with {0,1}-Objectives\",\n                \"A deployed quantal response-based patrol planning system for the us coast guard\",\n                \"One-level reformulation of the bilevel knapsack problem using dynamic programming\",\n                \"A decomposition-based pseudoapproximation algorithm for network flow inhibition\",\n                \"A complexity and approximability study of the bilevel knapsack problem\",\n                \"Approximation algorithms for knapsack problems with cardinality constraints\",\n                \"A polynomial algorithm for a continuous bilevel knapsack problem\",\n                \"Approximation algorithms for a bi-level knapsack problem\",\n                \"Hardness and Approximation for Network Flow Interdiction\",\n                \"An overview of bilevel optimization\",\n                \"An exact approach for the bilevel knapsack problem with interdiction constraints and extensions\",\n                \"Bilevel programming with knapsack constraints\",\n                \"Interdiction and discrete bilevel linear programming\",\n                \"Packing interdiction and partial covering problems\",\n                \"The role of investment in entry-deterrence\",\n                \"A faster algorithm for the continuous bilevel knapsack problem\",\n                \"A new general-purpose algorithm for mixed-integer bilevel linear programs\",\n                \"Interdiction games and monotonicity, with application to knapsack problems\",\n                \"A dynamic reformulation heuristic for generalized interdiction problems\",\n                \"Geometric Algorithms and Combinatorial Optimization, volume 2 of Algorithms and Combinatorics\",\n                \"An eptas for scheduling jobs on uniform processors: using an milp relaxation with a constant number of integral variables\",\n                \"Parameterized approximation scheme for the multiple knapsack problem\",\n                \"The polynomial hierarchy and a simple model for competitive analysis\",\n                \"Matrix interdiction problem\",\n                \"A survey on mixed-integer programming techniques in bilevel optimization\",\n                \"Improved algorithms for mst and metric-tsp interdiction\",\n                \"Computers and intractability: a guide to the theory of np-completeness\",\n                \"Interdiction problems on planar graphs\",\n                \"Efficient algorithms to solve bayesian stackelberg games for security applications\",\n                \"A stackelberg knapsack game with weight control\",\n                \"On the stackelberg knapsack game\",\n                \"The network inhibition problem\",\n                \"Deployed armor protection: the application of a game theoretic model for security at the los angeles international airport\",\n                \"Improved approximation algorithms for a bilevel knapsack problem\",\n                \"A class of algorithms for mixed-integer bilevel min-max optimization\",\n                \"Matching interdiction\",\n                \"Network flow interdiction on planar graphs\",\n                \"Connectivity interdiction\",\n                \"An ğ‘‚â¢(1)-Approximation for Minimum Spanning Tree Interdiction\",\n                \"Generated Reference Title 39 for [ref]8\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]8 based on the context and research area of Approximation Algorithms for Interdiction Problem with Packing Constraints. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}