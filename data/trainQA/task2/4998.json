{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: The Complexity of Pattern Counting in Directed Graphs, Parameterised by the Outdegree1footnote 11footnote 1This research was funded in whole, or in part, by the Royal Society project ”RAISON DATA” (Project reference: RP\\R1\\201074) and by the Google Focused Award “Algorithms and Learning for AI” (ALL4AI). For the purpose of Open Access, the authors have applied a CC BY public copyright licence to any Author Accepted Manuscript version arising from this submission. All data is provided in full in the results section of this paper.\n\nPaper Abstract: \n\nPaper Section Text:\nWe study the complexity of the following fundamental counting problem: given two directed graphs, H→→𝐻\\vec{H} (the “pattern”) and G→→𝐺\\vec{G} (the “host”), count the number of occurrences or induced occurrences of H→→𝐻\\vec{H} in G→→𝐺\\vec{G}. This problem, known as subgraph counting, motif counting, or pattern counting, has gained great popularity because of its apparent ubiquity in a diverse selection of fields, from social network analysis  to network science  , and from database theory      and data mining   to bioinformatics  8, phylogeny 6, and genetics 9 . For this reason, subgraph counting in general has received significant attention from the theoretical community in the last two decades, with a flurry of novel techniques and exciting results    4 5 2  1 7 3 [ref]7 1. Since subgraph counting in general is hard (think of counting cliques), it is common to parameterise the problem so as to allow for a “bad” dependence on some quantity that is believed to be small in practice  . The standard parameterisation is by the size of H→→𝐻\\vec{H}, that is, |H→|=|V​(H→)|+|E​(H→)|→𝐻𝑉→𝐻𝐸→𝐻|\\vec{H}|=|V(\\vec{H})|+|E(\\vec{H})|. In that case, one says the problem is fixed-parameter tractable, or in the class 𝖥𝖯𝖳𝖥𝖯𝖳\\mathsf{FPT}, if for some (computable) function f𝑓f it admits an algorithm that runs in time f​(|H→|)⋅|G→|O​(1)⋅𝑓→𝐻superscript→𝐺𝑂1f(|\\vec{H}|)\\cdot|\\vec{G}|^{O(1)} for all H→→𝐻\\vec{H} and G→→𝐺\\vec{G}. This means one considers as efficient an algorithm with running time, say, 2|H→|⋅|G→|⋅superscript2→𝐻→𝐺2^{|\\vec{H}|}\\cdot|\\vec{G}|, but not one with running time |G→||H→|superscript→𝐺→𝐻|\\vec{G}|^{|\\vec{H}|}. The rationale is that in practice H→→𝐻\\vec{H} is often very small compared to G→→𝐺\\vec{G}, thus a running time of 2|H→|⋅|G→|⋅superscript2→𝐻→𝐺2^{|\\vec{H}|}\\cdot|\\vec{G}| is better than one of |G→||H→|superscript→𝐺→𝐻|\\vec{G}|^{|\\vec{H}|}. Under this parameterisation, the tractability of the problem is well understood: for the undirected version, both the induced and non-induced versions are in 𝖥𝖯𝖳𝖥𝖯𝖳\\mathsf{FPT} if and only if certain invariants of H𝐻H are bounded 8 4 , and it is not hard to show that the same holds for the directed case as well (see Section 2). While the parameterisation by |H→|→𝐻|\\vec{H}| is standard, it is also quite restrictive. Consider for instance the problem of counting the induced copies of H→→𝐻\\vec{H} in G→→𝐺\\vec{G}: when parameterised by |H→|→𝐻|\\vec{H}|, it is well-known that the problem is in 𝖥𝖯𝖳𝖥𝖯𝖳\\mathsf{FPT} if and only if the pattern size |H→|→𝐻|\\vec{H}| is bounded (see 8 and Appendix B). Thus, under this parameterization, one can efficiently count the induced copies of just a finite number of patterns. Suppose instead the parameter is |H→|+d​(G→)→𝐻𝑑→𝐺|\\vec{H}|+d(\\vec{G}), where d​(G→)𝑑→𝐺d(\\vec{G}) is the maximum outdegree of G→→𝐺\\vec{G}; the problem is then considered tractable if for some (computable) function f𝑓f it admits an algorithm that runs in time f​(|H→|,d​(G→))⋅|G→|O​(1)⋅𝑓→𝐻𝑑→𝐺superscript→𝐺𝑂1f(|\\vec{H}|,d(\\vec{G}))\\cdot|\\vec{G}|^{O(1)} for all H→→𝐻\\vec{H} and G→→𝐺\\vec{G}. It is not hard to see that, under this parameterization, the problem becomes 𝖥𝖯𝖳𝖥𝖯𝖳\\mathsf{FPT} even for infinite families of patterns. Let indeed H→→𝐻\\vec{H} be the acyclic orientation of a k𝑘k-clique: since H→→𝐻\\vec{H} has only one source s𝑠s (a vertex of indegree 00), one can first guess the image of s𝑠s in G→→𝐺\\vec{G} and then iterate over all (k−1)𝑘1(k-1)-vertex subsets in the out-neighbourhood of s𝑠s, which yields an algorithm with running time O​(d​(G→)|H→|⋅|G→|)𝑂⋅𝑑superscript→𝐺→𝐻→𝐺O(d(\\vec{G})^{|\\vec{H}|}\\cdot|\\vec{G}|). This idea was in fact extended to counting subgraphs in degenerate host graphs, which have orientations with bounded outdegree  0  3 2 [ref]7 (see Section 3.4 for a detailed discussion). Thus, adopting |H→|+d​(G→)→𝐻𝑑→𝐺|\\vec{H}|+d(\\vec{G}) as a parameter can open the door to a richer landscape of tractability. The goal of the present work is to understand precisely what that landscape is; that is, to understand when the aforementioned problems, parameterised by |H→|+d​(G→)→𝐻𝑑→𝐺|\\vec{H}|+d(\\vec{G}), are in 𝖥𝖯𝖳𝖥𝖯𝖳\\mathsf{FPT} as a function of the pattern H→→𝐻\\vec{H}. In addition to the aforementioned example of pattern counting in degenerate graphs, there is another reason to consider d​(G→)𝑑→𝐺d(\\vec{G}) as part of the parameter when counting directed subgraphs: several “real-world” directed graphs that are natural “hosts” have small or constant outdegree. This is true for many web graphs or online social network graphs, where the maximum outdegree is much smaller than the average degree or the maximum indegree; and it is true by construction in graphs produced by generative models such as preferential attachment .\nAs is customary, to express the dependence on the structure of H→→𝐻\\vec{H}, we formulate the problems as a function of a class C→→𝐶\\vec{C} of patterns — for instance, one may let C→→𝐶\\vec{C} be the class of all directed complete graphs, or of all directed trees. Let then C→→𝐶\\vec{C} denote an arbitrary family of directed graphs, and for any H→→𝐻\\vec{H} and G→→𝐺\\vec{G} let #​𝖲𝗎𝖻​(H→→G→)#𝖲𝗎𝖻→→𝐻→𝐺\\#\\mbox{$\\mathsf{Sub}(\\vec{H}\\!\\rightarrow\\!\\vec{G})$} and #​𝖨𝗇𝖽𝖲𝗎𝖻​(H→→G→)#𝖨𝗇𝖽𝖲𝗎𝖻→→𝐻→𝐺\\#\\mbox{$\\mathsf{IndSub}(\\vec{H}\\!\\rightarrow\\!\\vec{G})$} denote respectively the number of copies and induced copies of H→→𝐻\\vec{H} in G→→𝐺\\vec{G}. Our parameterised counting problems are formally defined as follows:\n{parameterizedproblem}\n{parameterizedproblem}\n\n\n\n\n\nThe goal of the present work is to understand which structural properties of the elements of C→→𝐶\\vec{C} determine whether #​DirSubd​(C→)#subscriptDirSubd→𝐶\\#\\textsc{DirSub}_{\\mathrm{d}}(\\vec{C}) and #​DirIndSubd​(C→)#subscriptDirIndSubd→𝐶\\#\\textsc{DirIndSub}_{\\mathrm{d}}(\\vec{C}) are in 𝖥𝖯𝖳𝖥𝖯𝖳\\mathsf{FPT}. The rest of this manuscript is organised as follows. Section 2 gives a concise overview of our results and their significance. Section 3 gives a detailed overview of our proofs and their key technical insights. The complete proofs of all our claims can be found in the remaining sections.\n\nReference markers found: [7]\n\nContext windows for each [ref]:\n[ref]7: reason, subgraph counting in general has received significant attention from the theoretical community in the last two decades, with a flurry of novel techniques and exciting results    4 5 2  1 7 3 [ref]7 1. Since subgraph counting in general is hard (think of counting cliques), it is common to parameterise the problem so as to allow for a “bad” dependence on some quantity that is believed to\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 7,\n            \"titles\": [\n                \"Counting Subgraphs in Degenerate Graphs\",\n                \"Efficient graphlet counting for large networks\",\n                \"Statistical mechanics of complex networks\",\n                \"Biomolecular network motif counting and discovery by color coding\",\n                \"When is Approximate Counting for Conjunctive Queries Tractable?\",\n                \"Galois Theory, volume 2\",\n                \"Approximation Algorithms for Some Parameterized Counting Problems\",\n                \"Linear Time Subgraph Counting, Graph Degeneracy, and the Chasm at Size Six\",\n                \"Near-Linear Time Homomorphism Counting in Bounded Degeneracy Graphs: The Barrier of Long Induced Cycles\",\n                \"How the Degeneracy Helps for Triangle Counting in Graph Streams\",\n                \"Extensor-Coding\",\n                \"Faster algorithms for counting subgraphs in sparse graphs\",\n                \"Exact and Approximate Pattern Counting in Degenerate Graphs: New Algorithms, Hardness Results, and Complexity Dichotomies\",\n                \"Semantic Width and the Fixed-Parameter Tractability of Constraint Satisfaction Problems\",\n                \"Counting Answers to Existential Positive Queries: A Complexity Classification\",\n                \"Tight lower bounds for certain parameterized NP-hard problems\",\n                \"Strong computational lower bounds via parameterized complexity\",\n                \"Understanding the Complexity of Induced Subgraph Isomorphisms\",\n                \"Fast Algorithms at Low Temperatures via Markov Chains\",\n                \"Arboricity and subgraph listing algorithms\",\n                \"Counting matchings of size k is #W[1]-hard\",\n                \"The simple, little and slow things count: On parameterized counting complexity\",\n                \"Homomorphisms are a good basis for counting small subgraphs\",\n                \"Complexity of counting subgraphs: only the boundedness of the vertex-cover number counts\",\n                \"The complexity of counting homomorphisms seen from the other side\",\n                \"Counting Answers to Existential Questions\",\n                \"Structural Tractability of Counting of Solutions to Conjunctive Queries\",\n                \"The Parameterized Complexity of Counting Problems\",\n                \"Parameterized Complexity Theory\",\n                \"Approximately counting answers to conjunctive queries with disequalities and negations\",\n                \"Counting Small Induced Subgraphs with Hereditary Properties\",\n                \"Counting Homomorphic Cycles in Degenerate Graphs\",\n                \"Constraint solving via fractional edge covers\",\n                \"On the complexity of SAT\",\n                \"The parameterised complexity of counting connected subgraphs and graph motifs\",\n                \"Topological network alignment uncovers biological function and phylogeny\",\n                \"Approximate counting of k-paths: Simpler, deterministic, and in polynomial space\",\n                \"Large Networks and Graph Limits, volume 60 of Colloquium Publications\",\n                \"Can You Beat Treewidth?\",\n                \"Tractable Hypergraph Properties for Constraint Satisfaction and Conjunctive Queries\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]7 based on the context and research area of The Complexity of Pattern Counting in Directed Graphs, Parameterised by the Outdegree1footnote 11footnote 1This research was funded in whole, or in part, by the Royal Society project ”RAISON DATA” (Project reference: RP\\\\R1\\\\201074) and by the Google Focused Award “Algorithms and Learning for AI” (ALL4AI). For the purpose of Open Access, the authors have applied a CC BY public copyright licence to any Author Accepted Manuscript version arising from this submission. All data is provided in full in the results section of this paper.. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}