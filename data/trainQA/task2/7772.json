{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: Parameterized Dynamic Logic â€” Towards A Cyclic Logical Framework for Program Verification via Operational Semantics\n\nPaper Abstract: \n\nPaper Section Text:\nReasoning about programs directly through their executable semantics is not a new idea.\nAs far as we know, the first related work was\nmatching logic, proposed by Rosu and Stefanescu inÂ [ref]36.\nMatching logic is based on patterns and pattern matching.\nIts basic form, a reachability rule Ï†â‡’Ï†â€²â‡’ğœ‘superscriptğœ‘â€²\\varphi\\Rightarrow\\varphi^{\\prime} (note that â‡’â‡’\\Rightarrow means differently there than in our sequents), captures whether pattern Ï†â€²superscriptğœ‘â€²\\varphi^{\\prime} is reachable from pattern Ï†ğœ‘\\varphi in a given pattern reachability system.\nOne-path reachability logicÂ  and all-paths reachability logicÂ \nwere developed based on matching logic by adding conditional rules and a all-paths reachability rule Ï†â‡’âˆ€Ï†â€²superscriptâ‡’for-allğœ‘superscriptğœ‘â€²\\varphi\\Rightarrow^{\\forall}\\varphi^{\\prime} respectively.\nThe concept of â€˜patternsâ€™ in matching/reachability logics has a wider scope of meaning than the concepts of â€˜programsâ€™, â€˜configurationsâ€™ and â€˜formulasâ€™ in ğ·ğ¿psubscriptğ·ğ¿ğ‘\\mathit{DL}_{p}.\nThe program specifications described with modal operator [â‹…]delimited-[]â‹…[\\cdot] in ğ·ğ¿psubscriptğ·ğ¿ğ‘\\mathit{DL}_{p} cannot be expressed in matching logic and one-path reachability logic when the program models are non-deterministic, as [â‹…]delimited-[]â‹…[\\cdot] captures â€œthe reachability of ALL execution pathsâ€.\nHowever, the semantics of [â‹…]delimited-[]â‹…[\\cdot] can be captured by the reachability rule Ï†â‡’âˆ€Ï†â€²superscriptâ‡’for-allğœ‘superscriptğœ‘â€²\\varphi\\Rightarrow^{\\forall}\\varphi^{\\prime} in all-paths reachability logic.\nA more powerful matching Î¼ğœ‡\\mu-logicÂ  was developed by adding a least fixpoint Î¼ğœ‡\\mu-binder to matching logic.\nWe conjecture that matching Î¼ğœ‡\\mu-logic can encode ğ·ğ¿psubscriptğ·ğ¿ğ‘\\mathit{DL}_{p}, as it has been declared inÂ  that it can encode traditional dynamic logics.\nSo compared to reachability logic and matching-Î¼ğœ‡\\mu logic, our contribution is not about expressiveness, but that we propose a different proof theory rooted in cyclic reasoning (rather than coinductionÂ ) and the theory of dynamic logic for program verification via operational semantics. Compared to all matching, reachability and matching-Î¼ğœ‡\\mu logics above, one advantage of ğ·ğ¿psubscriptğ·ğ¿ğ‘\\mathit{DL}_{p} is that\nğ·ğ¿psubscriptğ·ğ¿ğ‘\\mathit{DL}_{p} comes to program deductions in a more natural and direct way, in the sense that the concepts of â€˜programsâ€™ and â€˜configurationsâ€™ are explicitly expressed, and programs and formulas are clearly separated by the modal operator [â‹…]delimited-[]â‹…[\\cdot].\nAs we put previously, this brings a benefit that we can observe how program behaviours evolve independently from the formulas along the whole derivation processes.\nOn the other hand,\nto express a ğ·ğ¿psubscriptğ·ğ¿ğ‘\\mathit{DL}_{p} specification like (Ïƒ:Ï•)â‡’(Ïƒ:âŸ¨Î±âŸ©Ïˆ)(\\sigma:\\phi)\\Rightarrow{}(\\sigma:\\langle\\alpha\\rangle\\psi) in matching logic for example,\none needs to â€˜mix upâ€™ all structures together to form a pattern, in a form like: Ï†=dâ€‹fÎ±âˆ§Ïƒâˆ§Ï•subscriptğ‘‘ğ‘“ğœ‘ğ›¼ğœitalic-Ï•\\varphi=_{df}\\alpha\\wedge\\sigma\\wedge\\phi and Ï†â€²=dâ€‹fâ†“âˆ§Ïƒâ€²âˆ§Ïˆ\\varphi^{\\prime}=_{df}\\downarrow\\wedge\\sigma^{\\prime}\\wedge\\psi for some configuration Ïƒâ€²superscriptğœâ€²\\sigma^{\\prime}, in order to prove the reachability rule Ï†â‡’Ï†â€²â‡’ğœ‘superscriptğœ‘â€²\\varphi\\Rightarrow{}\\varphi^{\\prime}. Â proposed a general program verification framework based on coinduction, the theory the reachability logicsÂ   also rely on.\nUsing the terminology in this paper,\ninÂ  a program specification can be expressed as a pair (c,P)ğ‘ğ‘ƒ(c,P) with cğ‘c a program state and Pğ‘ƒP a set of program states, capturing the exact meaning of\nformula Ïƒ:[Î±]â€‹Ï•:ğœdelimited-[]ğ›¼italic-Ï•\\sigma:[\\alpha]\\phi in ğ·ğ¿psubscriptğ·ğ¿ğ‘\\mathit{DL}_{p} if we let cğ‘c be (Î±,Ïƒ)ğ›¼ğœ(\\alpha,\\sigma) and let set Pğ‘ƒP be the semantics of formula Ï•italic-Ï•\\phi.\nThe authors designed a method to derive a program specification (c,P)ğ‘ğ‘ƒ(c,P) in a coinductive way\naccording to the operational semantics of cğ‘c.\nThe soundness of the method is proved by using the greatest fixpoint theory on mathematical sets.\nFollowingÂ , Â also proposed a general framework for program reasoning, but via big-step semantics.\nUnlike the frameworks inÂ  andÂ , which are directly based on set theory,\nğ·ğ¿psubscriptğ·ğ¿ğ‘\\mathit{DL}_{p} has an explicit form of logic, which is more suitable in some cases to catch specifications.\nThe proof system of ğ·ğ¿psubscriptğ·ğ¿ğ‘\\mathit{DL}_{p} is based on the cyclic proof theory (cf.Â ) rather than coinduction, where\nespecially, the soundness of ğ·ğ¿psubscriptğ·ğ¿ğ‘\\mathit{DL}_{p} is proved by contradiction on the well-foundedness of partial-order relations.\nBesides, in ğ·ğ¿psubscriptğ·ğ¿ğ‘\\mathit{DL}_{p}, one can also express and derive the negation of a dynamic formula Ïƒ:[Î±]â€‹Ï•:ğœdelimited-[]ğ›¼italic-Ï•\\sigma:[\\alpha]\\phi as the dual formula Ïƒ:âŸ¨Î±âŸ©â€‹Â¬Ï•:ğœdelimited-âŸ¨âŸ©ğ›¼italic-Ï•\\sigma:\\langle\\alpha\\rangle\\neg\\phi, whose meaning cannot be captured in the framework ofÂ . The structure â€˜updatesâ€™ in traditional dynamic logics, used in Java dynamic logicÂ , differential dynamic logicÂ , dynamic trace logicÂ , etc., works as a special case of the configurations in this paper. As illustrated at the end of SectionÂ 4.1, a configuration is more than just a calculus for substitutions of variables and terms. The proof system of ğ·ğ¿psubscriptğ·ğ¿ğ‘\\mathit{DL}_{p} relies on the cyclic proof theory which firstly arose inÂ 0, and later developed in\ndifferent logics such asÂ , , etc.\nTraditional dynamic logicsâ€™ proof systems are not cyclic ones.\nInÂ ,\nJungteerapanich proposed a complete cyclic proof system for Î¼ğœ‡\\mu-calculus, which subsumes propositional dynamic logic (PDL)Â  in its expressiveness. InÂ , Docherty and Rowe proposed a complete labelled cyclic proof system for PDL.\nBoth Î¼ğœ‡\\mu-calculus and PDL are logics with regular expressions with tests as their program models, which are not in a parameterized form like the program models of ğ·ğ¿psubscriptğ·ğ¿ğ‘\\mathit{DL}_{p}.\nThe labelled form of ğ·ğ¿psubscriptğ·ğ¿ğ‘\\mathit{DL}_{p} formula Ïƒ:[Î±]â€‹Ï•:ğœdelimited-[]ğ›¼italic-Ï•\\sigma:[\\alpha]\\phi comes fromÂ , where a labelled PDL formula is of the form s:[Î±]â€‹Ï•:ğ‘ delimited-[]ğ›¼italic-Ï•s:[\\alpha]\\phi, with sğ‘ s a state in Kripke structure.\nRather than just a state,\na configuration Ïƒğœ\\sigma in ğ·ğ¿psubscriptğ·ğ¿ğ‘\\mathit{DL}_{p} allow more forms rather than functions mapping variables to values (see our Example 2).\nÂ has inspired us to use the well-founded relation â‰ºmsubscriptprecedesğ‘š\\prec_{m} in the proof of the soundness of ğ·ğ¿psubscriptğ·ğ¿ğ‘\\mathit{DL}_{p}, though we take a different proof approach since unlike PDL, ğ·ğ¿psubscriptğ·ğ¿ğ‘\\mathit{DL}_{p} formulas do not satisfy the â€œfinite model propertyâ€ (cf.Â ).\n\nReference markers found: [36]\n\nContext windows for each [ref]:\n[ref]36: Reasoning about programs directly through their executable semantics is not a new idea.\nAs far as we know, the first related work was\nmatching logic, proposed by Rosu and Stefanescu inÂ [ref]36.\nMatching logic is based on patterns and pattern matching.\nIts basic form, a reachability rule Ï†â‡’Ï†â€²â‡’ğœ‘superscriptğœ‘â€²\\varphi\\Rightarrow\\varphi^{\\prime} (note that â‡’â‡’\\Rightarrow means differently\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 36,\n            \"titles\": [\n                \"All-Path Reachability Logic\",\n                \"Program Logics for Certified Compilers\",\n                \"Principles of Model Checking\",\n                \"Foundations of Probabilistic Programming\",\n                \"Dynamic logic with trace semantics\",\n                \"Dynamic Logic for Java, pp. 49â€“106\",\n                \"A propositional dynamic logic for concurrent programs based on the Ï€ğœ‹\\\\pi-calculus\",\n                \"The Esterel synchronous programming language: design, semantics, implementation\",\n                \"Cyclic proofs of program termination in separation logic\",\n                \"A generic cyclic theorem prover\",\n                \"Complete sequent calculi for induction and infinite descent\",\n                \"Matching mâ€‹uğ‘šğ‘¢mu-logic\",\n                \"Proving termination with multiset orderings\",\n                \"A Non-wellfounded, Labelled Proof System for Propositional Dynamic Logic\",\n                \"A probabilistic dynamic logic\",\n                \"Propositional dynamic logic of regular programs\",\n                \"Untersuchungen Ã¼ber das logische SchlieÃŸen\",\n                \"A hoare calculus for the verification of synchronous languages\",\n                \"Deep Learning\",\n                \"First-Order Dynamic Logic, Lecture Notes in Computer Science (LNCS), vol.Â 68\",\n                \"Dynamic Logic\",\n                \"An axiomatic basis for computer programming\",\n                \"Unifying theories of programming, vol.Â 14\",\n                \"A tableau system for the modal Î¼ğœ‡\\\\mu-calculus\",\n                \"A probabilistic pdl\",\n                \"Kleene algebra with tests\",\n                \"Reasoning about Iteration and Recursion Uniformly based on Big-step Semantics\",\n                \"A Calculus of Communicating Systems\",\n                \"Program verification by coinduction\",\n                \"Incorrectness logic\",\n                \"A specification logic for programs in the probabilistic guarded command language\",\n                \"Differential dynamic logic for verifying parametric hybrid systems\",\n                \"Stochastic differential dynamic logic for stochastic hybrid programs\",\n                \"Logical Foundations of Cyber-Physical Systems\",\n                \"A structural approach to operational semantics\",\n                \"Compiling Esterel\",\n                \"Towards a unified theory of operational and axiomatic semantics\",\n                \"Toward verified artificial intelligence\",\n                \"Local model checking in the modal mu-calculus\",\n                \"Towards aÂ unifying logical framework forÂ neural networks\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]36 based on the context and research area of Parameterized Dynamic Logic â€” Towards A Cyclic Logical Framework for Program Verification via Operational Semantics. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}