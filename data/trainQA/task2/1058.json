{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: Provenance Graph Kernel\n\nPaper Abstract: \n\nPaper Section Text:\nSimilar definitions of provenance types have been proposed as a tool for provenance graph summarisation  . In both these approaches, the idea of the history of provenance nodes being related to a sequence of transformations described by edge labels is used. To the best of our knowledge, however, this is the first work to explore the use of provenance types in the context of machine learning methods.\nWhen comparing the efficiency of the other summarisation methods with our own, we find that the definition by  requires an exponential time 𝒪​(n​d0​p​t)𝒪𝑛superscript𝑑0𝑝𝑡\\mathcal{O}(nd^{0}pt), where d𝑑d is the maximum degree of nodes in an input graphs, and n𝑛n its number of nodes.\nOn the other hand,  propose a faster algorithm that takes 𝒪​(0​p​t​m)𝒪0𝑝𝑡𝑚\\mathcal{O}(0ptm), where m𝑚m is the number of edges of an input graph. This is faster than our algorithm by a factor of 0​p​t0𝑝𝑡0pt, which is typically small and does not depend on the size of the graph.\nThis faster algorithm, however, shares similarities with Weisfeiler-Lehman graph kernels to a point in which patterns with very close meaning in provenance are classified differently. More specifically, the algorithm does not inspect sub-trees beyond their first level in order to discard repetitions. This is discussed in detail later in this section and exemplified in Fig. 3. ML techniques\non graphs\nhave been proposed in the domain on provenance (e.g. .\nProvenance Network Analytics (PNA) [ref]13, for example, creates, for each graph, a feature vector that encodes a sequence of different graph topological properties.\nSome of these are provenance agnostic, such as the number of nodes, or the number of edges. Others, in contrast, record the longest shortest paths between, e.g., two provenance entities, or between an agent and an activity.\nIn Section 4, we compare the performance of provenance kernels and PNA in the same classification tasks. For other works in provenance and ML see  and [ref]19. Provenance kernels compare and classify graphs, as opposed to comparing and classifying nodes on graphs. The latter is often known as kernels on graphs (as opposed to graph kernels), or graph embedding techniques. A notable example of graph embedding technique is Struc2Vec  is a learning technique based on the structural identity of nodes on graphs that embed nodes into a Euclidean space according to the structure of their neighbourhood. Similarly to provenance kernels, struc2vec has a hierarchical approach when looking at the structure of the neighbourhood of nodes. The main difference to our work is that Struc2Vec does not consider edge nor node labels, but instead the number of occurrences of neighbouring elements (and their degrees). Another commonality is that both works define a distance between nodes based on their neighbours and a suitable metric.\nIn the context of knowledge graphs, graph embedding for link prediction was used in .\nThe former work used implicit computations to compare a pair of graphs, whether the latter introduced explicit methods allowing for faster computation (for a survey on similar models, see ).\nML methods for Resource Description Framework (RDF) graphs have been studied by  (RDF2Vec),  and .\nOther known approaches that for example aim to find missing labels or links in graphs include NodeSketch [ref]26, DeepWalk ,\nand Node2Vec . Using the classification from , we can place provenance kernels in the Information Propagation graph kernel family. More specifically, in the group of Kernels based on iterative label refinement. That is because we iteratively update node labels up to 0​p​t0𝑝𝑡0pt times based on the other node labels. Other graph kernel methods in the same family include Neighbourhood Hash kernels (NH) , Weisfeiler-Lehman kernels (WL) , and Neighborhood Subgraph Pairwise Distance kernel (NSPD) . Out of those, only the latter originally have taken into account the edge labels in addition to node labels in its classification. A possible extension for labelled edges, however, is mentioned in WL original work  and made explicit by . On the other hand, the WL graph kernel algorithm presented by  does not consider edge labels.\nA close variant to this WL extension was also proposed by , with the differences that (1) repetitions of branches from the same given parent in its walk-tree are discarded and; (2) although all edge-labels were considered, only nodes at the leaves of trees had their labels taken in account. Another close variant of WL, that uses truncated trees as features, was proposed recently in .\nDiscarding repetitions, however, is key in reducing the sizes of feature vectors by putting together patterns that have a similar meaning in provenance. In this paper, we extend this process further by agglutinating even more similar patterns into the same provenance type.\nFig. 3 shows two examples of such types.\nIn essence, the extra sequence of two derivations in Pattern 111 does not add qualitative meaning to the set of transformations that lead to the creation of the root node.\nThus, provenance kernels consider these two patterns as having the same type. One can see provenance types for provenance kernels as a flattened version of the ones defined by  since the idea of branches is hidden by the sole enumeration of labels at a given depth. In terms of theoretical computational complexity, provenance kernels are situated in the efficient spectrum. Note that provenance kernel’s computational complexity for one graph with m𝑚m edges, 𝒪​(0​p​t2​m)𝒪0𝑝superscript𝑡2𝑚\\mathcal{O}(0pt^{2}m), is bounded by 𝒪​(0​p​t2​n​d)𝒪0𝑝superscript𝑡2𝑛𝑑\\mathcal{O}(0pt^{2}nd), where d𝑑d is the maximum (out) degree and n𝑛n is the number of nodes of this graph. Also, m=n​d𝑚𝑛𝑑m=nd if and only if the input graph is regular.\nGraphlet Sampling kernel (GS)  counts the number of small subgraphs present in each input graph.\nThese small subgraphs typically have size k∈{3,4,5}𝑘345k\\in\\{3,4,5\\}. The original time required to run this kernel, 𝒪​(nk)𝒪superscript𝑛𝑘\\mathcal{O}(n^{k}), is prohibitively expensive.\nLater,  improved this bound to 𝒪​(n​dk−1)𝒪𝑛superscript𝑑𝑘1\\mathcal{O}(nd^{k-1}), where d𝑑d is the maximum degree of nodes in an input graph.\nNeighbourhood Hash kernel (NH)  compares graphs by counting the number of common node labels, which are updated with the employment of logical operations that take in account the label of neighbouring nodes.\nThese operations do not use the original categorical node label, but a binary array so XOR operations can be employed. The complexity of this kernel is bounded by 𝒪​(b​h​n​D¯)𝒪𝑏ℎ𝑛¯𝐷\\mathcal{O}(bhn\\bar{D}), where D¯¯𝐷\\bar{D} is the average degree of the vertices, hℎh is how many times the update is executed, and b𝑏b is the number of bit labels.\nWe need 2b−1>>|Σ|much-greater-thansuperscript2𝑏1Σ2^{b}-1>>|\\Sigma|, size of the label set.\nFinally, Neighborhood Subgraph Pairwise Distance kernel (NSPD)  compares subgraphs S𝑆S in the neighbourhood of nodes up to a distance r𝑟r for all pair of nodes in a given graph.\nThe complexity, 𝒪​(n​|S|​|E​(S)|​log⁡|E​(S)|)𝒪𝑛𝑆𝐸𝑆𝐸𝑆\\mathcal{O}(n|S||E(S)|\\log|E(S)|), is such that S𝑆S is the subgraph induced by the neighbourhood of a vertex and radius r𝑟r. E​(S)𝐸𝑆E(S) is the number of edges of S𝑆S. We can see that some of the theoretical gaps on running times between provenance kernels and the others discussed above come down to low-impact variables that may even be treated as constants, such as the number of bit labels or the size of graphlets. Others, such as maximum degrees and number of edges of neighbourhood subgraphs, are more dependent on input graphs and tend to have more impact on running times, which indicate that provenance kernels are computed faster.\nThese differences are reflected in the empirical running times evaluated in Section 4, in which we show that provenance kernels outperform the three methods described above (GS, NH, and NSPD) in terms of efficiency.\nMoreover, none of these is designed to take as input the edge categorical labels of graphs.\nSubgraph Matching kernel, on the other hand, does consider both edge and node labels as it counts the number of common subgraphs of bounded size k𝑘k between two graphs.\nIt requires, however, an impractical computational running time of 𝒪​(k​nk−1)𝒪𝑘superscript𝑛𝑘1\\mathcal{O}(kn^{k-1}), where n𝑛n this time stands for the sum of sizes of the two graphs being compared.\nIn fact, this kernel timed out in our experiments and its accuracy could not be measured. Table II presents a summary of all graph kernels to be compared to provenance kernels in Section 4.\nIn this table, we note whether node or edge categorical labels were taken into account in the implementation we used, as well as their theoretical complexity.\nWe now briefly discuss the remaining kernel methods.\nThe Shortest Path kernel (SP) , for each graph, constructs a new graph that captures the original graph’s shortest paths and then uses a base kernel to compare two shortest path graph’s.\nThe complexity of SP is 𝒪​(n4)𝒪superscript𝑛4\\mathcal{O}(n^{4}). We use the algorithm of Vertex Histogram (VH) and Edge Histogram (EH) kernels as presented by . VH creates, for each graph, a feature vector that captures the number of nodes with each given node label l, whereas EH does the analogous for edge labels. Their computational complexities are 𝒪​(n)𝒪𝑛\\mathcal{O}(n) for VH and 𝒪​(m)𝒪𝑚\\mathcal{O}(m) for EH. Note that provenance kernels of depth 00 coincide with VH.\nHadamard Code kernel (HC)  is similar to NH, even by showing the same computational complexity.\nIt explores the neighbourhood of nodes iteratively for different levels (or depths). Its name come from the use of Hadarmard code matrices. Finally, when compared against the PNA method, provenance kernels outperform in terms of theoretical computational complexity. One of the features considered in the PNA method is the longest shortest path between two nodes of a given label (two entities, or one entity and one activity, and so on). This gives us a lower bound for PNA’s computational complexity of Ω​(n​m)Ω𝑛𝑚\\Omega(nm).\n\nReference markers found: [13]\n\nContext windows for each [ref]:\n[ref]13: This is discussed in detail later in this section and exemplified in Fig. 3. ML techniques\non graphs\nhave been proposed in the domain on provenance (e.g. .\nProvenance Network Analytics (PNA) [ref]13, for example, creates, for each graph, a feature vector that encodes a sequence of different graph topological properties.\nSome of these are provenance agnostic, such as the number of nodes,\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 13,\n            \"titles\": [\n                \"“Why Should I Trust You?” Explaining the Predictions of Any Classifier\",\n                \"PROV-DM: The PROV data model\",\n                \"Enhancing and abstracting scientific workflow provenance for data publishing\",\n                \"Reprozip: Using provenance to support computational reproducibility\",\n                \"Capturing provenance of global change information\",\n                \"A disaster response system based on human-agent collectives\",\n                \"A Survey on Graph Kernels\",\n                \"Graph Kernels: A Survey\",\n                \"Graph Kernels State-of-the-Art and Future Challenges\",\n                \"Shortest-path kernels on graphs\",\n                \"Weisfeiler-Lehman graph kernels\",\n                \"Scalable kernels for graphs with continuous attributes\",\n                \"On graph kernels: Hardness results and efficient alternatives\",\n                \"Provenance Network Analytics\",\n                \"Reproducing Kernel Hilbert Spaces in Probability and Statistics\",\n                \"Aggregation by provenance types: A technique for summarising provenance graphs\",\n                \"Incremental inference of provenance types\",\n                \"Workflow Provenance in the Lifecycle of Scientific Machine Learning\",\n                \"Towards unified data and lifecycle management for deep learning\",\n                \"struc2vec: Learning Node Representations from Structural Identity\",\n                \"Beyond triplets: Hyper-relational knowledge graph embedding for link prediction\",\n                \"Semantic web in data mining and knowledge discovery: A comprehensive survey\",\n                \"RDF2Vec: RDF graph embeddings for data mining\",\n                \"Graph kernels for rdf data\",\n                \"Substructure counting graph kernels for machine learning from rdf data\",\n                \"Nodesketch: Highly-efficient graph embeddings via recursive sketching\",\n                \"DeepWalk: Online Learning of Social Representations\",\n                \"node2vec: Scalable Feature Learning for Networks\",\n                \"A linear-time graph kernel\",\n                \"Fast neighborhood subgraph pairwise distance kernel\",\n                \"A fast approximation of the Weisfeiler-Lehman graph kernel for RDF data\",\n                \"Tree++: Truncated Tree Based Graph Kernels\",\n                \"Biological network comparison using graphlet degree distribution\",\n                \"Efficient graphlet kernels for large graph comparison\",\n                \"Halting in random walk kernels\",\n                \"Hadamard code graph kernels for classifying graphs\",\n                \"MIMIC-III, a freely accessible critical care database\",\n                \"CollabMap: Crowdsourcing maps for emergency planning\",\n                \"The pokémon go experience: A location-based augmented reality mobile game goes mainstream\",\n                \"NetLogo: A simple environment for modeling complexity\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]13 based on the context and research area of Provenance Graph Kernel. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}