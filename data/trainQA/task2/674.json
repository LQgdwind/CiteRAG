{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: Twin-width III: Max Independent Set, Min Dominating Set, and Coloring\n\nPaper Abstract: \n\nPaper Section Text:\nIn this section, we show how to build on the viewpoint of the previous section to compute shortest paths efficiently.\nWe first show that bounded twin-width graphs admit favorable edge partitions into linearly many bicliques. An interval biclique partition (or IBP, for short) of a graph G𝐺G on vertex set [n]delimited-[]𝑛[n] is a set ℬℬ\\mathcal{B} of bicliques that edge-partitions G𝐺G where each biclique (Ai,Bi)∈ℬsubscript𝐴𝑖subscript𝐵𝑖ℬ(A_{i},B_{i})\\in\\mathcal{B} is such that both sides Aisubscript𝐴𝑖A_{i} and Bisubscript𝐵𝑖B_{i} are two (disjoint) discrete intervals of [n]delimited-[]𝑛[n] (see Figure 5).\nObserve that the latter condition makes interval biclique partitions a more restricted form of the mere biclique (edge-)partitions.\nHowever every graph admits an IBP, since a biclique of ℬℬ\\mathcal{B} can be a single edge of G𝐺G.\nSuch an edge-partition becomes interesting when the number of bicliques in ℬℬ\\mathcal{B} is small, say, at most linear in the number of vertices.\nWe will show that bounded twin-width graphs admit linear-sized IBPs.\nTo give an example, the clique Knsubscript𝐾𝑛K_{n} admits {(,[2,n]),([ref]2,[3,n]),(,[4,n]),…,([n−1],[n])}delimited-[]12𝑛delimited-[]23𝑛delimited-[]34𝑛…delimited-[]𝑛1delimited-[]𝑛\\{(,[2,n]),([ref]2,[3,n]),(,[4,n]),\\ldots,([n-1],[n])\\} as an IBP.\nThe IBP ℬℬ\\mathcal{B} gives a 4​⌈log⁡n⌉​|ℬ|4𝑛ℬ4\\lceil\\log n\\rceil|\\mathcal{B}|-bits representation of the graph. The ordered union tree of a d𝑑d-sequence 𝒮:G=Gn,…,G1=K1:𝒮formulae-sequence𝐺subscript𝐺𝑛…subscript𝐺1subscript𝐾1\\mathcal{S}:G=G_{n},\\ldots,G_{1}=K_{1}, is a pair (𝒯,𝒜)𝒯𝒜(\\mathcal{T},\\mathcal{A}) where 𝒯𝒯\\mathcal{T} is a rooted binary tree whose leaves are in one-to-one correspondence with V​(G)𝑉𝐺V(G), and 𝒜𝒜\\mathcal{A} is an array of length n−1𝑛1n-1 whose i𝑖i-th entry is a pointer to the (distinct) internal node of 𝒯𝒯\\mathcal{T} representing the i𝑖i-th contraction of 𝒮𝒮\\mathcal{S}, i.e., whose rooted subtree has for leaves all the vertices of G𝐺G “contained” in the contracted vertex.\nOur algorithms in [ref]5 [ref]4 can output an ordered union tree in the same running time as for computing the d𝑑d-sequence.\nThe ordered union tree can thus be seen as an alternative way of presenting the d𝑑d-sequence. Every n𝑛n-vertex graph of twin-width d𝑑d has an interval biclique partition ℬℬ\\mathcal{B} of size at most (d+1)​(n−1)𝑑1𝑛1(d+1)(n-1).\nFurthermore ℬℬ\\mathcal{B} can be computed in time O​(d​n)=Od​(n)𝑂𝑑𝑛subscript𝑂𝑑𝑛O(dn)=O_{d}(n) given the ordered union tree of a d𝑑d-sequence for G𝐺G. We relabel the nodes of the tree starting from the leaves.\nFrom left to right, their label now describes the integers from 1 to n𝑛n (see Figure 6).\nAn internal node gets label [i,j]𝑖𝑗[i,j] if the leaves of its subtree precisely form the interval [i,j]𝑖𝑗[i,j].\nThis step can be done in O​(n)𝑂𝑛O(n)-time. Now we read the d𝑑d-sequence backwards, starting from the end G1=K1subscript𝐺1subscript𝐾1G_{1}=K_{1}, and tracking black edges appearing for the first time.\nLet u,v∈V​(Gi+1)𝑢𝑣𝑉subscript𝐺𝑖1u,v\\in V(G_{i+1}) be obtained by splitting z∈V​(Gi)𝑧𝑉subscript𝐺𝑖z\\in V(G_{i}).\nFormally we say that a black edge x​y∈E​(Gi+1)𝑥𝑦𝐸subscript𝐺𝑖1xy\\in E(G_{i+1}) appears for the first time in Gi+1subscript𝐺𝑖1G_{i+1}, if x​y𝑥𝑦xy is not a black edge of Gisubscript𝐺𝑖G_{i} (this implies that {x,y}∩{u,v}≠∅𝑥𝑦𝑢𝑣\\{x,y\\}\\cap\\{u,v\\}\\neq\\emptyset) and x​y𝑥𝑦xy is not of the form u​y𝑢𝑦uy or v​y𝑣𝑦vy with z​y∈E​(Gi)𝑧𝑦𝐸subscript𝐺𝑖zy\\in E(G_{i}).\nIntuitively, not only the black edge is new, but it did not originate from a black edge z​y∈E​(Gi)𝑧𝑦𝐸subscript𝐺𝑖zy\\in E(G_{i}).\nNote that the latter automatically creates two black edges u​y,v​y∈E​(Gi+1)𝑢𝑦𝑣𝑦𝐸subscript𝐺𝑖1uy,vy\\in E(G_{i+1}), but the information carried by these edges is contained in the biclique (y​(G),z​(G))𝑦𝐺𝑧𝐺(y(G),z(G)) already detected. At each of the n−1𝑛1n-1 steps, at most d+1𝑑1d+1 black edges can appear for the first time: possibly one between the two vertices u,v𝑢𝑣u,v, and at most one between {u,v}𝑢𝑣\\{u,v\\} and every red neighbor of z𝑧z in Gisubscript𝐺𝑖G_{i}.\nWe append the corresponding bicliques to ℬℬ\\mathcal{B}.\nThis takes overall time O​(d​n)𝑂𝑑𝑛O(dn), and shows that |ℬ|⩽(d+1)​(n−1)ℬ𝑑1𝑛1|\\mathcal{B}|\\leqslant(d+1)(n-1).\nBy the previous relabeling, the two sides of the bicliques are discrete intervals.\nBy the final observation in the previous paragraph, the bicliques of ℬℬ\\mathcal{B} cover all the edges of G𝐺G.\nBy the definition of a “black edge appearing for the first time”, no edge is covered twice, so ℬℬ\\mathcal{B} is indeed a biclique partition of E​(G)𝐸𝐺E(G). An interesting additional property of the computed IBP ℬℬ\\mathcal{B}, in the case of bounded twin-width graphs, is that the whole set of biclique sides (partite sets) defines a laminar family.\nIndeed, by definition of a contraction sequence, there cannot be two overlapping sides.\nOur algorithm will not use this additional property. For the next algorithm, the interval biclique partition ℬℬ\\mathcal{B} is stored in a look-up table 𝒵𝒵\\mathcal{Z}.\nOne accesses in constant time, with 𝒵​[A]𝒵delimited-[]𝐴\\mathcal{Z}[A], the head of the list of sides B𝐵B such that (A,B)𝐴𝐵(A,B) or (B,A)𝐵𝐴(B,A) is in ℬℬ\\mathcal{B}.\nThe table 𝒵𝒵\\mathcal{Z} can be initialized in time O​(|ℬ|)𝑂ℬO(|\\mathcal{B}|), given the list of bicliques ℬℬ\\mathcal{B}. Given an IBP ℬℬ\\mathcal{B} of an n𝑛n-vertex graph G𝐺G and a vertex s∈V​(G)𝑠𝑉𝐺s\\in V(G), Single-Source Shortest Paths can be solved in time O​((n+|ℬ|)​log⁡n)𝑂𝑛ℬ𝑛O((n+|\\mathcal{B}|)\\log n). Essentially we will perform a breadth-first search (BFS) from vertex s𝑠s, following the bicliques instead of single edges. To start with, we need a quick access to all the bicliques of ℬℬ\\mathcal{B} containing a given vertex u∈V​(G)𝑢𝑉𝐺u\\in V(G).\nAs the sides of the bicliques are intervals, we in fact want to solve the interval stabbing problem: Preprocess a set ℐℐ\\mathcal{I} of intervals to answer queries of the form “list all intervals of ℐℐ\\mathcal{I} containing p𝑝p”.\nFor instance, if we query vertex 21 of Figure 5, we want the fast output of the list of intervals 4 , ,14242124delimited-[]214 , ,.\nThat way we can then get the neighborhood of 21 in the compact form 2 3,4 6, , 212131416222325322 3,4 6, , 2.\nSince our intervals range over [n]delimited-[]𝑛[n], there are optimal static data structures for that problem, with preprocessing time O​(n)𝑂𝑛O(n) and query time O​(q)𝑂𝑞O(q) where q𝑞q is the number of output intervals and n𝑛n is the total number of intervals (see for instance 6 and ).\nTo our knowledge, there is no dynamic version of these data structures that would further support deletions in time o​(log⁡n)𝑜𝑛o(\\log n), let alone in constant amortized time.\nHowever it will be crucial in our algorithm to remove intervals.\nWe thus accept to pay an extra logarithmic factor, and resolve to the simpler use of self-balancing binary search trees such as red-black trees .\nRed-black trees take O​(n​log⁡n)𝑂𝑛𝑛O(n\\log n) to build (by n𝑛n successive insertions in time O​(log⁡n)𝑂𝑛O(\\log n)), and support search queries in O​(log⁡n+q)𝑂𝑛𝑞O(\\log n+q) and deletions in O​(log⁡n)𝑂𝑛O(\\log n).\nHere the search queries are of the form: “list all nodes (intervals) containing a query element or intersecting a query interval”. We maintain two red-black trees.\nThe first, 𝒯ℬsubscript𝒯ℬ\\mathcal{T}_{\\mathcal{B}}, is initialized to the 2​|ℬ|2ℬ2|\\mathcal{B}| nodes of {A,B\\{A,B ||| (A,B)∈ℬ}(A,B)\\in\\mathcal{B}\\}, that is the sides of the bicliques of the IBP.\nThese intervals are sorted by lexicographic order on their pairs of endpoints.\nThis tree will maintain which bicliques are still untraversed in a given direction (we will distinguish the two orientations).\nThe second, 𝒯Usubscript𝒯𝑈\\mathcal{T}_{U}, initially comprises the n𝑛n vertices in V​(G)=[n]𝑉𝐺delimited-[]𝑛V(G)=[n], sorted in the usual order.\n(The integers can be seen as singleton intervals to unify 𝒯ℬsubscript𝒯ℬ\\mathcal{T}_{\\mathcal{B}} and 𝒯Usubscript𝒯𝑈\\mathcal{T}_{U} into the same kind of objects.)\nIt will maintain which vertex of G𝐺G are still unexplored. The primitive Bel​(u,𝒯ℬ)Bel𝑢subscript𝒯ℬ\\texttt{Bel}(u,\\mathcal{T}_{\\mathcal{B}}) (as in belongs) reports all the biclique sides S∈𝒯ℬ𝑆subscript𝒯ℬS\\in\\mathcal{T}_{\\mathcal{B}} such that u∈S𝑢𝑆u\\in S, while Adj​(u,𝒯ℬ)Adj𝑢subscript𝒯ℬ\\texttt{Adj}(u,\\mathcal{T}_{\\mathcal{B}}) (as in adjacency) reports the set of biclique sides B∈𝒯ℬ𝐵subscript𝒯ℬB\\in\\mathcal{T}_{\\mathcal{B}} such that there is a biclique (A,B)∈ℬ𝐴𝐵ℬ(A,B)\\in\\mathcal{B} with u∈A𝑢𝐴u\\in A.\nFinally Int​(𝒯U,[i,j])Intsubscript𝒯𝑈𝑖𝑗\\texttt{Int}(\\mathcal{T}_{U},[i,j]) (as in intersection) lists all the elements of 𝒯Usubscript𝒯𝑈\\mathcal{T}_{U} that are in [i,j]𝑖𝑗[i,j], and we denote by delete​(u,𝒯)delete𝑢𝒯\\text{delete}(u,\\mathcal{T}) the deletion of u𝑢u from the red-black tree 𝒯𝒯\\mathcal{T}. We can now write our algorithm Single-Source Shortest Paths from a classic BFS, by replacing the access to edges of the current vertex u𝑢u by Adj​(u,𝒯ℬ)Adj𝑢subscript𝒯ℬ\\texttt{Adj}(u,\\mathcal{T}_{\\mathcal{B}}), and the vertices to enqueue (and explore later) by ⋃[i,j]∈Adj​(u,𝒯ℬ)Int​(U,[i,j])subscript𝑖𝑗Adj𝑢subscript𝒯ℬInt𝑈𝑖𝑗\\bigcup_{[i,j]\\in\\texttt{Adj}(u,\\mathcal{T}_{\\mathcal{B}})}\\texttt{Int}(U,[i,j]).\nMore precisely, we initialize a queue Q𝑄Q to {s}𝑠\\{s\\}, a set of unexplored vertices U𝑈U to V​(G)∖{s}𝑉𝐺𝑠V(G)\\setminus\\{s\\} as a red-black tree 𝒯usubscript𝒯𝑢\\mathcal{T}_{u}, a set of unaccessed biclique sides of ℬℬ\\mathcal{B} as another red-black tree 𝒯ℬsubscript𝒯ℬ\\mathcal{T}_{\\mathcal{B}}, a shortest-path tree parent relation p𝑝p by p​(s):=sassign𝑝𝑠𝑠p(s):=s, and a distance table d𝑑d to the source s𝑠s by d​(s):=0assign𝑑𝑠0d(s):=0.\nWe remove s𝑠s from 𝒯Usubscript𝒯𝑈\\mathcal{T}_{U}.\nAs long as Q𝑄Q is non-empty, we dequeue u𝑢u from it, and set 𝒮u:=Bel​(u,𝒯ℬ)assignsubscript𝒮𝑢Bel𝑢subscript𝒯ℬ\\mathcal{S}_{u}:=\\texttt{Bel}(u,\\mathcal{T}_{\\mathcal{B}}), and 𝒩u:=Adj​(u,𝒯ℬ)assignsubscript𝒩𝑢Adj𝑢subscript𝒯ℬ\\mathcal{N}_{u}:=\\texttt{Adj}(u,\\mathcal{T}_{\\mathcal{B}}).\nWe remove all the biclique sides of 𝒮usubscript𝒮𝑢\\mathcal{S}_{u} from 𝒯ℬsubscript𝒯ℬ\\mathcal{T}_{\\mathcal{B}}.\nWe set Nu:=⋃[i,j]∈𝒩uInt​(𝒯U,[i,j])assignsubscript𝑁𝑢subscript𝑖𝑗subscript𝒩𝑢Intsubscript𝒯𝑈𝑖𝑗N_{u}:=\\bigcup_{[i,j]\\in\\mathcal{N}_{u}}\\texttt{Int}(\\mathcal{T}_{U},[i,j]).\nFor every v∈Nu𝑣subscript𝑁𝑢v\\in N_{u}, we set p​(v)𝑝𝑣p(v) to u𝑢u, d​(v)𝑑𝑣d(v) to d​(u)+1𝑑𝑢1d(u)+1, we enqueue v𝑣v in Q𝑄Q, and remove it from 𝒯Usubscript𝒯𝑈\\mathcal{T}_{U}.\nWe finally return p𝑝p and d𝑑d (see Algorithm 4 for the pseudo-code). Correctness.\nOur algorithm is a BFS in which some edges that are not traversed may still disappear in one direction (line 12).\nWe only need to argue that these arcs cannot be part of a shortest-path tree rooted at s𝑠s.\nSay the current vertex is u𝑢u, and the set of unexplored vertices is U𝑈U (i.e., the nodes of 𝒯Usubscript𝒯𝑈\\mathcal{T}_{U}).\nWe consider the set 𝒮u:=Bel​(u,Tℬ)assignsubscript𝒮𝑢Bel𝑢subscript𝑇ℬ\\mathcal{S}_{u}:=\\texttt{Bel}(u,T_{\\mathcal{B}}) of biclique sides still in 𝒯ℬsubscript𝒯ℬ\\mathcal{T}_{\\mathcal{B}} and containing u𝑢u.\nAll these intervals are then removed from 𝒯ℬsubscript𝒯ℬ\\mathcal{T}_{\\mathcal{B}}.\nLet u′≠usuperscript𝑢′𝑢u^{\\prime}\\neq u be a vertex in a side S∈𝒮u𝑆subscript𝒮𝑢S\\in\\mathcal{S}_{u}, and let S′superscript𝑆′S^{\\prime} be another side such that (S,S′)∈ℬ𝑆superscript𝑆′ℬ(S,S^{\\prime})\\in\\mathcal{B}.\nThe deletion of 𝒮usubscript𝒮𝑢\\mathcal{S}_{u} implies that an arc from S𝑆S to S′superscript𝑆′S^{\\prime} can no longer be taken.\nWe claim that it is safe to remove the arcs from u′superscript𝑢′u^{\\prime} (or more generally from S𝑆S) to S′superscript𝑆′S^{\\prime}.\nIndeed if u′superscript𝑢′u^{\\prime} is visited after u𝑢u, then d​(u)⩽d​(u′)𝑑𝑢𝑑superscript𝑢′d(u)\\leqslant d(u^{\\prime}).\nThus all the vertices in Nu⊇S′∩Usuperscript𝑆′𝑈subscript𝑁𝑢N_{u}\\supseteq S^{\\prime}\\cap U have already had their distance set to d​(u)+1𝑑𝑢1d(u)+1 (⩽d​(u′)+1absent𝑑superscript𝑢′1\\leqslant d(u^{\\prime})+1) and their parent set to u𝑢u. Note however that the biclique (S′,S)superscript𝑆′𝑆(S^{\\prime},S) may still be traversed (in the other direction, from S′superscript𝑆′S^{\\prime} to S𝑆S).\nThese arcs can very well be on a shortest-path tree.\nThat is why we are removing biclique sides and not bicliques. Running time.\nThe initialization of 𝒯Usubscript𝒯𝑈\\mathcal{T}_{U} and 𝒯ℬsubscript𝒯ℬ\\mathcal{T}_{\\mathcal{B}} takes time O​(n​log⁡n)𝑂𝑛𝑛O(n\\log n) and O​(|ℬ|​log⁡|ℬ|)=O​(|ℬ|​log⁡n)𝑂ℬℬ𝑂ℬ𝑛O(|\\mathcal{B}|\\log|\\mathcal{B}|)=O(|\\mathcal{B}|\\log n), respectively (observe that |B|⩽n2𝐵superscript𝑛2|B|\\leqslant n^{2}, thus O​(log⁡|ℬ|)=O​(log⁡n)𝑂ℬ𝑂𝑛O(\\log|\\mathcal{B}|)=O(\\log n)).\nEach call Bel​(u,Tℬ)Bel𝑢subscript𝑇ℬ\\texttt{Bel}(u,T_{\\mathcal{B}}) reporting q𝑞q sides takes time O​(log⁡n+q)𝑂𝑛𝑞O(\\log n+q).\nIt is immediately followed by the deletion of these sides from 𝒯ℬsubscript𝒯ℬ\\mathcal{T}_{\\mathcal{B}}, in time O​(q​log⁡n)𝑂𝑞𝑛O(q\\log n).\nTherefore in the entire while loop, these operations take overall time O​(|ℬ|​log⁡n)𝑂ℬ𝑛O(|\\mathcal{B}|\\log n).\nObserve that Adj​(u,Tℬ)Adj𝑢subscript𝑇ℬ\\texttt{Adj}(u,T_{\\mathcal{B}}) is built from Bel​(u,Tℬ)Bel𝑢subscript𝑇ℬ\\texttt{Bel}(u,T_{\\mathcal{B}}) by simple access to the look-up table 𝒵𝒵\\mathcal{Z} encoding ℬℬ\\mathcal{B}.\nThis takes time O​(|Adj​(u,Tℬ)|)𝑂Adj𝑢subscript𝑇ℬO(|\\texttt{Adj}(u,T_{\\mathcal{B}})|).\nSince every biclique can be traversed at most twice (once in each direction), overall the calls Adj​(u,Tℬ)Adj𝑢subscript𝑇ℬ\\texttt{Adj}(u,T_{\\mathcal{B}}) take time O​(|ℬ|)𝑂ℬO(|\\mathcal{B}|).\nEach call Int​(𝒯U,[i,j])Intsubscript𝒯𝑈𝑖𝑗\\texttt{Int}(\\mathcal{T}_{U},[i,j]) reporting q𝑞q vertices takes time O​(log⁡n+q)𝑂𝑛𝑞O(\\log n+q).\nThis is followed by removing these vertices from 𝒯Usubscript𝒯𝑈\\mathcal{T}_{U} in time O​(q​log⁡n)𝑂𝑞𝑛O(q\\log n).\nHence this part takes overall time O​(n​log⁡n)𝑂𝑛𝑛O(n\\log n).\nThe rest of the instructions take constant time.\nTherefore the running time of SSSP is O​((n+|ℬ|)​log⁡n)𝑂𝑛ℬ𝑛O((n+|\\mathcal{B}|)\\log n). As a direct corollary of Lemmas 6.1 and 6.3, we get the following two theorems. Let 𝒞𝒞\\mathcal{C} be a class of bounded twin-width on which there is an Od​(n​log⁡n)subscript𝑂𝑑𝑛𝑛O_{d}(n\\log n)-time algorithm computing d𝑑d-sequences for n𝑛n-vertex graphs.\nThen Single-Source Shortest Paths can be solved in 𝒞𝒞\\mathcal{C} in time Od​(n​log⁡n)subscript𝑂𝑑𝑛𝑛O_{d}(n\\log n). Let 𝒞𝒞\\mathcal{C} be a class of bounded twin-width on which there is an Od​(n2​log⁡n)subscript𝑂𝑑superscript𝑛2𝑛O_{d}(n^{2}\\log n)-time algorithm computing d𝑑d-sequences for n𝑛n-vertex graphs.\nThen All-Pairs Shortest Paths can be solved in 𝒞𝒞\\mathcal{C} in time Od​(n2​log⁡n)subscript𝑂𝑑superscript𝑛2𝑛O_{d}(n^{2}\\log n). Note that for all the classes shown to have bounded twin-width in the first two papers of the series [ref]5 [ref]4, an Od​(n2)subscript𝑂𝑑superscript𝑛2O_{d}(n^{2})-time algorithm computes a d𝑑d-sequence (where d𝑑d does not depend on n𝑛n).\nFor some sparse classes (Ktsubscript𝐾𝑡K_{t}-minor free graphs), or some dense classes sparsely presented (unit interval graphs, posets of bounded antichain), it is even possible to obtain the contraction sequence in time Od​(n​log⁡n)subscript𝑂𝑑𝑛𝑛O_{d}(n\\log n).\nFor the latter kind, it yields O​(n​log⁡n)𝑂𝑛𝑛O(n\\log n)-time algorithms (that is, sublinear in the number of edges) computing shortest-path trees from a given source.\nHowever in these individual classes, much simpler arguments would give O​(n)𝑂𝑛O(n)-time algorithms.\nThus the strength of Theorems 6.5 and 6.6 lies more in unifying and generalizing graph classes where O~​(n)~𝑂𝑛\\tilde{O}(n) and O~​(n2)~𝑂superscript𝑛2\\tilde{O}(n^{2}) are achievable for SSSP and APSP, and in the simplicity of the algorithm (a slightly modified BFS). One could wonder if the diameter of a graph given with an O​(1)𝑂1O(1)-sequence can be computed significantly faster than in O​(n2​log⁡n)𝑂superscript𝑛2𝑛O(n^{2}\\log n), by simply calling APSP and reporting the longest distance.\nWe observe that no truly subquadratic algorithm is possible, unless the Strong Exponential Time Hypothesis151515The assumption that, for every ε>0𝜀0\\varepsilon>0, SAT cannot be solved in time (2−ε)nsuperscript2𝜀𝑛(2-\\varepsilon)^{n} by a classical algorithm. (SETH) fails. For every ε,ε′>0𝜀superscript𝜀′0\\varepsilon,\\varepsilon^{\\prime}>0, Diameter on bounded twin-width graphs cannot be computed, or 3/2−ε′32superscript𝜀′3/2-\\varepsilon^{\\prime}-approximated, in time n2−εsuperscript𝑛2𝜀n^{2-\\varepsilon}, unless the SETH fails, even if an O​(1)𝑂1O(1)-sequence of the input graph is given. Such an SETH lower bound exists on graphs of bounded degree (see ).\nWe subdivide ℓ−1ℓ1\\ell-1 times each edge of a hard instance H𝐻H, with degree bounded by ΔΔ\\Delta and n′>1superscript𝑛′1n^{\\prime}>1 vertices, where ℓ:=⌈log⁡n′⌉assignℓsuperscript𝑛′\\ell:=\\lceil\\log n^{\\prime}\\rceil.\nWe attach a pending path on ℓℓ\\ell edges to the n′superscript𝑛′n^{\\prime} original vertices of H𝐻H.\nThis defines a graph G𝐺G with n⩽Δ/2⋅(ℓ−1)​n′+ℓ​n′=O​(n′​log⁡n′)𝑛⋅Δ2ℓ1superscript𝑛′ℓsuperscript𝑛′𝑂superscript𝑛′superscript𝑛′n\\leqslant\\Delta/2\\cdot(\\ell-1)n^{\\prime}+\\ell n^{\\prime}=O(n^{\\prime}\\log n^{\\prime}) vertices.\nThus n=O​(n′⁣1+ε2)𝑛𝑂superscript𝑛′1𝜀2n=O(n^{\\prime 1+\\frac{\\varepsilon}{2}}).\nWe observe that diam(G)=ℓ+ℓ⋅(G)=\\ell+\\ell\\leavevmode\\nobreak\\ \\cdot\\leavevmode\\nobreak\\ diam(H)+ℓ=(ℓ+2)𝐻ℓℓ2(H)+\\ell=(\\ell+2)diam(H)𝐻(H).\nBesides we show in [ref]4 that the log⁡n′superscript𝑛′\\log n^{\\prime}-subdivision of n′superscript𝑛′n^{\\prime}-vertex graphs have bounded twin-width.\nFurthermore an O​(1)𝑂1O(1)-sequence can be computed in O​(n)𝑂𝑛O(n)-time if the initial graph has bounded degree.\nAn n2−εsuperscript𝑛2𝜀n^{2-\\varepsilon}-time algorithm computing the diameter of such a graph G𝐺G, would give an O​((n′⁣1+ε2)2−ε)=O​(n′⁣2−ε22)𝑂superscriptsuperscript𝑛′1𝜀22𝜀𝑂superscript𝑛′2superscript𝜀22O((n^{\\prime 1+\\frac{\\varepsilon}{2}})^{2-\\varepsilon})=O(n^{\\prime 2-\\frac{\\varepsilon^{2}}{2}}).\nSuch a subquadratic algorithm is ruled out, even to obtain a 3/2−ε′32superscript𝜀′3/2-\\varepsilon^{\\prime}-approximation of the diameter, unless the SETH fails.\nFinally one may observe that the reduction preserves the inapproximability gap. A related SETH lower bound is obtained by Coudert et al. , who show that Diameter cannot be solved in time 2o​(cw)​n2−εsuperscript2𝑜cwsuperscript𝑛2𝜀2^{o(\\text{cw})}n^{2-\\varepsilon} on n𝑛n-vertex graphs with clique-width cw.\nThe lower bound of Theorem 6.7 is quantitatively stronger (albeit in an admittedly larger graph class) since it rules out any algorithm solving Diameter in time f​(d)​n2−ε𝑓𝑑superscript𝑛2𝜀f(d)n^{2-\\varepsilon} for any function f𝑓f, on graphs of twin-width at most d𝑑d.\nLet us recall that when the diameter is guaranteed constant, Diameter can be expressed as a first-order formula.\nThus we can compute the exact diameter in O​(n)𝑂𝑛O(n)-time provided the contraction sequence of the input graph [ref]5.\n\nReference markers found: [2]\n\nContext windows for each [ref]:\n[ref]2: is small, say, at most linear in the number of vertices.\nWe will show that bounded twin-width graphs admit linear-sized IBPs.\nTo give an example, the clique Knsubscript𝐾𝑛K_{n} admits {(,[2,n]),([ref]2,[3,n]),(,[4,n]),…,([n−1],[n])}delimited-[]12𝑛delimited-[]23𝑛delimited-[]34𝑛…delimited-[]𝑛1delimited-[]𝑛\\{(,[2,n]),([ref]2,[3,n]),(,[4,n]),\\ldots,([n-1],[n])\\} as an IBP.\nThe IBP ℬℬ\\mathcal{B}\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 2,\n            \"titles\": [\n                \"Graphs of bounded cliquewidth are polynomially 𝜒-bounded\",\n                \"Crossing patterns of semi-algebraic sets\",\n                \"On problems without polynomial kernels\",\n                \"Twin-width II: small classes\",\n                \"Twin-width I: tractable FO model checking\",\n                \"Packing and covering balls in graphs excluding a minor\",\n                \"Filtering search: A new approach to query-answering\",\n                \"Introduction to Algorithms, 3rd Edition\",\n                \"Fully polynomial FPT algorithms for some classes of bounded clique-width graphs\",\n                \"The monadic second-order logic of graphs. I. Recognizable sets of finite graphs\",\n                \"Linear time solvable optimization problems on graphs of bounded clique-width\",\n                \"Subexponential parameterized algorithms on bounded-genus graphs and H-minor-free graphs\",\n                \"Bounding the vertex cover number of a hypergraph\",\n                \"Analytical approach to parallel repetition\",\n                \"Planar subgraph isomorphism revisited\",\n                \"Classes of graphs with small rank decompositions are χ𝜒\\\\chi-bounded\",\n                \"Constant-factor approximation of the domination number in sparse graphs\",\n                \"Subgraph isomorphism in planar graphs and related problems\",\n                \"Diameter and treewidth in minor-closed graph families\",\n                \"Tight hardness results for distance and centrality problems in constant degree graphs\",\n                \"Approximating Clique is almost NP-complete (preliminary version)\",\n                \"Fixed-parameter tractability, definability, and model-checking\",\n                \"The complexity of first-order and monadic second-order logic revisited\",\n                \"A linear-time algorithm for a special case of disjoint set union\",\n                \"The ellipsoid method and its consequences in combinatorial optimization\",\n                \"Polynomial-time algorithm for maximum weight independent set on P6subscript𝑃6{P}_{6}-free graphs\",\n                \"Finding small patterns in permutations in linear time\",\n                \"Epsilon-nets and simplex range queries\",\n                \"On the complexity of SAT\",\n                \"Which problems have strongly exponential complexity?\",\n                \"Approximation algorithms for combinatorial problems\",\n                \"Efficient parameterized algorithms for computing all-pairs shortest paths\",\n                \"On the ratio of optimal integral and fractional covers\",\n                \"Polynomial bounds for centered colorings on proper minor-closed graph classes\",\n                \"A note on stable sets and colorings of graphs\",\n                \"Interval stabbing problems in small integer ranges\",\n                \"An overview of techniques for designing parameterized algorithms\",\n                \"Positive-instance driven dynamic programming for treewidth\",\n                \"Efficient algorithms on sets of permutations, dominance, and real-weighted APSP\",\n                \"Generated Reference Title 39 for [ref]2\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]2 based on the context and research area of Twin-width III: Max Independent Set, Min Dominating Set, and Coloring. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}