{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: Portus: Linking Alloy with SMT-based Finite Model Finding\n\nPaper Abstract: \n\nPaper Section Text:\nThere have been several efforts to translate Alloy to SMT solvers.\nOur approach is distinct for its focus on linking with a library that\ndoes finite model finding for the scopes provided in an Alloy model\nusing SMT solvers, thus keeping the problem decidable.\nAn advantage of relying on EUF (rather than a new decision procedure)\nis that EUF is decidable and widely supported in SMT solvers. Our\napproach will benefit from performance improvements in EUF solvers.\nPortus is also novel in how it handles and optimizes\nscalars and functions,\nsignature hierarchy together with\nnon-exact scopes,\nset cardinality,\nand how it uses\nsymmetry breaking (statically within an SMT solver)\nfor the ordering module.\nPortus covers almost all Alloy constructs (including libraries) and is\nfully integrated into the Alloy Analyzer. Additionally,\nwe extensively evaluate our approach for correctness and performance. El Ghazi et al.  report on a case study where three models in an address book case study are translated by hand to the Yices SMT solver  for mostly unbounded verification. Each basic signature is translated to an uninterpreted type.\nSince Yices allows subsorts, Alloy subsets are expressed using a combination of predicates and subsorts. An extra constant is introduced to be a “non value” for a partial function represented as a total function, which requires custom translation for uses of the partial function.\nUniversal quantifiers are expanded over a finite set of values and existential quantifiers are skolemized.\nSets involved in a closure operator must be finite, which is expressed using iterative squaring. Yices cannot complete evaluation over multiple transitive closures even with relatively small finite scopes in the presented examples. El Ghazi et al.  present a translation from Alloy to SMT-LIB for a completely unbounded analysis where the problem is undecidable and thus\nthe SMT solver may not complete.\nWe note the Alloy operators that we cover beyond their work in Section 3 . Their work does not require any translations of non-exact or exact scope as we do. They describe a representation of transitive closure of a relation through an inductive definition on the number of iterations of the relation (i.e., a pair is in some iteration of the relation). Alloy integers are translated\nto unbounded integers. Set cardinality is handled by mapping every pair in the relation to a distinct integer and the cardinality becomes the largest finite integer used in this mapping.\nThey present five simplifications that cover particular cases of Alloy relations with range multiplicity one, and quantified variables and equality. Our optimizations for scalars and functions are more comprehensive and systematic.\nTheir translation is evaluated on eight models from the Alloy distribution with 20 assertions. Z3 evaluated many of these problems quickly for unbounded sorts. In three cases a spurious counterexample was returned due to the inexactness of the representation of transitive closure.\nEl Ghazi et al. introduce an approach that automatically detects\ninvariants iteratively to tighten the axiomatization of transitive closure over unbounded scopes . There have been a few efforts to link Alloy with interactive theory proving tools.\nPrioni  translates Alloy to the MSFOL of the Athena proof language for reasoning about sorts of unbound scope. Alloy relations and relational operations are axiomatized and the key contribution is that through Athena, induction principles for structures can be created and used.\nKelloy  is a translation of Alloy to the KeY theorem prover  based on many-sorted first-order logic. In this translation, all Alloy fields are represented as relations and transitive closure and set cardinality are represented similar to . Set operations are mapped to predicates of similar names, and the meaning of these predicates in terms of quantifiers become rewrite rules to be used by the theorem prover.\nUsers can interact with the theorem prover to help with quantifier instantiations, etc. Kelloy uses finiteness predicates to state that a signature is finite.\nTwelve of twenty-two assertions in ten models from the Alloy Analyzer distribution were proven automatically within 30 seconds.\nEl Ghazi et al.  present combining three solving strategies for Alloy: SMT-based bounded verification, SMT-based unbounded verification (both based on the translation of ) and interactive-theorem-prover-based full verification using the KeY theorem prover (based on ).\nFor bounded verification, they convert an Alloy model to a formula in quantified bit-vector formula logic (QBVF) where each sort is represented by a fixed-size bit-vector based on its scope.\nThey evaluated their approach on four models. Their SMT-based bounded verification\noutperformed the Alloy Analyzer on three of the four models.\nMeng et al. [ref]16 report that this tool, called AlloyPE, fails on a number of Alloy models due to unsupported Alloy constructs or internal errors.\nThe tool Dynamite  provides a front-end to a shallow embedding of Alloy in PVS  for proofs over signatures of unbounded scope via fork algebras, which have similar operators to Alloy. The proofs are interactive, but as a front-end, custom Alloy proof rules are provided that use the Alloy Analyzer at finite scope to help check introduced lemmas or search for witnesses to existential quantifiers.\nAlloy2JML  translates Alloy specifications treating the heap as a relation to the Java Modelling Language  for annotations of preconditions and postconditions of Java programs. Verification is done using the KeY theorem prover . There are alternative approaches to handling the cardinality operators. Cardinality can be expressed using sufficient first-order formulas introduced by Leino et al.  without finite bounds for comprehensions to prove some verification conditions. There are translations from Alloy to other formal languages.\nAlloy 6\nincludes support for the description of mutable behaviour and temporal properties in LTL and past LTL to constrain the possible behaviours of the model .\nAlloy 6 can translate an Alloy behavioural model to the SMV language for input to NuSMV  and NuXmv . In this translation, the finite relations of the Alloy model are represented in propositional logic using a Boolean variable for each tuple in a relation.\nKrings et al.  translate Alloy to B .\nAs B has language constructs for sets, partial functions, and cardinality, the translation is fairly direct, but does not support libraries except the ordering module.\nThey find that mapping the ordering module to integers is\nmore efficient than using B sequences because B supports integers natively.\nThey test their translation on the river crossing and n-queens models, finding\nthat sometimes ProB is faster than Alloy. There are alternatives to using the Fortress library for finite model finding of translated Alloy models.\nIn Reynolds et al.   , a finite model finding decision procedure is added to CVC4 that checks for satisfying instances of a model at gradually increasing scopes by looking at ground instances of the domain on-demand, rather than the use of domain constants and quantifier expansion (as Fortress does).\nTheir results are promising, but at this time not a good match for expressing\nAlloy’s scope and set cardinality constraints.\nWhen compared to Fortress in , CVC4 with finite model finding\ndid not perform well. As an alternative to translating Alloy to MSFOL, Bansal et al.  present a calculus and decision procedure (implemented in CVC4) for the decidable theory of flat finite (but unbounded) sets of individual elements (not relations) with cardinality and set membership.\nThis decision procedure is extended in Meng et al. [ref]16 to handle quantifier-free formulas with relational operators such as join and transitive closure, and set comprehension,\nbut only supports cardinality over relations in expressions that compare to a constant natural number.\nThey implemented a fairly direct translation from Alloy’s core language to this theory that uses\none sort for Alloy atoms except for integers.\nThey evaluated their approach on a benchmark set consisting of 40 examples from the Alloy distribution plus a few more models using four methods 1) the Alloy Analyzer (AA), 2) AlloyPE, 3) CVC4 with the new calculus and the FMF methods of CVC4, and 4) CVC4 with FMF and a representation of the relational operators as uninterpreted functions with axiomatizations of the behaviour of the operators.\nThirteen models were not solved by any method within the 300 second timeout.\nTo compare against CVC4’s incremental FMF methods, the scope of the Alloy models in the AA had to be gradually increased and thus the AA was run multiple times on one model within the timeout.\nThe performance of the new\ncalculus outperformed the Alloy Analyzer on unsatisfiable problems and was slightly slower than\nthe AA for satisfiable problems.\nThe axiomatic approach and AlloyPE did not perform well due to either timeouts or lack of results.\nMohamed  report on an integration of this approach with the Alloy Analyzer and report\nthat the Alloy Analyzer outperforms this tool for the bounded case. AlleAlle  is a relational model finding library, similar to Kodkod, which translates to an SMT formula in the logic of quantifier-free non-linear integer arithmetic, enabling it to support unbounded integers.\nBy using Codd’s relation algebra as a base rather than Tarski’s relational logic as Kodkod does, AlleAlle does not require data such as integers to be explicitly encoded in the domain.\nAlleAlle also supports optimization criteria that change the order instances are returned.\nAlleAlle translates to Z3 using only a single sort for non-integer atoms and does not apply any symmetry breaking optimizations.\nIn a comparison of six models, AlleAlle was compared to Kodkod without its symmetry breaking and AlleAlle was faster only on models containing integers and cardinality. Reger et al.  extend the Vampire theorem prover to support finite model finding over MSFOL\nby encoding an MSFOL problem in SAT in a way that takes advantage of multiple sorts, rather than using an SMT solver.\nTheir algorithm incrementally increase the sizes of the sorts to evaluate satisfiability over many model sizes.\nThey introduce techniques to determine relationships between the sort sizes in a problem so that fewer combinations of sort sizes need to be considered, including by analyzing returned proofs of unsatisfiability and by detecting properties of functions in the problem.\nSubsorts are also detected and split to further reduce the generated formula size.\nTheir results show favourable performance compared to CVC4. Astra  was a prototype to\ntranslate from Alloy’s Kodkod interface\nto Fortress. Astra\ntranslates only a limited subset of the Alloy language\nand only supports analysis of\nan exact scope size.\nAstra uses a bottom-up approach to translation, which requires the creation of many auxiliary functions and extra quantifiers, causing bottlenecks in efficiency, which we avoid with a top-down approach.\nAstra starts from the Kodkod model and thus requires\nreverse-engineering steps to determine the set hierarchy, which we avoid by starting from the Alloy model.\n\nReference markers found: [16]\n\nContext windows for each [ref]:\n[ref]16: fixed-size bit-vector based on its scope.\nThey evaluated their approach on four models. Their SMT-based bounded verification\noutperformed the Alloy Analyzer on three of the four models.\nMeng et al. [ref]16 report that this tool, called AlloyPE, fails on a number of Alloy models due to unsupported Alloy constructs or internal errors.\nThe tool Dynamite  provides a front-end to a shallow embedding\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 16,\n            \"titles\": [\n                \"Reasoning with finite sets and cardinality constraints in SMT\",\n                \"Software Abstractions, 2nd ed.\",\n                \"Using lightweight modeling to understand Chord\",\n                \"Validating the hybrid ERTMS/ETCS level 3 concept with Electrum\",\n                \"Leveraging the power of formal methods in the realm of enterprise modeling—on the example of extending the (meta) model verification possibilities of ADOxx with Alloy\",\n                \"Constructing security cases based on formal verification of security requirements in Alloy\",\n                \"An HPC practitioner’s workbench for formal refinement checking\",\n                \"Formal verification of interoperability between future network architectures using Alloy\",\n                \"Validating multiple variants of an automotive light system with Alloy 6\",\n                \"Kodkod: A relational model finder\",\n                \"An Extensible SAT-solver\",\n                \"Finite Model Finding Using the Logic of Equality with Uninterpreted Functions\",\n                \"Solvable Cases of the Decision Problem, 2nd ed.\",\n                \"Satisfiability Modulo Theories\",\n                \"Analyzing Alloy Constraints using an SMT Solver: A Case Study\",\n                \"Relational Reasoning via SMT Solving\",\n                \"Relational constraint solving in SMT\",\n                \"A new relational solver for the Alloy Analyzer\",\n                \"Static profiling of Alloy models\",\n                \"Learning to optimize the Alloy Analyzer\",\n                \"New techniques for static symmetry breaking in many-sorted finite model finding\",\n                \"Improvements to many-sorted finite model finding using SMT solvers\",\n                \"Symbolic model checking: 1020superscript102010^{20} states and beyond\",\n                \"Z3: An efficient SMT solver\",\n                \"Design patterns: elements of reuseable object-oriented software\",\n                \"Minimizing disjunctive normal forms of pure first-order logic\",\n                \"The Sat4j library, release 2.2\",\n                \"Jazzer\",\n                \"cvc5: A versatile and industrial-strength SMT solver\",\n                \"Yices 2.2\",\n                \"First-order transitive closure axiomatization via iterative invariant injections\",\n                \"Integrating model checking and theorem proving for relational reasoning\",\n                \"A proof assistant for Alloy specifications\",\n                \"Verification of Object-Oriented Software. The KeY Approach - Foreword by K. Rustan M. Leino\",\n                \"A dual-engine for early analysis of critical systems\",\n                \"Dynamite: A tool for the verification of Alloy models based on PVS\",\n                \"PVS: A prototype verification system\",\n                \"Generating JML specifications from Alloy expressions\",\n                \"JML Reference Manual\",\n                \"Reasoning about Comprehensions with First-Order SMT Solvers\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]16 based on the context and research area of Portus: Linking Alloy with SMT-based Finite Model Finding. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}