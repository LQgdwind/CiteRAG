{
  "paper_id": "2010.06037v3",
  "title": "Streaming enumeration on nested documents",
  "sections": {
    "visibly pushdown transducers and main result": "In this section, we present the definition of visibly pushdown transducersÂ  (), which are an extension of visibly pushdown automata to produce outputs. We use as our computational model to represent queries with output. This model is general enough to include any query language for nested documents, like XML or JSON, whose expressive power is in MSO.\nAfter the setting is formalized, we state the main result of the paper. A visibly pushdown transducer () is a tuple T=(Q,Î£,Î“,Î©,Î”,I,F)TQÎ£Î“Î©Î”IF\\pazocal{T}\\!=(Q,\\Sigma,\\Gamma,\\Omega,\\Delta,I,F) where Qğ‘„Q, Î£Î£\\Sigma, Î“Î“\\Gamma, Iğ¼I, and Fğ¹F are the same as for VPA, Î©Î©\\Omega is the output alphabet with Îµâˆ‰Î©ğœ€Î©\\varepsilon\\notin\\Omega, and\nÎ”âŠ†(QÃ—Î£<Ã—(Î©âˆª{Îµ})Ã—QÃ—Î“)âˆª(QÃ—Î£>Ã—(Î©âˆª{Îµ})Ã—Î“Ã—Q)âˆª(QÃ—Î£|Ã—(Î©âˆª{Îµ})Ã—Q)Î”ğ‘„superscriptÎ£<Î©ğœ€ğ‘„Î“ğ‘„superscriptÎ£>Î©ğœ€Î“ğ‘„ğ‘„superscriptÎ£|Î©ğœ€ğ‘„\\Delta\\subseteq(Q\\times\\Sigma^{\\texttt{<}}\\times(\\Omega\\cup\\{\\varepsilon\\})\\times Q\\times\\Gamma)\\cup(Q\\times\\Sigma^{\\texttt{>}}\\times(\\Omega\\cup\\{\\varepsilon\\})\\times\\Gamma\\times Q)\\cup(Q\\times\\Sigma^{\\texttt{|}}\\times(\\Omega\\cup\\{\\varepsilon\\})\\times Q)\nis the transition relation. As usual for transducers, a symbol sâˆˆÎ£<âˆªÎ£>âˆªÎ£|ğ‘ superscriptÎ£<superscriptÎ£>superscriptÎ£|s\\in\\Sigma^{\\texttt{<}}\\cup\\Sigma^{\\texttt{>}}\\cup\\Sigma^{\\texttt{|}} is an input symbol that the machine reads and o\n\n\n\nâŒ£\n\nâˆˆÎ©âˆª{Îµ}o\n\n\n\nâŒ£\n\nÎ©ğœ€\\operatorname{\\ooalign{\\raisebox{0.0pt}{$o$}\\cr\\rotatebox[origin={c}]{15.0}{\\raisebox{0.86108pt}{\\scalebox{0.7}{$\\ \\boldsymbol{\\smallsmile}$}}}}}\\in\\Omega\\cup\\{\\varepsilon\\} is a symbol that the machine prints in an output tape. Furthermore, Îµğœ€\\varepsilon represents that no symbol is printed for that transition.\nA run ÏğœŒ\\rho of TT\\pazocal{T}\\! over a well-nested word w=s1â€‹s2â€‹â‹¯â€‹snâˆˆÎ£<*>ğ‘¤subscriptğ‘ 1subscriptğ‘ 2â‹¯subscriptğ‘ ğ‘›superscriptÎ£<*>w=s_{1}s_{2}\\cdots s_{n}\\in\\Sigma^{\\texttt{<*>}} is a sequence of the form\nÏ=(q1,Ïƒ1)â†’s1/o\n\n\n\nâŒ£\n\n1â€¦â†’sn/o\n\n\n\nâŒ£\n\nn(qn+1,Ïƒn+1)ğœŒsubscriptğ‘1subscriptğœ1subscriptğ‘ 1subscripto\n\n\n\nâŒ£\n\n1â†’â€¦subscriptğ‘ ğ‘›subscripto\n\n\n\nâŒ£\n\nğ‘›â†’subscriptğ‘ğ‘›1subscriptğœğ‘›1\\rho=(q_{1},\\sigma_{1})\\xrightarrow{s_{1}/\\!\\operatorname{\\scriptsize{\\ooalign{\\raisebox{0.0pt}{$o$}\\cr\\rotatebox[origin={c}]{15.0}{\\raisebox{0.60275pt}{\\scalebox{0.7}{$\\ \\,\\boldsymbol{\\smallsmile}$}}}}}}_{1}}\\ldots\\xrightarrow{s_{n}/\\!\\operatorname{\\scriptsize{\\ooalign{\\raisebox{0.0pt}{$o$}\\cr\\rotatebox[origin={c}]{15.0}{\\raisebox{0.60275pt}{\\scalebox{0.7}{$\\ \\,\\boldsymbol{\\smallsmile}$}}}}}}_{n}}(q_{n+1},\\sigma_{n+1})\nwhere qiâˆˆQsubscriptğ‘ğ‘–ğ‘„q_{i}\\in Q, ÏƒiâˆˆÎ“âˆ—subscriptğœğ‘–superscriptÎ“\\sigma_{i}\\in\\Gamma^{*}, q1âˆˆIsubscriptğ‘1ğ¼q_{1}\\in I, Ïƒ1=Îµsubscriptğœ1ğœ€\\sigma_{1}=\\varepsilon and for every iâˆˆ[1,n]ğ‘–1ğ‘›i\\in[1,n] the following holds:\n(1)Â if siâˆˆÎ£<subscriptğ‘ ğ‘–superscriptÎ£<s_{i}\\in\\Sigma^{\\texttt{<}}, then (qi,si,o\n\n\n\nâŒ£\n\ni,qi+1,Î³)âˆˆÎ”subscriptğ‘ğ‘–subscriptğ‘ ğ‘–subscripto\n\n\n\nâŒ£\n\nğ‘–subscriptğ‘ğ‘–1ğ›¾Î”(q_{i},s_{i},\\operatorname{\\ooalign{\\raisebox{0.0pt}{$o$}\\cr\\rotatebox[origin={c}]{15.0}{\\raisebox{0.86108pt}{\\scalebox{0.7}{$\\ \\boldsymbol{\\smallsmile}$}}}}}_{i},q_{i+1},\\gamma)\\in\\Delta for some Î³âˆˆÎ“ğ›¾Î“\\gamma\\in\\Gamma and Ïƒi+1=Î³â€‹Ïƒisubscriptğœğ‘–1ğ›¾subscriptğœğ‘–\\sigma_{i+1}=\\gamma\\sigma_{i},\n(2)Â if siâˆˆÎ£>subscriptğ‘ ğ‘–superscriptÎ£>s_{i}\\in\\Sigma^{\\texttt{>}}, then (qi,si,o\n\n\n\nâŒ£\n\ni,Î³,qi+1)âˆˆÎ”subscriptğ‘ğ‘–subscriptğ‘ ğ‘–subscripto\n\n\n\nâŒ£\n\nğ‘–ğ›¾subscriptğ‘ğ‘–1Î”(q_{i},s_{i},\\operatorname{\\ooalign{\\raisebox{0.0pt}{$o$}\\cr\\rotatebox[origin={c}]{15.0}{\\raisebox{0.86108pt}{\\scalebox{0.7}{$\\ \\boldsymbol{\\smallsmile}$}}}}}_{i},\\gamma,q_{i+1})\\in\\Delta for some Î³âˆˆÎ“ğ›¾Î“\\gamma\\in\\Gamma and Ïƒi=Î³â€‹Ïƒi+1subscriptğœğ‘–ğ›¾subscriptğœğ‘–1\\sigma_{i}=\\gamma\\sigma_{i+1}, and\n(3)Â if siâˆˆÎ£|subscriptğ‘ ğ‘–superscriptÎ£|s_{i}\\in\\Sigma^{\\texttt{|}}, then (pi,si,o\n\n\n\nâŒ£\n\ni,qi+1)âˆˆÎ”subscriptğ‘ğ‘–subscriptğ‘ ğ‘–subscripto\n\n\n\nâŒ£\n\nğ‘–subscriptğ‘ğ‘–1Î”(p_{i},s_{i},\\operatorname{\\ooalign{\\raisebox{0.0pt}{$o$}\\cr\\rotatebox[origin={c}]{15.0}{\\raisebox{0.86108pt}{\\scalebox{0.7}{$\\ \\boldsymbol{\\smallsmile}$}}}}}_{i},q_{i+1})\\in\\Delta and Ïƒi=Ïƒi+1subscriptğœğ‘–subscriptğœğ‘–1\\sigma_{i}=\\sigma_{i+1}. We say that the run is accepting if qn+1âˆˆFsubscriptğ‘ğ‘›1ğ¹q_{n+1}\\in F.\nWe call a pair (qi,Ïƒi)subscriptğ‘ğ‘–subscriptğœğ‘–(q_{i},\\sigma_{i}) a configuration of ÏğœŒ\\rho.\nFinally, the output of an accepting run ÏğœŒ\\rho is defined as:\noutâ€‹(Ï)=outâ€‹(o\n\n\n\nâŒ£\n\n1,1)â‹…â€¦â‹…outâ€‹(o\n\n\n\nâŒ£\n\nn,n)outğœŒâ‹…outsubscripto\n\n\n\nâŒ£\n\n11â€¦outsubscripto\n\n\n\nâŒ£\n\nğ‘›ğ‘›\\textsf{out}(\\rho)=\\textsf{out}(\\operatorname{\\ooalign{\\raisebox{0.0pt}{$o$}\\cr\\rotatebox[origin={c}]{15.0}{\\raisebox{0.86108pt}{\\scalebox{0.7}{$\\ \\boldsymbol{\\smallsmile}$}}}}}_{1},1)\\cdot\\ldots\\cdot\\textsf{out}(\\operatorname{\\ooalign{\\raisebox{0.0pt}{$o$}\\cr\\rotatebox[origin={c}]{15.0}{\\raisebox{0.86108pt}{\\scalebox{0.7}{$\\ \\boldsymbol{\\smallsmile}$}}}}}_{n},n)\nwhere outâ€‹(o\n\n\n\nâŒ£\n\n,i)=Îµouto\n\n\n\nâŒ£\n\nğ‘–ğœ€\\textsf{out}(\\operatorname{\\ooalign{\\raisebox{0.0pt}{$o$}\\cr\\rotatebox[origin={c}]{15.0}{\\raisebox{0.86108pt}{\\scalebox{0.7}{$\\ \\boldsymbol{\\smallsmile}$}}}}},i)=\\varepsilon when o\n\n\n\nâŒ£\n\n=Îµo\n\n\n\nâŒ£\n\nğœ€\\operatorname{\\ooalign{\\raisebox{0.0pt}{$o$}\\cr\\rotatebox[origin={c}]{15.0}{\\raisebox{0.86108pt}{\\scalebox{0.7}{$\\ \\boldsymbol{\\smallsmile}$}}}}}=\\varepsilon and (o\n\n\n\nâŒ£\n\n,i)o\n\n\n\nâŒ£\n\nğ‘–(\\operatorname{\\ooalign{\\raisebox{0.0pt}{$o$}\\cr\\rotatebox[origin={c}]{15.0}{\\raisebox{0.86108pt}{\\scalebox{0.7}{$\\ \\boldsymbol{\\smallsmile}$}}}}},i) otherwise. Note that in o\n\n\n\nâŒ£\n\n1â¡â‹¯â€‹o\n\n\n\nâŒ£\n\nnsubscripto\n\n\n\nâŒ£\n\n1â‹¯subscripto\n\n\n\nâŒ£\n\nğ‘›\\operatorname{\\ooalign{\\raisebox{0.0pt}{$o$}\\cr\\rotatebox[origin={c}]{15.0}{\\raisebox{0.86108pt}{\\scalebox{0.7}{$\\ \\boldsymbol{\\smallsmile}$}}}}}_{1}\\cdots\\operatorname{\\ooalign{\\raisebox{0.0pt}{$o$}\\cr\\rotatebox[origin={c}]{15.0}{\\raisebox{0.86108pt}{\\scalebox{0.7}{$\\ \\boldsymbol{\\smallsmile}$}}}}}_{n} we use Îµğœ€\\varepsilon as a symbol, and in outâ€‹(Ï)outğœŒ\\textsf{out}(\\rho) we use Îµğœ€\\varepsilon as the empty string. Given a TT\\pazocal{T}\\! and a wâˆˆÎ£<*>ğ‘¤superscriptÎ£<*>w\\in\\Sigma^{\\texttt{<*>}}, we define the set âŸ¦TâŸ§(w)\\llbracket\\pazocal{T}\\!\\mkern 1.0mu\\rrbracket(w) of all outputs of TT\\pazocal{T}\\! over wğ‘¤w as:\nâŸ¦TâŸ§(w)={out(Ï)âˆ£ÏÂ is an accepting run ofÂ TÂ overÂ w}.\\llbracket\\pazocal{T}\\!\\mkern 1.0mu\\rrbracket(w)=\\{\\textsf{out}(\\rho)\\,\\mid\\,\\text{$\\rho$ is an accepting run of $\\pazocal{T}\\!$ over $w$}\\}. \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n Strictly speaking, our definition of is richer than the one studied inÂ . In our definition of each output element is a tuple (o\n\n\n\nâŒ£\n\n,i)o\n\n\n\nâŒ£\n\nğ‘–(\\operatorname{\\ooalign{\\raisebox{0.0pt}{$o$}\\cr\\rotatebox[origin={c}]{15.0}{\\raisebox{0.86108pt}{\\scalebox{0.7}{$\\ \\boldsymbol{\\smallsmile}$}}}}},i) where o\n\n\n\nâŒ£\n\no\n\n\n\nâŒ£\n\n\\operatorname{\\ooalign{\\raisebox{0.0pt}{$o$}\\cr\\rotatebox[origin={c}]{15.0}{\\raisebox{0.86108pt}{\\scalebox{0.7}{$\\ \\boldsymbol{\\smallsmile}$}}}}} is the symbol and iğ‘–i is the output position, where for a standard Â  an output element is just the symbol o\n\n\n\nâŒ£\n\no\n\n\n\nâŒ£\n\n\\operatorname{\\ooalign{\\raisebox{0.0pt}{$o$}\\cr\\rotatebox[origin={c}]{15.0}{\\raisebox{0.86108pt}{\\scalebox{0.7}{$\\ \\boldsymbol{\\smallsmile}$}}}}}.\nThe extension presented here is indeed important for practical applications like in document spannersÂ   or in XML query evaluationÂ  . \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n \n\nâŒ£\n A first reasonable question is to understand what is the expressive power of VPT, namely, as a formalism for non-boolean query evaluation over nested words. For the Boolean case, it was shownÂ  that VPA describe the same class of queries as MSO over nested words, called MSOmatchsubscriptMSOmatch\\text{MSO}_{\\textsf{match}}.\nFormally, fix a structured alphabet Î£Î£\\Sigma and let wâˆˆÎ£<*>ğ‘¤superscriptÎ£<*>w\\in\\Sigma^{\\texttt{<*>}} be a word of lengthÂ nğ‘›n.\nWe encode wğ‘¤w as a structure: where [1,n]1ğ‘›[1,n] is the domain, â‰¤\\leq\nis the total order over [1,n]1ğ‘›[1,n], Pa={iâˆ£wâ€‹[i]=a}subscriptğ‘ƒğ‘conditional-setğ‘–ğ‘¤delimited-[]ğ‘–ğ‘P_{a}=\\{i\\mid w[i]=a\\}, and ğ—†ğ–ºğ—ğ–¼ğ—ğ—†ğ–ºğ—ğ–¼ğ—\\sf{match} is a binary relation over [1,n]1ğ‘›[1,n] that corresponds to the matching relation of open and close symbols: matchâ€‹(i,j)matchğ‘–ğ‘—\\textsf{match}(i,j) is true iff wâ€‹[i]ğ‘¤delimited-[]ğ‘–w[i] is an open symbol and wâ€‹[j]ğ‘¤delimited-[]ğ‘—w[j] is its matching close symbol.\nBy some abuse of notation, we also use wğ‘¤w to denote its corresponding logical structure.\nA MSOmatchsubscriptMSOmatch\\text{MSO}_{\\textsf{match}} formula Ï†ğœ‘\\varphi over Î£Î£\\Sigma is given by: where aâˆˆÎ£ğ‘Î£a\\in\\Sigma, xğ‘¥x and yğ‘¦y are first-order variables and Xğ‘‹X is a monadic second order (MSO) variable.\nWe write Ï†â€‹(X1,â€¦,Xn)ğœ‘subscriptğ‘‹1â€¦subscriptğ‘‹ğ‘›\\varphi(X_{1},\\ldots,X_{n}) where X1,â€¦,Xnsubscriptğ‘‹1â€¦subscriptğ‘‹ğ‘›X_{1},\\ldots,X_{n} are the free MSO variables of Ï†ğœ‘\\varphi (first-order variables are a special case of MSO variables).\nThen we write wâŠ§Ï†â€‹(A1,â€¦,An)modelsğ‘¤ğœ‘subscriptğ´1â€¦subscriptğ´ğ‘›w\\models\\varphi(A_{1},\\ldots,A_{n}) for A1,â€¦,AnâŠ†[1,n]subscriptğ´1â€¦subscriptğ´ğ‘›1ğ‘›A_{1},\\ldots,A_{n}\\subseteq[1,n] when wğ‘¤w satisfies Ï†ğœ‘\\varphi by replacing each variable Xisubscriptğ‘‹ğ‘–X_{i} with the set Aisubscriptğ´ğ‘–A_{i}. Here, we assume the standard semantics for MSO logicÂ [ref]43. Given that VPT is an extension of VPA, it should not be a surprise that we can translate these results to VPT. In particular, the result inÂ  can be easily extended to link VPT with formulas expressible in MSOmatchsubscriptMSOmatch\\text{MSO}_{\\textsf{match}}. Let Ï†â€‹(X1,â€¦,Xm)ğœ‘subscriptğ‘‹1â€¦subscriptğ‘‹ğ‘š\\varphi(X_{1},\\ldots,X_{m}) be a MSOmatchsubscriptMSOmatch\\text{MSO}_{\\textsf{match}} formula with mğ‘šm free variables X1,â€¦,Xmsubscriptğ‘‹1â€¦subscriptğ‘‹ğ‘šX_{1},\\ldots,X_{m}.\nThere is a VPT TT\\pazocal{T}\\! for which there is a one-to-one correspondence between the set\nâŸ¦TâŸ§(w)\\llbracket\\pazocal{T}\\!\\mkern 1.0mu\\rrbracket(w)\nand the set {(A1,â€¦,Am)âˆ£wâŠ§Ï†â€‹(A1,â€¦,Am)}conditional-setsubscriptğ´1â€¦subscriptğ´ğ‘šmodelsğ‘¤ğœ‘subscriptğ´1â€¦subscriptğ´ğ‘š\\{(A_{1},\\ldots,A_{m})\\mid w\\models\\varphi(A_{1},\\ldots,A_{m})\\} for any word wâˆˆÎ£<*>ğ‘¤superscriptÎ£<*>w\\in\\Sigma^{\\texttt{<*>}}.\nMoreover, for every VPT TT\\pazocal{T}\\! there is an MSOmatchsubscriptMSOmatch\\text{MSO}_{\\textsf{match}} formula Ï†â€‹(X1,â€¦,Xm)ğœ‘subscriptğ‘‹1â€¦subscriptğ‘‹ğ‘š\\varphi(X_{1},\\ldots,X_{m}) for which the same one-to-one correspondence holds. In other words, VPT has the same expressive power as MSO over nested words. Given that fragments of query languages over nested documents (e.g., navigational XPathÂ 4, JSON Navigational LogicÂ ) are usually included in MSO, this shows that VPT is an expressive formalism for query evaluation over nested documents.\nAs an example, in the appendix we show how to translate some XPath queries into , including QQ\\pazocal{Q}. We say that a T=(Q,Î£,Î“,Î©,Î”,I,F)TQÎ£Î“Î©Î”IF\\pazocal{T}\\!=(Q,\\Sigma,\\Gamma,\\Omega,\\Delta,I,F) is input/output deterministic (I/O-deterministic for short) if |I|=1ğ¼1|I|=1 and Î”Î”\\Delta is a partial function of the form Î”:(QÃ—Î£<Ã—Î©â†’QÃ—Î“)âˆª(QÃ—Î£>Ã—Î©Ã—Î“â†’Q)âˆª(QÃ—Î£|Ã—Î©â†’Q):Î”â†’ğ‘„superscriptÎ£<Î©ğ‘„Î“â†’ğ‘„superscriptÎ£>Î©Î“ğ‘„â†’ğ‘„superscriptÎ£|Î©ğ‘„\\Delta:(Q\\times\\Sigma^{\\texttt{<}}\\times\\Omega\\to Q\\times\\Gamma)\\cup(Q\\times\\Sigma^{\\texttt{>}}\\times\\Omega\\times\\Gamma\\to Q)\\cup(Q\\times\\Sigma^{\\texttt{|}}\\times\\Omega\\to Q).\nOn the other hand, we say that TT\\pazocal{T}\\! is input/output unambiguous (I/O-unambiguous for short) if for every wâˆˆÎ£<*>ğ‘¤superscriptÎ£<*>w\\in\\Sigma^{\\texttt{<*>}} and every Î¼âˆˆâŸ¦TâŸ§(w)\\mu\\in\\llbracket\\pazocal{T}\\!\\mkern 1.0mu\\rrbracket(w) there is exactly one accepting run ÏğœŒ\\rho of TT\\pazocal{T}\\! over wğ‘¤w such that Î¼=outâ€‹(Ï)ğœ‡outğœŒ\\mu=\\textsf{out}(\\rho).\nNotice that an I/O-deterministic is also I/O-unambiguous and in both models for each output there exists at most one run. The definition of I/O-deterministic is in line with the notion of I/O-deterministic variable automata ofÂ  and I/O-unambiguous is a generalization of this idea that is enough for the purpose of our enumeration algorithm. One can show that for every TT\\pazocal{T}\\! there exists an equivalent I/O-deterministic and, therefore, an equivalent I/O-unambiguous . For every TT\\pazocal{T}\\! there exists an I/O-deterministic Tâ€²superscriptTâ€²\\pazocal{T}\\!^{\\prime} of size Oâ€‹(2|Q|2â€‹|Î“|)Osuperscript2superscriptQ2Î“\\pazocal{O}(2^{|Q|^{2}|\\Gamma|}) such that âŸ¦TâŸ§(w)=âŸ¦Tâ€²âŸ§(w)\\llbracket\\pazocal{T}\\!\\mkern 1.0mu\\rrbracket(w)=\\llbracket\\pazocal{T}\\!^{\\prime}\\mkern 1.0mu\\rrbracket(w) for every wâˆˆÎ£<*>ğ‘¤superscriptÎ£<*>w\\in\\Sigma^{\\texttt{<*>}}. In this paper, we are interested on the following streaming enumeration problem for . Let CC\\pazocal{C} be a class of (e.g. I/O-deterministic ). \n\n\n\nProblem:\nEnumVPTâ€‹[C]EnumVPTdelimited-[]C\\textsc{EnumVPT}[\\pazocal{C}]\n\n\n\nInput:\na TâˆˆCTC\\pazocal{T}\\!\\in\\pazocal{C} and wâˆˆÎ£<*>ğ‘¤superscriptÎ£<*>w\\in\\Sigma^{\\texttt{<*>}}\n\nOutput:\nEnumerate âŸ¦TâŸ§(w)\\llbracket\\pazocal{T}\\!\\mkern 1.0mu\\rrbracket(w)\n\n\n The main result of the paper is that for the class of I/O-unambiguous , the streaming full-enumeration version of this problem can be solved efficiently. The streaming full-enumeration problem of EnumVPT for the class of I/O-unambiguous can be solved with update-time Oâ€‹(|Q|2â€‹|Î”|)OsuperscriptQ2Î”\\pazocal{O}(|Q|^{2}|\\Delta|) and output-linear delay. For the general class of , it can be solved with update-time Oâ€‹(2|Q|2â€‹|Î”|)Osuperscript2superscriptQ2Î”\\pazocal{O}(2^{|Q|^{2}|\\Delta|}) and output-linear delay. The result for the class of all is a consequence of LemmaÂ 4.2 and the enumeration algorithm for I/O-unambiguous (see SectionÂ 5 andÂ 6). For both cases, if the is fixed (i.e., in data complexity), then the update-time of the streaming algorithm is constant. For the streaming version of EnumVPT, one can have Î”Î”\\Delta-enumeration with a small loss of efficiency by solving the full-enumeration problem. Specifically, one can show that for any I/O-unambiguous TT\\pazocal{T}\\! there is an I/O-unambiguous Tâ€²superscriptTâ€²\\pazocal{T}\\!^{\\prime} of linear size with respect to |T|T|\\pazocal{T}\\!| such that âŸ¦Tâ€²âŸ§(w)=âŸ¦TâŸ§(w)âˆ–â‹ƒ{âŸ¦TâŸ§(w[1,i])âˆ£i<|w|,w[1,i]âˆˆÎ£<*>}\\llbracket\\pazocal{T}\\!^{\\prime}\\mkern 1.0mu\\rrbracket(w)=\\llbracket\\pazocal{T}\\!\\mkern 1.0mu\\rrbracket(w)\\setminus\\bigcup\\,\\{\\llbracket\\pazocal{T}\\!\\mkern 1.0mu\\rrbracket(w[1,i])\\mid i<|w|,w[1,i]\\in\\Sigma^{\\texttt{<*>}}\\} for each wâˆˆÎ£<*>ğ‘¤superscriptÎ£<*>w\\in\\Sigma^{\\texttt{<*>}}. The streaming Î”Î”\\Delta-enumeration problem of EnumVPT for the class of I/O-unambiguous can be solved with update-time Oâ€‹(|Q|2â€‹|Î”|)OsuperscriptQ2Î”\\pazocal{O}(|Q|^{2}|\\Delta|) and output-linear delay. For the general class of , it can be solved with update-time Oâ€‹(2|Q|2â€‹|Î”|)Osuperscript2superscriptQ2Î”\\pazocal{O}(2^{|Q|^{2}|\\Delta|}) and output-linear delay. We could have considered a more general definition of VPT to produce outputs for prefix-nested words. This would be desirable for having some sort of earliest query answeringÂ  which is important in practical scenarios. We remark that the algorithm of TheoremÂ 4.3 can be extended for this case at the cost of making the presentation more complicated. For the sake of presentation, we defer this extension to the full version of this paper. Space lower bounds of evaluating a .\nThis subsection deals with the space used by the streaming evaluation algorithm of TheoremÂ 4.3.\nIndeed, this algorithm could use linear space in the worst case. In the following we explore some lower bounds in the space needed by any algorithm, and show that this bound is tight for a certain type of . To study the minimum number of bits needed to solve EnumVPT we need to introduce some definitions.\nFix a TT\\pazocal{T}\\! and wâˆˆprefixâ€‹(Î£<*>)ğ‘¤prefixsuperscriptÎ£<*>w\\in\\textsf{prefix}(\\Sigma^{\\texttt{<*>}}). Let\nğ—ˆğ—ğ—ğ—‰ğ—ğ—ğ—ğ–¾ğ—‚ğ—€ğ—ğ—â€‹(T,w)ğ—ˆğ—ğ—ğ—‰ğ—ğ—ğ—ğ–¾ğ—‚ğ—€ğ—ğ—Tw\\mathsf{outputweight}(\\pazocal{T}\\!,w) be the number of positions less than |w|ğ‘¤|w| that appear in some output of âŸ¦TâŸ§(wâ‹…wâ€²)\\llbracket\\pazocal{T}\\!\\mkern 1.0mu\\rrbracket(w\\cdot w^{\\prime}) for some wâ‹…wâ€²âˆˆÎ£<*>â‹…ğ‘¤superscriptğ‘¤â€²superscriptÎ£<*>w\\cdot w^{\\prime}\\in\\Sigma^{\\texttt{<*>}}.\nFurthermore, for a well-nested word uğ‘¢u let 0â€‹pâ€‹tâ€‹(u)0ğ‘ğ‘¡ğ‘¢0pt(u) be the maximum number of nesting pairs inside uğ‘¢u, formally, 0â€‹pâ€‹tâ€‹(a)=00ğ‘ğ‘¡ğ‘00pt(a)=0 for aâˆˆÎ£|âˆª{Îµ}ğ‘superscriptÎ£|ğœ€a\\in\\Sigma^{\\texttt{|}}\\cup\\{\\varepsilon\\}, 0â€‹pâ€‹tâ€‹(u1â‹…u2)=maxâ¡{0â€‹pâ€‹tâ€‹(u1),0â€‹pâ€‹tâ€‹(u2)}0ğ‘ğ‘¡â‹…subscriptğ‘¢1subscriptğ‘¢20ğ‘ğ‘¡subscriptğ‘¢10ğ‘ğ‘¡subscriptğ‘¢20pt(u_{1}\\cdot u_{2})=\\max\\{0pt(u_{1}),0pt(u_{2})\\}, and 0â€‹pâ€‹tâ€‹(<â€‹aâ‹…uâ‹…bâ€‹>)=0â€‹pâ€‹tâ€‹(u)+10ğ‘ğ‘¡â‹…<ğ‘ğ‘¢ğ‘>0ğ‘ğ‘¡ğ‘¢10pt({\\scriptsize\\texttt{<}}a\\cdot u\\cdot b{\\scriptsize\\texttt{>}})=0pt(u)+1. For wâˆˆprefixâ€‹(Î£<*>)ğ‘¤prefixsuperscriptÎ£<*>w\\in\\textsf{prefix}(\\Sigma^{\\texttt{<*>}}), we define 0â€‹pâ€‹tâ€‹(w)=minâ¡{0â€‹pâ€‹tâ€‹(wâ€²)âˆ£wâ€‹Â is a prefix ofÂ â€‹wâ€²}0ğ‘ğ‘¡ğ‘¤conditional0ğ‘ğ‘¡superscriptğ‘¤â€²ğ‘¤Â is a prefix ofÂ superscriptğ‘¤â€²0pt(w)=\\min\\{0pt(w^{\\prime})\\mid w\\text{ is a prefix of }w^{\\prime}\\}.\nWe can now state some worst-case space lower bounds for EnumVPT. There exists a TT\\pazocal{T}\\! such that every streaming evaluation algorithm for EnumVPT with input TT\\pazocal{T}\\! and SS\\pazocal{S} requires at least Î©â€‹(0â€‹pâ€‹tâ€‹(Sâ€‹[1,n]))Î©0ğ‘ğ‘¡S1n\\Omega(0pt(\\pazocal{S}[1,n])) bits of space. There exists a TT\\pazocal{T}\\! such that every streaming evaluation algorithm for EnumVPT with input TT\\pazocal{T}\\! and SS\\pazocal{S} requires at least Î©â€‹(ğ—ˆğ—ğ—ğ—‰ğ—ğ—ğ—ğ–¾ğ—‚ğ—€ğ—ğ—â€‹(T,Sâ€‹[1,n]))Î©ğ—ˆğ—ğ—ğ—‰ğ—ğ—ğ—ğ–¾ğ—‚ğ—€ğ—ğ—TS1n\\Omega(\\mathsf{outputweight}(\\pazocal{T}\\!,\\pazocal{S}[1,n])) bits of space. InÂ  , the authors provide lower bounds on the amount of space needed for evaluating XPath in terms of the nesting and the concurrency (seeÂ  for a definition).\nOne can show that the output weight of TT\\pazocal{T}\\! and wğ‘¤w is always above the concurrency of TT\\pazocal{T}\\! and wğ‘¤w. Despite this, one can check that both notions coincide for the space lower bound given in PropositionÂ 4.5. The previous results show that, in the worst case, any streaming evaluation algorithm for VPT will require space of at least the depth of the document or the output weight.\nTo show that TheoremÂ 4.3 is optimal in the worst-case, we need to consider a further assumption of our . We say that a TT\\pazocal{T}\\! is trimmedÂ  if for every wâˆˆprefixâ€‹(Î£<*>)ğ‘¤prefixsuperscriptÎ£<*>w\\in\\textsf{prefix}(\\Sigma^{\\texttt{<*>}}) and every (partial) run ÏğœŒ\\rho of TT\\pazocal{T}\\! over wğ‘¤w, there exists wâ€²superscriptğ‘¤â€²w^{\\prime} and an accepting run Ïâ€²superscriptğœŒâ€²\\rho^{\\prime} of TT\\pazocal{T}\\! over wâ‹…wâ€²â‹…ğ‘¤superscriptğ‘¤â€²w\\cdot w^{\\prime} such that ÏğœŒ\\rho is a prefix of Ïâ€²superscriptğœŒâ€²\\rho^{\\prime}.\nThis notion is the analog of trimmed non-deterministic automata. Similarly to LemmaÂ 4.2, one can show that for every TT\\pazocal{T}\\! there exists a trimmed I/O-deterministic Tâ€²superscriptTâ€²\\pazocal{T}\\!^{\\prime} equivalent to TT\\pazocal{T}\\! (i.e., by extending the construction inÂ  to VPT).\nThe next result shows that, if the input to EnumVPT is a trimmed I/O-unambiguous , then the memory footprint is at most the maximum between the depth and output weight of the input. The streaming enumeration problem of EnumVPTÂ for the class of trimmed I/O-unambiguous can be solved with update-time Oâ€‹(|Q|2â€‹|Î”|)OsuperscriptQ2Î”\\pazocal{O}(|Q|^{2}|\\Delta|), output-linear delay and Oâ€‹(maxâ¡{0â€‹pâ€‹tâ€‹(Sâ€‹[1,n]),ğ—ˆğ—ğ—ğ—‰ğ—ğ—ğ—ğ–¾ğ—‚ğ—€ğ—ğ—â€‹(T,Sâ€‹[1,n])}Ã—|Q|2â€‹|Î”|)O0ptS1nğ—ˆğ—ğ—ğ—‰ğ—ğ—ğ—ğ–¾ğ—‚ğ—€ğ—ğ—TS1nsuperscriptQ2Î”\\pazocal{O}(\\max\\{0pt(\\pazocal{S}[1,n]),\\mathsf{outputweight}(\\pazocal{T}\\!,\\pazocal{S}[1,n])\\}\\times|Q|^{2}|\\Delta|) space for every stream SS\\pazocal{S}. Unfortunately, the algorithm provided in TheoremÂ 4.3 is not instance optimal, in the sense of using the lowest number of bits needed for each specific (see the appendix).\nNote that an instance optimal algorithm for the streaming enumeration problem of VPT will imply a solution to the weak evaluation problem, stated by Segoufin and VianuÂ 2. This is an open problem in the area (see  for some recent results), so we leave this for future work."
  },
  "reference_labels": [
    {
      "index": 0,
      "title": "The Design and Analysis of Computer Algorithms",
      "abstract": "",
      "year": "1974",
      "venue": "Addison-Wesley",
      "authors": "Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ullman"
    },
    {
      "index": 1,
      "title": "Compilers, principles, techniques",
      "abstract": "",
      "year": "1986",
      "venue": "Addison wesley",
      "authors": "Alfred V Aho, Ravi Sethi, and Jeffrey D Ullman"
    },
    {
      "index": 2,
      "title": "Efficient filtering of XML documents for selective dissemination of information",
      "abstract": "",
      "year": "2000",
      "venue": "VLDB",
      "authors": "Mehmet AltÄ±nel and Michael J Franklin"
    },
    {
      "index": 3,
      "title": "Streamable regular transductions",
      "abstract": "",
      "year": "2020",
      "venue": "Theor. Comput. Sci.",
      "authors": "Rajeev Alur, Dana Fisman, Konstantinos Mamouras, Mukund Raghothaman, and Caleb Stanford"
    },
    {
      "index": 4,
      "title": "Invisible pushdown languages",
      "abstract": "",
      "year": "2004",
      "venue": "STOC",
      "authors": "Rajeev Alur and P. Madhusudan",
      "orig_title": "Visibly pushdown languages",
      "paper_id": "1511.00289v1"
    },
    {
      "index": 5,
      "title": "A circuit-based approach to efficient enumeration",
      "abstract": "",
      "year": "2017",
      "venue": "ICALP",
      "authors": "Antoine Amarilli, Pierre Bourhis, Louis Jachiet, and Stefan Mengel"
    },
    {
      "index": 6,
      "title": "Constant-delay enumeration for nondeterministic document spanners",
      "abstract": "",
      "year": "2019",
      "venue": "ICDT",
      "authors": "Antoine Amarilli, Pierre Bourhis, Stefan Mengel, and Matthias Niewerth"
    },
    {
      "index": 7,
      "title": "Enumeration on trees with tractable combined complexity and efficient updates",
      "abstract": "",
      "year": "2019",
      "venue": "PODS",
      "authors": "Antoine Amarilli, Pierre Bourhis, Stefan Mengel, and Matthias Niewerth"
    },
    {
      "index": 8,
      "title": "Efficient logspace classes for enumeration, counting, and uniform generation",
      "abstract": "",
      "year": "2019",
      "venue": "PODS",
      "authors": "Marcelo Arenas, Luis Alberto Croquevielle, Rajesh Jayaram, and Cristian Riveros"
    },
    {
      "index": 9,
      "title": "Models and issues in data stream systems",
      "abstract": "",
      "year": "2002",
      "venue": "SIGMOD",
      "authors": "Brian Babcock, Shivnath Babu, Mayur Datar, Rajeev Motwani, and Jennifer Widom"
    },
    {
      "index": 10,
      "title": "MSO queries on tree decomposable structures are computable with linear delay",
      "abstract": "",
      "year": "2006",
      "venue": "CSL",
      "authors": "Guillaume Bagan"
    },
    {
      "index": 11,
      "title": "On acyclic conjunctive queries and constant delay enumeration",
      "abstract": "",
      "year": "2007",
      "venue": "CSL",
      "authors": "Guillaume Bagan, Arnaud Durand, and Etienne Grandjean"
    },
    {
      "index": 12,
      "title": "Buffering in query evaluation over XML streams",
      "abstract": "",
      "year": "2005",
      "venue": "PODS",
      "authors": "Ziv Bar-Yossef, Marcus Fontoura, and Vanja Josifovski"
    },
    {
      "index": 13,
      "title": "On the memory requirements of XPath evaluation over XML streams",
      "abstract": "",
      "year": "2007",
      "venue": "J. Comput. Syst. Sci.",
      "authors": "Ziv Bar-Yossef, Marcus Fontoura, and Vanja Josifovski"
    },
    {
      "index": 14,
      "title": "Stackless processing of streamed trees",
      "abstract": "",
      "year": "2021",
      "venue": "PODS",
      "authors": "Corentin Barloy, Filip Murlak, and Charles Paperman"
    },
    {
      "index": 15,
      "title": "Constant delay enumeration for conjunctive queries: a tutorial",
      "abstract": "",
      "year": "2020",
      "venue": "ACM SIGLOG News",
      "authors": "Christoph Berkholz, Fabian Gerhardt, and Nicole Schweikardt"
    },
    {
      "index": 16,
      "title": "Answering conjunctive queries under updates",
      "abstract": "",
      "year": "2017",
      "venue": "PODS",
      "authors": "Christoph Berkholz, Jens Keppeler, and Nicole Schweikardt"
    },
    {
      "index": 17,
      "title": "JSON: Data model and query languages",
      "abstract": "",
      "year": "2020",
      "venue": "Inf. Syst.",
      "authors": "Pierre Bourhis, Juan L. Reutter, and Domagoj Vrgoc"
    },
    {
      "index": 18,
      "title": "Trimming visibly pushdown automata",
      "abstract": "",
      "year": "2015",
      "venue": "Theor. Comput. Sci.",
      "authors": "Mathieu Caralp, Pierre-Alain Reynier, and Jean-Marc Talbot"
    },
    {
      "index": 19,
      "title": "An efficient XPath query processor for XML streams",
      "abstract": "",
      "year": "2006",
      "venue": "ICDE",
      "authors": "Yi Chen, Susan B. Davidson, and Yifeng Zheng"
    },
    {
      "index": 20,
      "title": "Materialized views",
      "abstract": "",
      "year": "2012",
      "venue": "Found. Trends Databases",
      "authors": "Rada Chirkova and Jun Yang"
    },
    {
      "index": 21,
      "title": "Linear delay enumeration and monadic second-order logic",
      "abstract": "",
      "year": "2009",
      "venue": "Discret. Appl. Math.",
      "authors": "Bruno Courcelle"
    },
    {
      "index": 22,
      "title": "Making data structures persistent",
      "abstract": "",
      "year": "1986",
      "venue": "STOC",
      "authors": "James R Driscoll, Neil Sarnak, Daniel Dominic Sleator, and Robert Endre Tarjan"
    },
    {
      "index": 23,
      "title": "First-order queries on structures of bounded degree are computable with constant delay",
      "abstract": "",
      "year": "2007",
      "venue": "ACM Trans. Comput. Log.",
      "authors": "Arnaud Durand and Etienne Grandjean"
    },
    {
      "index": 24,
      "title": "Document spanners: A formal approach to information extraction",
      "abstract": "",
      "year": "2015",
      "venue": "J. ACM",
      "authors": "Ronald Fagin, Benny Kimelfeld, Frederick Reiss, and Stijn Vansummeren"
    },
    {
      "index": 25,
      "title": "Streamability of nested word transductions",
      "abstract": "",
      "year": "2019",
      "venue": "LMCS",
      "authors": "Emmanuel Filiot, Olivier Gauwin, Pierre-Alain Reynier, and FrÃ©dÃ©ric Servais"
    },
    {
      "index": 26,
      "title": "Visibly pushdown transducers",
      "abstract": "",
      "year": "2018",
      "venue": "JCSS",
      "authors": "Emmanuel Filiot, Jean-FranÃ§ois Raskin, Pierre-Alain Reynier, FrÃ©dÃ©ric Servais, and Jean-Marc Talbot"
    },
    {
      "index": 27,
      "title": "Efficient enumeration algorithms for regular document spanners",
      "abstract": "",
      "year": "2020",
      "venue": "TODS",
      "authors": "Fernando Florenzano, Cristian Riveros, MartÃ­n Ugarte, Stijn Vansummeren, and Domagoj Vrgoc"
    },
    {
      "index": 28,
      "title": "A logic for document spanners",
      "abstract": "",
      "year": "2019",
      "venue": "Theory Comput. Syst.",
      "authors": "Dominik D. Freydenberger"
    },
    {
      "index": 29,
      "title": "Joining Extractions of Regular Expressions",
      "abstract": "",
      "year": "2018",
      "venue": "PODS",
      "authors": "Dominik D. Freydenberger, Benny Kimelfeld, and Liat Peterfreund",
      "orig_title": "Joining extractions of regular expressions",
      "paper_id": "1703.10350v1"
    },
    {
      "index": 30,
      "title": "Streaming tree automata",
      "abstract": "",
      "year": "2008",
      "venue": "Inf. Process. Lett.",
      "authors": "Olivier Gauwin, Joachim Niehren, and Yves Roos"
    },
    {
      "index": 31,
      "title": "Bounded delay and concurrency for earliest query answering",
      "abstract": "",
      "year": "2009",
      "venue": "LATA",
      "authors": "Olivier Gauwin, Joachim Niehren, and Sophie Tison"
    },
    {
      "index": 32,
      "title": "Earliest query answering for deterministic nested word automata",
      "abstract": "",
      "year": "2009",
      "venue": "FCT",
      "authors": "Olivier Gauwin, Joachim Niehren, and Sophie Tison"
    },
    {
      "index": 33,
      "title": "Efficient algorithms for evaluating XPath over streams",
      "abstract": "",
      "year": "2007",
      "venue": "SIGMOD",
      "authors": "Gang Gou and Rada Chirkova"
    },
    {
      "index": 34,
      "title": "Processing XML streams with deterministic automata and stream indexes",
      "abstract": "",
      "year": "2004",
      "venue": "ACM Trans. Database Syst.",
      "authors": "Todd J. Green, Ashish Gupta, Gerome Miklau, Makoto Onizuka, and Dan Suciu"
    },
    {
      "index": 35,
      "title": "Towards streaming evaluation of queries with correlation in complex event processing",
      "abstract": "",
      "year": "2020",
      "venue": "ICDT",
      "authors": "Alejandro Grez and Cristian Riveros"
    },
    {
      "index": 36,
      "title": "A formal framework for complex event processing",
      "abstract": "",
      "year": "2019",
      "venue": "ICDT",
      "authors": "Alejandro Grez, Cristian Riveros, and MartÃ­n Ugarte"
    },
    {
      "index": 37,
      "title": "The dynamic Yannakakis algorithm: Compact and efficient query processing under updates",
      "abstract": "",
      "year": "2017",
      "venue": "SIGMOD",
      "authors": "Muhammad Idris, MartÃ­n Ugarte, and Stijn Vansummeren"
    },
    {
      "index": 38,
      "title": "Random generation of combinatorial structures from a uniform distribution",
      "abstract": "",
      "year": "1986",
      "venue": "Theor. Comput. Sci.",
      "authors": "Mark Jerrum, Leslie G. Valiant, and Vijay V. Vazirani"
    },
    {
      "index": 39,
      "title": "Querying XML streams",
      "abstract": "",
      "year": "2005",
      "venue": "VLDB J.",
      "authors": "Vanja Josifovski, Marcus Fontoura, and Attila Barta"
    },
    {
      "index": 40,
      "title": "Trade-offs in Static and Dynamic Evaluation of Hierarchical Queries",
      "abstract": "",
      "year": "2020",
      "venue": "PODS",
      "authors": "Ahmet Kara, Milos Nikolic, Dan Olteanu, and Haozhe Zhang",
      "orig_title": "Trade-offs in static and dynamic evaluation of hierarchical queries",
      "paper_id": "1907.01988v7"
    },
    {
      "index": 41,
      "title": "Visibly pushdown automata for streaming XML",
      "abstract": "",
      "year": "2007",
      "venue": "WWW",
      "authors": "Viraj Kumar, P. Madhusudan, and Mahesh Viswanathan"
    },
    {
      "index": 42,
      "title": "Elements of finite model theory, volume 41",
      "abstract": "",
      "year": "2004",
      "venue": "Springer",
      "authors": "Leonid Libkin"
    },
    {
      "index": 43,
      "title": "Document Spanners for Extracting Incomplete Information: Expressiveness and Complexity",
      "abstract": "",
      "year": "2018",
      "venue": "PODS",
      "authors": "Francisco Maturana, Cristian Riveros, and Domagoj Vrgoc",
      "orig_title": "Document spanners for extracting incomplete information: Expressiveness and complexity",
      "paper_id": "1707.00827v2"
    },
    {
      "index": 44,
      "title": "Incremental view maintenance with triple lock factorization benefits",
      "abstract": "",
      "year": "2018",
      "venue": "SIGMOD",
      "authors": "Milos Nikolic and Dan Olteanu"
    },
    {
      "index": 45,
      "title": "SPEX: Streamed and progressive evaluation of XPath",
      "abstract": "",
      "year": "2007",
      "venue": "IEEE Trans. Knowl. Data Eng.",
      "authors": "Dan Olteanu"
    },
    {
      "index": 46,
      "title": "An efficient single-pass query evaluator for XML data streams",
      "abstract": "",
      "year": "2004",
      "venue": "SAC",
      "authors": "Dan Olteanu, Tim Furche, and FranÃ§ois Bry"
    },
    {
      "index": 47,
      "title": "Size bounds for factorised representations of query results",
      "abstract": "",
      "year": "2015",
      "venue": "ACM TODS",
      "authors": "Dan Olteanu and Jakub ZÃ¡vodnÃ½"
    },
    {
      "index": 48,
      "title": "Grammars for document spanners",
      "abstract": "",
      "year": "2021",
      "venue": "ICDT",
      "authors": "Liat Peterfreund"
    },
    {
      "index": 49,
      "title": "Recursive Programs for Document Spanners",
      "abstract": "",
      "year": "2019",
      "venue": "ICDT",
      "authors": "Liat Peterfreund, Balder ten Cate, Ronald Fagin, and Benny Kimelfeld",
      "orig_title": "Recursive programs for document spanners",
      "paper_id": "1712.08198v3"
    },
    {
      "index": 50,
      "title": "Enumerating with constant delay the answers to a query",
      "abstract": "",
      "year": "2013",
      "venue": "ICDT",
      "authors": "Luc Segoufin"
    },
    {
      "index": 51,
      "title": "Validating streaming XML documents",
      "abstract": "",
      "year": "2002",
      "venue": "PODS",
      "authors": "Luc Segoufin and Victor Vianu"
    },
    {
      "index": 52,
      "title": "The space complexity of processing XML twig queries over indexed documents",
      "abstract": "",
      "year": "2008",
      "venue": "ICDE",
      "authors": "Mirit Shalem and Ziv Bar-Yossef"
    },
    {
      "index": 53,
      "title": "Navigational XPath: calculus and algebra",
      "abstract": "",
      "year": "2007",
      "venue": "SIGMOD Record",
      "authors": "Balder ten Cate and Maarten Marx"
    },
    {
      "index": 54,
      "title": "Aggregate Queries on Sparse Databases",
      "abstract": "",
      "year": "2020",
      "venue": "PODS",
      "authors": "Szymon Torunczyk",
      "orig_title": "Aggregate queries on sparse databases",
      "paper_id": "1912.12338v1"
    }
  ]
}