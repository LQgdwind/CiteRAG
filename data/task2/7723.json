{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: Amortized Analysis via Coalgebra\n\nPaper Abstract: \n\nPaper Section Text:\nTo support a method with two inputs and two outputs, one may naïvely attempt to use so that a Σ-coalgebra D→ΣD is equivalent to a map D⊗D→D⊗D.\nHowever, this definition of Σ is not functorial: X is used in a contravariant position.\nTo remedy this, we will let Σ be an endoprofunctor rather than an endofunctor, taking in both a covariant and a contravariant copies of what will ultimately be X.\nRecall from Section 1.2 that a profunctor C\\ext@arrow0055-- ↦-- →D is a functor Dop×C→Set.\nTo represent an arbitrary signature for an abstract data type, we will use an endoprofunctor Σ:C\\ext@arrow0055-- ↦-- →C in place of an endofunctor.\nFor example, if we let \n\n\n\nΣ(X-,X+)=(X-⊗X-)⊸(X+⊗X+),\n\n\nwe describe a signature that takes in a pair of states and produces a new pair of states.\nWe now recall the definition of a coalgebra for an endoprofunctor, using the bicategorical generalization coalgebra.\n\n\n\nDefinition 3.2.\n\n\nLet Σ be an endoprofunctor.\nA Σ-coalgebra is a pair (D,δ) of a carrier object D:1\\ext@arrow0055-- ↦-- →C and a transition morphism δ:D→Σ∘D .\n\nNote that profunctors 1\\ext@arrow0055-- ↦-- →C are equivalent to presheaves ^C.\nFor cost analysis, we will continue to use C≜Alg(C×(-)).\nCoalgebras for endoprofunctors encompass coalgebras for endofunctors.\n\n\n\nTheorem 3.3.\n\n\nLet Σ:C→C be an arbitrary endofunctor, and define ~Σ:C\\ext@arrow0055-- ↦-- →C by:\n\n\n\n\n~Σ(X-,X+)=X-⊸ΣX+\n\n\nThen, a Σ-coalgebra with carrier X is equivalent to a ~Σ-coalgebra with carrier よX.\n\n\n\nProof 3.4.\n\n\nBy the Yoneda lemma, maps δ:よD→~Σ∘よD are equivalent to elements of ~Σ(D,D).\nBy definition, we have ~Σ(D,D)=D⊸ΣD, precisely the definition of a Σ-coalgebra transition morphism.\n\n\nWhile coalgebras over endofunctors are definable as coalgebras over endoprofunctors, this new environment allows more flexibility in the contravariant position.\nMorphisms of coalgebras over an endoprofunctor generalize morphisms of coalgebras over an endofunctor, as well.\n\n\n\nDefinition 3.5.\n\n\nLet (D,δ) and (S,σ) be Σ-coalgebras, where Σ is an endoprofunctor.\nA morphism of Σ-coalgebras from (D,δ) to (S,σ) consists of a morphism Φ:D→S that preserves the Σ-coalgebra structure, as before:\n\n\n\nDΣ∘DSΣ∘SδσΦΣ∘Φ\n\n\n\nNote that D and S are presheaves in ^C and Φ is a morphism of presheaves.\n\n\nWhen D=よD0 and S=よS0, the situation becomes simpler.\nSince the Yoneda embedding is fully faithful, it is equivalent to give a map Φ:D0→S0.\nBy the Yoneda lemma, the structure preservation requirement can be simplified to the following:\n\n\n\n\n1Σ(D0,D0)Σ(S0,S0)Σ(D0,S0)δΣ(Φ,S0)σΣ(D0,Φ)\n\n\n\nViewing the covariant and contravariant positions as outputs and inputs, respectively, this formalizes of the amortization condition with multiple inputs and outputs.\nWe demonstrate this via a concrete example.\n\n\n\nExample 3.6.\n\n\nDefine endoprofunctor Σ(X-,X+)=(X-⊗X-)⊸(X+⊗X+), representing a method that takes two states of a data structure and provides two new states.\nSuppose (よ(F¯D),δ:Σ(F¯D,F¯D)) and (よ(F1),σ:Σ(F1,F1)) are Σ-coalgebras.\nThen, the above condition simplifies to:\n\n\n\n(Φ(d1)+Φ(d2))+σ$=δ$(d)+(Φ(δ∘(d)1)+Φ(δ∘(d)2))\n\n\n\nwhere d=(d1,d2):¯D×¯D.\nEquivalently, we may write:\n\n\n\n∑i∈{1,2}Φ(di)+σ$=δ$(d)+∑i∈{1,2}Φ(δ∘(d)i)\n\n\n\nUp to our usual movement of the starting potential across the equation, this is precisely the form of the generalized amortization equation given above, using the structure of signature Σ to make precise the informal Input notion.\n\n\nUsing a monoidal product, we allowed multiple states to exist simultaneously, adding any potential they contain.\nThen, using profunctors, we generalized the notion of signature to support arbitrary contravariant data, allowing arbitrarily many inputs and outputs to a method.\n\n\n\n4 Composition of Amortized Data Structures\n\nThus far, we have considered coalgebra morphisms in isolation, each showing that one data structure implementation matches a specification up to amortization.\nUsing the fact that Σ-coalgebras and coalgebra morphisms form a category, we may compose potential functions to support different levels of amortized abstraction.\n\n\n\nExample 4.1.\n\n\nRecall Examples 2.1 and 2.3, where the specification (S,σ) purports to incur $1 of cost every operation while really the implementation (D,δ) incurs $8 of cost every eight operations.\nAlternatively, we may view (D,δ) as the specification, which can be implemented by an even more amortized scheme.\nFor example, we may define a coalgebra (D′,δ′) that incurs $16 of cost every sixteen operations, which is an amortized implementation of (D,δ) via a new potential function Φ′:(D′,δ′)→(D,δ).\nOf course, we may then compose these potential functions,\n\n\n\n(D′,δ′)(D,δ)(S,σ),Φ′Φ\n\n\n\nshowing that (D′,δ′) is an implementation of the original specification (S,σ) after all.\n\n\n\nMore commonly, though, we may wish to compose coalgebras with different signatures, using one amortized data structure to implement another.\nFor example, we may wish to use a pair of stacks, with an amortized implemented in terms of arrays in Example 2.7, to implement a queue, as given in Example 2.8.\nThe coalgebras and morphisms for pairs of stacks and queues exist in different categories, Coalg(Σs×Σs) and Coalg(Σq), where both Σs and Σq are (coincidentally) both the signature from Example 2.7 extended with a method N⋉X for computing the number of elements stored in the data structure.\n\n\nRather than viewing each Coalg(Σ) in isolation, we may think of Coalg(-):Fun(C,C)→Cat as an indexed category whose (covariant) Grothendieck construction\n∫Σ:Fun(C,C)Coalg(Σ)\nis the category with objects (Σ,(D,δ)), where (D,δ) is a Σ-coalgebra.\nIn other words, an object here consists of a signature Σ along with an implementation of that signature.\nA morphism from (Σ′,(D,δ)) to (Σ,(S,σ)) consists of a natural transformation φ:Σ′→Σ translating the operations of Σ to the language of Σ′, along with a Σ-coalgebra morphism from (D,Dδ→Σ′DφD→ΣD) to (S,σ) performing an amortized analysis on the φ-translated implementation.\n\n\n\nExample 4.2.\n\n\nLet Σs be the signature functor from Example 2.7 for stacks, and let ΣcX=X×(F1+X) be the signature of for a counter with successor and predecessor methods.\nLet ¯D be the type of bounded arrays used to implement stacks.\nThe amortized analysis of stacks induces a morphism\n\n\n\n(Σs,(D,δ))→(Σs,(F(list(E)),σ))\n\n\n\nwhose translation component Σs→Σs is the identity.\nSeparately, let (FN,σcounter) be a Σc-coalgebra specification similar to the Σs coalgebra (F(list(E)),σ), keeping the same costs but only storing the number of elements stored rather than the elements themselves.\nWe can give a morphism to (FN,σcounter)\n\n\n\n(Σs,(F(list(E)),σ))→(Σc,(FN,σcounter))\n\n\n\nthat implements counters in terms of stacks of a sentinel value e0:E.\nComposing these morphisms, we get a map\n\n\n\n(Σs,(D,δ))→(Σc,(FN,σcounter))\n\n\n\nthat implements natural number counters in terms of a dynamically resizing array, mixing signatures.\n\n\n\nTo implement an amortized queue as a pair of amortized stacks, we must first be able to pair two coalgebras.\nFortunately, when restricted to signature functors equipped with a tensorial strength (which includes all signatures considered in this work), the indexed category Coalg(-) is lax monoidal.\n\n\n\nTheorem 4.3.\n\n\nLet C be a symmetric monoidal category.\nThen, Coalg(-):Strong(C,C)→Cat is a lax monoidal pseudofunctor.\n\n\n\nSo, if (Ss,σs):Coalg(Σs) is the specification coalgebra for stacks,\nthen (Ss,σs)⊗(Ss,σs):Coalg(Σs×Σs)\nis the compound specification for a pair of stacks.\nWe may hope, then, to give a morphism\n\n\n\n(Σs×Σs,(Ss,σs)⊗(Ss,σs))→(Σq,(Sq,σq))\n\n\n\nimplementing amortized queues in terms of a pair of stacks.\nThe translation morphism Σs×Σs→Σq would have to describe each queue operation in terms of a stack operation.\nHowever, implementing a queue operation may require more than one stack operation, popping all of the elements of the “inbox” stack in the case the “outbox” stack is empty.\nTo allow each queue operation to perform arbitrarily many stack operations, we instead treat Coalg(-) as category indexed in the coKleisli category of the cofree comonad comonad.\nIn the fibered category\n∫Σ:coKl(CofreeC)Coalg(Σ),\nthe objects are the same as before, but the signature translation of a morphism from (Σ′,(D,δ)) to (Σ,(S,σ)) now uses the cofree comonad on Σ′ in its domain, φ:Cofree(Σ′)→Σ, translating the operations of Σ to arbitrarily many Σ′ operations.\nThis approach is the formal dual of recent work by Grodin and Spivak  about algebraic effect handlers; in this sense, a translation morphism can be viewed as a “coalgebraic coeffect cohandler”.\n\n\n\nExample 4.4.\n\n\nIn this category, we may implement a morphism\n\n\n\n(Σs×Σs,(Ss,σs)⊗(Ss,σs))→(Σq,(Sq,σq)),\n\n\n\nusing amortized stacks to implement amortized queues.\nThe translation morphsm Σs×Σs→Σq is analogous to the behavior of the implementation coalgebra in Example 2.8 but generic in stack implementation, and the coalgebra morphism is precisely as in Example 2.8.\nPre-composing this with the morphism from Example 2.7, we implement the queue specification via a pair of stacks up to amortization, which in turn are implemented as arrays up to amortization.\n\n\n\nThe techniques considered here generalize to mixed-variance signatures given by profunctors, as well, treating Coalg(-):Prof(C,C)→Cat as a category indexed by endoprofunctors.\n\n\n\n5 Lax Amortized Analysis in a Bicategory\n\nIn some cases, such as those considered thus far, amortized analysis is precise, where the specification exactly matches the amount of cost used by the implementation.\nHowever, it is common for the specified cost to be an upper bound, since some cases may be cheaper than specified due to internal factors that would be difficult to communicate via a concise specification.\nIn the literature, the equation\n\n\n\nσ$=δ$(d)+Φ(δ∘(d))-Φ(d)\n\n\n\nis used to specify the amortized cost σ$, which is then given an upper bound.\nSince we treat (S,σ) as a specification implementation, though, we find it cleaner to treat σ as the upper bound itself, turning the above equation into the inequality\n\n\n\nσ$≥δ$(d)+Φ(δ∘(d))-Φ(d).\n\n\n\nTo achieve this categorically, we augment our development slightly: rather than using coalgebras and morphisms for an endo(pro)functor on a category, we consider colax coalgebras and morphisms for a endo-2-(pro)functor on a bicategory.\nThe 2-cells of the bicategory will serve as inequalities for the purpose of cost analysis, drawing inspiration from Grodin et al. .\n\n\nFirst, we generalize the story about coalgebras of endofunctors, and then we discuss endoprofunctors.\nFixing a bicategory C, let Σ:C→C be an endo-2-functor.\nThis definition of Σ-coalgebra does not materially change, aside from the fact that Σ is a 2-functor.\nHowever, the definition of morphism between Σ-coalgebras will be affected: rather than considering coalgebra morphisms where the given square commutes exactly, we only ask for the square to commute colaxly according to a given 2-cell.\n\n\n\nDefinition 5.1.\n\n\nLet (D,δ) and (S,σ) be Σ-coalgebras.\nA colax morphism of Σ-coalgebras    from (D,δ) to (S,σ) consists of a morphism Φ:D→S that colaxly preserves the Σ-coalgebra structure:\n\n\n\nDΣDSΣSδσΦΣΦ¯Φ\n\n\n\nHere, ¯Φ is a 2-cell Φ;σ⇐δ;ΣΦ, serving as a proof of inequality.\nWe refer to ¯Φ as the lax generalized amortization condition.\n\n\n\nFor amortized analysis, we will typically find ourselves using a 2-poset, a bicategory whose 2-cells are mere propositions.\nIn this case, the 2-cell of a morphism is simply a proof that Φ;σ≥δ;ΣΦ.\nConcretely, we will choose C=Poset.\nFollowing Grodin et al. , we will use discrete posets everywhere except for the cost parameter on the writer monad, which will be the natural numbers equipped with the usual increasing ordering, written ω.\n\n\n\nExample 5.2.\n\n\nLet (F¯D,δ) and (F1,σ) be Id-coalgebras.\nThen, a colax morphism from (F¯D,δ) to (F1,σ) consists of a map Φ:¯D→ω and a 2-cell\n\n\n\nΦ;σ≥δ;ΣΦ\n\n\n\ndemonstrating that Φ satisfies the lax generalized amortization condition.\nIn this case, the inequality condition exactly requires that\n\n\n\nΦ(d)+σ$≥δ$(d)+Φ(δ∘(d)),\n\n\n\nmatching the traditional amortization condition.\n\n\n\n\nRemark 5.3.\n\n\nΣ-coalgebras and their colax morphisms form a bicategory, where a 2-cell from (Φ,¯Φ) to (Φ′,¯Φ′) is a 2-cell Φ⇒Φ′ in C along with a coherence condition on ¯Φ and ¯Φ′ .\nIn the restricted case of 2-posets, the coherence condition is trivialized.\nThen, a 2-cell Φ≤Φ′ justifies that Φ expresses the amortization argument with at most as much overhead as Φ′.\nFor instance, in Example 5.2, if Φ is a colax morphism, then so is Φ′(d)=Φ(d)+$c for any c:ω, using the commutativity of addition in ω.\nThen, Φ≤Φ′, since Φ′ unnecessarily adds $c cost.\n\n\n\nThe advantages and generalizations from the 1-categorical development translate immediately to the 2-categorical setting.\nFor example, the specification carrier can be altered to expose some state, and the monad can be varied to amortize other effects.\n\n\n\nExample 5.4.\n\n\nExtending Example 2.8, a double-ended queue (or “deque”) data structure can also be implemented by a pair of lists; when an element is meant to be removed from an empty inbox or outbox list, the other list is split in half and shared between the two lists, though the amortized cost is treated as constant.\nDepending on whether there are an even or odd number of elements to split, the amortized cost bound will be either less than or equal to the specified cost, making use of the lax generalized amortization condition.\n\n\n\nFor bicategories C and D, a 2-profunctor Σ:C\\ext@arrow0055-- ↦-- →D is a 2-functor Dop×C→Cat.\nThis definition of Σ-coalgebra does not materially change, aside from the fact that Σ is a 2-functor.\nAs with endo-2-functors, though, the definition of morphism between Σ-coalgebras is modified to only require that the given square commutes colaxly.\n\n\n\nDefinition 5.5.\n\n\nLet (D,δ) and (S,σ) be Σ-coalgebras, where Σ is an endo-2-profunctor.\nA morphism of Σ-coalgebras from (D,δ) to (S,σ) consists of a morphism Φ:D→S that preserves the Σ-coalgebra structure, as before:\n\n\n\nDΣ∘DSΣ∘SδσΦΣ∘Φ¯Φ\n\n\nHere, ¯Φ is a 2-cell Φ;σ⇐δ;Σ∘Φ, serving as a proof of inequality.\nNote that D and S are Cat-valued presheaves.\n\n\nAs in Section 3, when D=よD0 and S=よS0, the situation becomes simpler.\nThe structure preservation requirement can be simplified to the following:\n\n\n\n\n1Σ(D0,D0)Σ(S0,S0)Σ(D0,S0)δΣ(Φ,S0)σΣ(D0,Φ)¯Φ\n\n\nThis condition is the lax generalized amortization condition in the setting of multiple inputs and outputs.\nThe discussion of composition from Section 4 generalizes to the bicategorical setting, where we treat Coalg(-):Strong(C,C)→2Cat as an indexed bicategory.\n\n\n\n6 Conclusion\n\nIn this work, we observed that the condition imposed on a potential function in amortized analysis is generalized by the commutativity condition for a coalgebra in the category of writer monad algebras.\nUsing this perspective, we gave simple, clear accounts of examples, and we generalized amortized analysis to other effectful settings.\nWe expanded this definition to include branching amortization given a commutative cost model using profunctors, and we investigated the composition of amortized data structures via the indexed category of coalgebras.\nFinally, we observed that this development makes sense in a bicategory, where colax coalgebra morphisms give a more relaxed and practically useful definition of amortization.\nThe examples presented have been partially mechanized inside calf   in the Agda proof assistant.\n\n\n\n6.1 Related Work\n\nThis development principally expands upon the early work of Grodin and Harper [ref]8, which first proposed to use coalgebraic techniques to reason about amortized analysis.\nAmortized analysis was first characterized by Tarjan 4, providing a technique for describing the cost of data structure operations that takes into account the evolving state of the data structure and considers cost in aggregate, in contrast with algorithmic worst-case upper bounds on a per-operation basis.\nRepresenting abstract data types as coalgebras and simulations as coalgebra morphisms has been well studied; see, e.g., Jacobs   for an overview.\nFormalization of cost analysis using a writer monad has been studied extensively; see Niu et al.  for a comprehensive review of the literature.\nMechanizations of amortized cost analysis has also been pursued, but in the traditional algebraic form 1 7 .\n\n\n\n\n6.2 Future Work\n\nThe carriers of all endofunctor coalgebras considered are free algebras of the form FA, and the carriers of all endoprofunctor coalgebras considered are Yoneda-embedded free algebras of the form よ(FA).\nWe hope to investigate whether this restricted format is sufficient for practical use cases; if so, we may choose to consider only full subcategories of the category of coalgebras over a signature whose carriers are of the forms given above.\n\n\nIn the present work, we consider coalgebras in a category of algebras.\nThis construction appears in a more balanced manner in the development of mathematical operational semantics, there called a bialgebra, representing a transition system in the style of operational semantics.\nWe leave it to future investigation to understand the connections between amortized analysis and operational semantics.\n\n\nWhile we view amortized analysis as a simulation, i.e. a morphism of coalgebras, we suspect that a double categorical approach may be valuable for understanding a symmetric generalization more akin to bisimulation.\nCospans of coalgebras have been used to generalize bisimulations 3, which can serve as vertical morphisms to add to the bicategory of colax coalgebras.\nAdditionally, Goncharov et al.  propose a double category of (co)lax coalgebras of a lax-double functor, generalizing from a fundamentally double categorical perspective.\n\n\nIn our formalization within calf, the notion of coalgebra morphism is defined explicitly, in contrast with the notion of cost algebra that is built in as a primitive.\nWe hope to incorporate coalgebras and coalgebra morphisms more fundamentally, allowing amortized analysis to be more seamless within the language rather than embedded.\n\n\n\nAcknowledgements\n\nThe authors wish to thank Max New, Yue Niu, and David Spivak for insightful conversations that directly impacted the direction of this work and Zachary Battleman, Runming Li, Parth Shastri, and Jonathan Sterling for fruitful adjacent collaboration that contributed broader inspiration.\nThis material is based upon work supported by the United States Air Force Office of Scientific Research under grant number FA9550-21-0009 (Tristan Nguyen, program manager) and the National Science Foundation under grant number CCF-1901381. Any opinions, findings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the AFOSR or NSF.\n\n\nReferences\n\n\n\n\nBenton, P. N., A mixed linear and non-linear logic: Proofs, terms and\nmodels, in: L. Pacholski and J. Tiuryn, editors, Computer Science\nLogic, Lecture Notes in Computer Science, pages 121–135,\nSpringer, Berlin, Heidelberg (1995), ISBN 978-3-540-49404-1.\n\n https://doi.org/10.1007/BFb0022251\n\n\n\n\n\nBlackwell, R., G. M. Kelly and A. J. Power, Two-dimensional monad\ntheory, Journal of Pure and Applied Algebra 59, pages 1–41 (1989),\nISSN 0022-4049.\n\n https://doi.org/10.1016/0022-4049(89)90160-6\n\n\n\n\n\nBurton, F. W., An efficient functional implementation of FIFO\nqueues, Information Processing Letters 14, pages 205–206 (1982),\nISSN 0020-0190.\n\n https://doi.org/10.1016/0020-0190(82)90015-1\n\n\n\n\n\nEgger, J., R. E. Møgelberg and A. Simpson, Enriching an Effect\nCalculus with Linear Types, in: E. Grädel and R. Kahle, editors,\nComputer Science Logic, Lecture Notes in Computer Science,\npages 240–254, Springer, Berlin, Heidelberg (2009), ISBN 978-3-642-04027-6.\n\n https://doi.org/10.1007/978-3-642-04027-6_19\n\n\n\n\n\nEgger, J., R. E. Møgelberg and A. Simpson, The enriched effect\ncalculus: Syntax and semantics, Journal of Logic and Computation\n24, pages 615–654 (2014), ISSN 1465-363X.\n\n https://doi.org/10.1093/logcom/exs025\n\n\n\n\n\nGoncharov, S., D. Hofmann, P. Nora, L. Schröder and P. Wild,\nKantorovich Functors and Characteristic Logics for\nBehavioural Distances (2022). 2202.07069.\n\n http://arxiv.org/abs/2202.07069\n\n\n\n\n\nGries, D., The Science of Programming, Springer New York (1989),\nISBN 978-0-387-96480-5.\n\n\n\n\n[ref]8\n\nGrodin, H. and R. Harper, Amortized Analysis via Coinduction,\nin: P. Baldan and V. de Paiva, editors, 10th Conference on\nAlgebra and Coalgebra in Computer Science (CALCO 2023),\nvolume 270 of Leibniz International Proceedings in Informatics\n(LIPIcs), pages 23:1–23:6, Schloss Dagstuhl – Leibniz-Zentrum für\nInformatik, Dagstuhl, Germany (2023), ISBN 978-3-95977-287-7, ISSN 1868-8969.\n\n https://doi.org/10.4230/LIPIcs.CALCO.2023.23\n\n\n\n\n\nGrodin, H., Y. Niu, J. Sterling and R. Harper, Decalf: A Directed,\nEffectful Cost-Aware Logical Framework, Proceedings of the ACM on\nProgramming Languages 8, pages 10:273–10:301 (2024).\n\n https://doi.org/10.1145/3632852\n\n\n\n\n\nGrodin, H. and D. Spivak, Poly-morphic effect handlers (2024).\n\n https://topos.site/blog/2024/01/poly-morphic-effect-handlers/\n\n\n\n1\n\nHood, R. and R. Melville, Real-time queue operations in pure LISP,\nInformation Processing Letters 13, pages 50–54 (1981), ISSN\n0020-0190.\n\n https://doi.org/10.1016/0020-0190(81)90030-2\n\n\n\n\n\nJacobs, B., Objects And Classes, Co-Algebraically, in:\nB. Freitag, C. B. Jones, C. Lengauer and H.-J. Schek, editors, Object\nOrientation with Parallelism and Persistence, The Kluwer\nInternational Series in Engineering and Computer Science, pages\n83–103, Springer US, Boston, MA (1996), ISBN 978-1-4613-1437-0.\n\n https://doi.org/10.1007/978-1-4613-1437-0_5\n\n\n\n\n\nJacobs, B., Introduction to Coalgebra, Cambridge University Press\n(2017), ISBN 978-1-107-17789-5.\n\n\n\n\n\n\nLack, S., Limits for Lax Morphisms, Applied Categorical Structures\n13, pages 189–203 (2005), ISSN 1572-9095.\n\n https://doi.org/10.1007/s10485-005-2958-5\n\n\n\n\n\nLack, S. and M. Shulman, Enhanced 2-categories and limits for lax\nmorphisms, Advances in Mathematics 229, pages 294–356 (2012), ISSN\n0001-8708.\n\n https://doi.org/10.1016/j.aim.2011.08.014\n\n\n\n6\n\nLevy, P. B., Call-By-Push-Value: A Functional/Imperative\nSynthesis, Springer Netherlands, Dordrecht (2003), ISBN 978-94-010-3752-5\n978-94-007-0954-6.\n\n https://doi.org/10.1007/978-94-007-0954-6\n\n\n\n7\n\nNipkow, T. and H. Brinkop, Amortized Complexity Verified, Journal of\nAutomated Reasoning 62, pages 367–391 (2019), ISSN 1573-0670.\n\n https://doi.org/10.1007/s10817-018-9459-3\n\n\n\n\n\nNiu, Y., J. Sterling, H. Grodin and R. Harper, A Cost-Aware Logical\nFramework, Proceedings of the ACM on Programming Languages 6,\npages 9:1–9:31 (2022).\n\n https://doi.org/10.1145/3498670\n\n\n\n\n\nnLab authors, algebra for a profunctor,\nhttps://ncatlab.org/nlab/show/algebra+for+a+profunctor (2024).\nRevision\n11.\n\n\n\n\n0\n\nOkasaki, C., Purely Functional Data Structures, Cambridge University\nPress (1999), ISBN 978-0-521-66350-2.\n\n\n\n\n1\n\nPlotkin, G. and J. Power, Tensors of Comodels and Models for\nOperational Semantics, Electronic Notes in Theoretical Computer Science\n218, pages 295–311 (2008), ISSN 1571-0661.\n\n https://doi.org/10.1016/j.entcs.2008.10.018\n\n\n\n2\n\nSleator, D. D. and R. E. Tarjan, Self-adjusting binary search trees,\nJournal of the ACM 32, pages 652–686 (1985), ISSN 0004-5411.\n\n https://doi.org/10.1145/3828.3835\n\n\n\n3\n\nStaton, S., Relating coalgebraic notions of bisimulation, Logical\nMethods in Computer Science Volume 7, Issue 1, page 670 (2011), ISSN\n1860-5974. 1101.4223.\n\n https://doi.org/10.2168/LMCS-7(1:13)2011\n\n\n\n4\n\nTarjan, R. E., Amortized Computational Complexity, SIAM Journal on\nAlgebraic Discrete Methods 6, pages 306–318 (1985), ISSN 0196-5212.\n\n https://doi.org/10.1137/0606031\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n By the Yoneda lemma, maps δ:よD→~Σ∘よD are equivalent to elements of ~Σ(D,D).\nBy definition, we have ~Σ(D,D)=D⊸ΣD, precisely the definition of a Σ-coalgebra transition morphism. Let (D,δ) and (S,σ) be Σ-coalgebras, where Σ is an endoprofunctor.\nA morphism of Σ-coalgebras from (D,δ) to (S,σ) consists of a morphism Φ:D→S that preserves the Σ-coalgebra structure, as before: Note that D and S are presheaves in ^C and Φ is a morphism of presheaves. Define endoprofunctor Σ(X-,X+)=(X-⊗X-)⊸(X+⊗X+), representing a method that takes two states of a data structure and provides two new states.\nSuppose (よ(F¯D),δ:Σ(F¯D,F¯D)) and (よ(F1),σ:Σ(F1,F1)) are Σ-coalgebras.\nThen, the above condition simplifies to: where d=(d1,d2):¯D×¯D.\nEquivalently, we may write: Up to our usual movement of the starting potential across the equation, this is precisely the form of the generalized amortization equation given above, using the structure of signature Σ to make precise the informal Input notion.\n\nReference markers found: [8]\n\nContext windows for each [ref]:\n[ref]8: examples presented have been partially mechanized inside calf   in the Agda proof assistant.\n\n\n\n6.1 Related Work\n\nThis development principally expands upon the early work of Grodin and Harper [ref]8, which first proposed to use coalgebraic techniques to reason about amortized analysis.\nAmortized analysis was first characterized by Tarjan 4, providing a technique for describing the cost of\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 8,\n            \"titles\": [\n                \"Decalf: A Directed, Effectful Cost-Aware Logical Framework\",\n                \"A mixed linear and non-linear logic: Proofs, terms and models\",\n                \"Two-dimensional monad theory\",\n                \"An efficient functional implementation of FIFO queues\",\n                \"Enriching an Effect Calculus with Linear Types\",\n                \"The enriched effect calculus: Syntax and semantics\",\n                \"Kantorovich Functors and Characteristic Logics for Behavioural Distances\",\n                \"The Science of Programming\",\n                \"Amortized Analysis via Coinduction\",\n                \"Poly-morphic effect handlers\",\n                \"Real-time queue operations in pure LISP\",\n                \"Objects And Classes, Co-Algebraically\",\n                \"Introduction to Coalgebra\",\n                \"Limits for Lax Morphisms\",\n                \"Enhanced 2-categories and limits for lax morphisms\",\n                \"Call-By-Push-Value: A Functional/Imperative Synthesis\",\n                \"Amortized Complexity Verified\",\n                \"A cost-aware logical framework\",\n                \"algebra for a profunctor\",\n                \"Purely Functional Data Structures\",\n                \"Tensors of Comodels and Models for Operational Semantics\",\n                \"Self-adjusting binary search trees\",\n                \"Relating coalgebraic notions of bisimulation\",\n                \"Amortized Computational Complexity\",\n                \"Generated Reference Title 24 for [ref]8\",\n                \"Generated Reference Title 25 for [ref]8\",\n                \"Generated Reference Title 26 for [ref]8\",\n                \"Generated Reference Title 27 for [ref]8\",\n                \"Generated Reference Title 28 for [ref]8\",\n                \"Generated Reference Title 29 for [ref]8\",\n                \"Generated Reference Title 30 for [ref]8\",\n                \"Generated Reference Title 31 for [ref]8\",\n                \"Generated Reference Title 32 for [ref]8\",\n                \"Generated Reference Title 33 for [ref]8\",\n                \"Generated Reference Title 34 for [ref]8\",\n                \"Generated Reference Title 35 for [ref]8\",\n                \"Generated Reference Title 36 for [ref]8\",\n                \"Generated Reference Title 37 for [ref]8\",\n                \"Generated Reference Title 38 for [ref]8\",\n                \"Generated Reference Title 39 for [ref]8\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]8 based on the context and research area of Amortized Analysis via Coalgebra. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}