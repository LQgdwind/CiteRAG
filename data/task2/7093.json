{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: Quantum and classical query complexities of functions of matrices\n\nPaper Abstract: \n\nPaper Section Text:\nThe quantum query (or black-box) model is an important model in studying quantum advantage over classical algorithms. In this model, we are given an oracle that allows us to query the inputs xi,i∈[n]subscript𝑥𝑖𝑖delimited-[]𝑛x_{i},i\\in[n] in superposition, and the goal is to determine some properties of an unknown object f​(x1,…,xn)𝑓subscript𝑥1…subscript𝑥𝑛f(x_{1},\\ldots,x_{n}) (e.g., an unknown function) using as few queries as possible.\nMany famous quantum algorithms fit naturally into the query model, such as the period-finding problem (a key subroutine of Shor’s algorithm ) and Grover’s algorithm , Simon’s algorithm , Deutsch-Jozsa’s algorithm , Bernstein-Vazirani’s algorithm , etc.\nAnother reason that makes the query model important is that one can prove nontrivial lower bounds and so can bound the potential quantum advantage . Quantum singular value transformation (QSVT) is a unified framework that encompasses many major quantum algorithms . Given a univariate bounded real-valued polynomial P​(x)𝑃𝑥P(x) and a Hermitian matrix A𝐴A with a bounded operator norm (e.g., ‖A‖≤1norm𝐴1\\|A\\|\\leq 1) that is encoded into a quantum circuit, one can construct a new quantum circuit that implements P​(A)𝑃𝐴P(A) by QSVT. The complexity of this procedure is mainly dominated by the degree of P​(x)𝑃𝑥P(x).\nMore generally, for any function f​(x)𝑓𝑥f(x) that has an efficiently computable polynomial approximation, we can also apply QSVT to approximately implement f​(A)𝑓𝐴f(A).\nFunctions of matrices play an important role in exploring quantum advantage. For example, if f​(x)=ei​x​t𝑓𝑥superscript𝑒𝑖𝑥𝑡f(x)=e^{ixt}, then f​(A)𝑓𝐴f(A) corresponds to Hamiltonian simulation; if f​(x)=1/x𝑓𝑥1𝑥f(x)=1/x, then f​(A)𝑓𝐴f(A) corresponds to the matrix inversion problem. These problems are BQP-complete and believed to be intractable for classical computers. For these problems, many efficient quantum algorithms were proposed, some of which use QSVT.\nAs mentioned above, the complexity of the algorithms based on QSVT is mainly determined by the degree of some polynomials.\nIt was proved in [24, Theorem 73] that the lower bound of the complexity of QSVT is roughly Ω​(maxx⁡|f′​(x)|)Ωsubscript𝑥superscript𝑓′𝑥\\Omega(\\max_{x}|f^{\\prime}(x)|), which suggests that the dependence on the degree is optimal for many functions that are relevant to applications. In this work, we consider the problem of computing an entry of functions of matrices (with classical output) directly, via an arbitrary method that may not use QSVT. We prove a quantum query complexity lower bound based on the approximate degree, which implies a (tight) lower bound on QSVT in terms of the approximate degree directly. We will also study the classical query complexity of the same problem and show that the quantum-classical separation is exponential. Before stating our main results, we first recall some concepts. Let A𝐴A be a Hermitian matrix with eigenvalue decomposition A=U​D​U†𝐴𝑈𝐷superscript𝑈†A=UDU^{\\dagger}, and let f​(x)𝑓𝑥f(x) be a univariate function. We define f​(A):=U​f​(D)​U†assign𝑓𝐴𝑈𝑓𝐷superscript𝑈†f(A):=Uf(D)U^{\\dagger}, where f𝑓f is applied to the diagonal entries of D𝐷D. Let f​(x):[−1,1]→[−1,1]:𝑓𝑥→1111f(x):[-1,1]\\rightarrow[-1,1] be a function and ε∈ 𝜀01\\varepsilon\\in , we define the ε𝜀\\varepsilon-approximate degree of f​(x)𝑓𝑥f(x) as The approximate degree can be defined similarly for any function from an interval [a,b]𝑎𝑏[a,b] to the real field ℝℝ\\mathbb{R}, e.g., see  . In this work, our focus is on the interval [−1,1]11[-1,1]. One reason is that with appropriate scaling, we can change the domain and the range of f​(x)𝑓𝑥f(x). Another reason is fitting the framework of quantum computing. Namely, when we design quantum algorithms for functions of matrices, we usually focus on bounded functions on the interval [−1,1]11[-1,1], e,g., see [24, Theorem 56]. Let A=(Ai​j)n×n𝐴subscriptsubscript𝐴𝑖𝑗𝑛𝑛A=(A_{ij})_{n\\times n} be a sparse Hermitian matrix. We assume that we can query A𝐴A through the following two oracles: where νi​jsubscript𝜈𝑖𝑗\\nu_{ij} is the position of the j𝑗j-th nonzero entry of the i𝑖i-th row. The second oracle is We assume that we can also use the above two oracles in superposition. In this work, we use |1⟩,…,|n⟩ket1…ket𝑛|1\\rangle,\\dots,|n\\rangle to denote the standard basis for ℂnsuperscriptℂ𝑛\\mathbb{C}^{n}. So the (i,j)𝑖𝑗(i,j)-th entry of A𝐴A is ⟨i|A|j⟩quantum-operator-product𝑖𝐴𝑗\\langle i|A|j\\rangle, which is more intuitive. This is a little different from the standard quantum state notation, which usually starts from |0⟩ket0|0\\rangle. By sparse, we mean the number of nonzero entries in each row of A𝐴A is polylogarithmic in the dimension.\nIn the classical case, we also assume that we have oracles similar to (1.1), (1.2) to query matrix A𝐴A. The difference is that we cannot use them in superposition now.\nThe main problem we will study in this paper is the following. Let f​(x):[−1,1]→[−1,1]:𝑓𝑥→1111f(x):[-1,1]\\rightarrow[-1,1] be a univariate function and let A𝐴A be a sparse Hermitian matrix with ‖A‖≤1norm𝐴1\\|A\\|\\leq 1 and two query oracles (1.1), (1.2). Let i,j𝑖𝑗i,j be two indices and ε∈(0,1]𝜀01\\varepsilon\\in(0,1] be the accuracy. What is the query complexity of computing ⟨i|f​(A)|j⟩±ε​?plus-or-minusquantum-operator-product𝑖𝑓𝐴𝑗𝜀?\\langle i|f(A)|j\\rangle\\pm\\varepsilon?111Generally, let f​(x):[−α,α]→[−M,M]:𝑓𝑥→𝛼𝛼𝑀𝑀f(x):[-\\alpha,\\alpha]\\rightarrow[-M,M]. If M>1𝑀1M>1, then it is possible that ⟨i|f​(A)|j⟩quantum-operator-product𝑖𝑓𝐴𝑗\\langle i|f(A)|j\\rangle can be very large, such as f​(x)=xd𝑓𝑥superscript𝑥𝑑f(x)=x^{d}. In this case, the relative error is more appropriate, i.e., computing ⟨i|f​(A)|j⟩±M​εplus-or-minusquantum-operator-product𝑖𝑓𝐴𝑗𝑀𝜀\\langle i|f(A)|j\\rangle\\pm M\\varepsilon. This is equivalent to computing ⟨i|f~​(A)|j⟩±εplus-or-minusquantum-operator-product𝑖~𝑓𝐴𝑗𝜀\\langle i|\\tilde{f}(A)|j\\rangle\\pm\\varepsilon, where f~​(x)=f​(α​x)/M~𝑓𝑥𝑓𝛼𝑥𝑀\\tilde{f}(x)=f(\\alpha x)/M is from [−1,1]11[-1,1] to [−1,1]11[-1,1]. This is another reason why we consider functions from [−1,1]11[-1,1] to [−1,1]11[-1,1]. For the above problem, we are more concerned about the lower bounds analysis.\nIn the above, the quantum/classical query complexity refers to the minimum number of queries to (1.1), (1.2)\nneeded for a quantum/classical algorithm that approximates ⟨i|f​(A)|j⟩quantum-operator-product𝑖𝑓𝐴𝑗\\langle i|f(A)|j\\rangle for every sparse Hermitian matrix A𝐴A, with error probability at most 1/3.\nFor Problem 1.4, our main result in the quantum case is described as follows. For any continuous function f​(x):[−1,1]→[−1,1]:𝑓𝑥→1111f(x):[-1,1]\\rightarrow[-1,1], there is a 2-sparse Hermitian matrix A𝐴A with ‖A‖≤1norm𝐴1\\|A\\|\\leq 1 and two indices i,j𝑖𝑗i,j such that\nΩ​(deg~ε​(f))Ωsubscript~degree𝜀𝑓\\Omega(\\widetilde{\\deg}_{\\varepsilon}(f)) queries to A𝐴A are required in order to\ncompute ⟨i|f​(A)|j⟩±ε/4plus-or-minusquantum-operator-product𝑖𝑓𝐴𝑗𝜀4\\langle i|f(A)|j\\rangle\\pm\\varepsilon/4. As an application, consider f​(x)=ei​x​t𝑓𝑥superscript𝑒𝑖𝑥𝑡f(x)=e^{ixt}, then the imaginary part of f​(x)𝑓𝑥f(x) satisfies deg~ε​(sin⁡(x​t))=Ω​(t)subscript~degree𝜀𝑥𝑡Ω𝑡\\widetilde{\\deg}_{\\varepsilon}(\\sin(xt))=\\Omega(t) [24, Lemma 57].\nBy the above theorem, we re-obtain the quantum no fast-forwarding theorem 7, also see the analysis below Corollary 1.11 for more details.\nAs another application, we consider f​(x)=1/x𝑓𝑥1𝑥f(x)=1/x. Although this function does not satisfy the condition of the above theorem, using a similar argument to the proof of Theorem 1.5, we can also obtain a lower bound of Ω​(κ)Ω𝜅\\Omega(\\kappa), where κ𝜅\\kappa is the condition number. We state the result as follows.222We can also consider the polynomial that approximates 1/x1𝑥1/x in the interval [−1,1]\\[−δ,δ]\\11𝛿𝛿[-1,1]\\backslash[-\\delta,\\delta], where δ𝛿\\delta is usually 1/κ1𝜅1/\\kappa. The degree is close to O​(δ−1​log⁡(1/ε​δ))𝑂superscript𝛿11𝜀𝛿O(\\delta^{-1}\\log(1/\\varepsilon\\delta)) [24, Corollary 69]. One problem is that it is not clear if this degree is minimal. If it is, then we can obtain a lower bound of Ω​(κ​log⁡(κ/ε))Ω𝜅𝜅𝜀\\Omega(\\kappa\\log(\\kappa/\\varepsilon)) by Theorem 1.5.  There is a 2-sparse Hermitian matrix A𝐴A with ‖A‖≤1norm𝐴1\\|A\\|\\leq 1 and condition number κ𝜅\\kappa such that Ω​(κ)Ω𝜅\\Omega(\\kappa) quantum queries are required to compute ⟨i|A−1|j⟩quantum-operator-product𝑖superscript𝐴1𝑗\\langle i|A^{-1}|j\\rangle up to relative/additive error ε<1/4𝜀14\\varepsilon<1/4. Note that for the matrix inversion problem, it was proved in  that the quantum query complexity of approximating ⟨𝐱|M|𝐱⟩quantum-operator-product𝐱𝑀𝐱\\langle{\\bf x}|M|{\\bf x}\\rangle is lower bounded by Ω~​(κ1−δ)~Ωsuperscript𝜅1𝛿\\widetilde{\\Omega}(\\kappa^{1-\\delta}) for any δ>0𝛿0\\delta>0, where M=|0⟩​⟨0|⊗I𝑀tensor-productket0bra0𝐼M=|0\\rangle\\langle 0|\\otimes I and |𝐱⟩ket𝐱|{\\bf x}\\rangle is a normalized state proportional to A−1​|0⟩superscript𝐴1ket0A^{-1}|0\\rangle. In the above theorem, we considered a different matrix inversion problem and also proved a lower bound in terms of the condition number. For an upper bound on the query complexity, by quantum singular value transformation [24, Theorem 56], it is not hard to prove the following result.\nBelow, for a matrix A=(Ai​j)n×n𝐴subscriptsubscript𝐴𝑖𝑗𝑛𝑛A=(A_{ij})_{n\\times n}, we define ‖A‖max=maxi,j⁡|Ai​j|subscriptnorm𝐴subscript𝑖𝑗subscript𝐴𝑖𝑗\\|A\\|_{\\max}=\\max_{i,j}|A_{ij}|. Note that if ‖A‖≤1norm𝐴1\\|A\\|\\leq 1, then ‖A‖max≤1subscriptnorm𝐴1\\|A\\|_{\\max}\\leq 1. Let A𝐴A be an s𝑠s-sparse Hermitian matrix with ‖A‖≤1−δnorm𝐴1𝛿\\|A\\|\\leq 1-\\delta for some δ>0𝛿0\\delta>0, and\nlet f:[−1,1]→[−1,1]:𝑓→1111f:[-1,1]\\rightarrow[-1,1] be a continuous function. Then for any two efficiently preparable quantum states |x⟩,|y⟩ket𝑥ket𝑦|x\\rangle,|y\\rangle there is a quantum algorithm that computes ⟨x|f​(A)|y⟩±εplus-or-minusquantum-operator-product𝑥𝑓𝐴𝑦𝜀\\langle x|f(A)|y\\rangle\\pm\\varepsilon with query complexity O​(Cε​deg~ε​(f))𝑂𝐶𝜀subscript~degree𝜀𝑓O(\\frac{C}{\\varepsilon}\\widetilde{\\deg}_{\\varepsilon}(f)), where C=s​‖A‖maxδ​log⁡(s​‖A‖maxε​deg~ε​(f))𝐶𝑠subscriptnorm𝐴𝛿𝑠subscriptnorm𝐴𝜀subscript~degree𝜀𝑓C=\\frac{s\\|A\\|_{\\max}}{\\delta}\\log(\\frac{s\\|A\\|_{\\max}}{\\varepsilon}\\widetilde{\\deg}_{\\varepsilon}(f)). In the above theorem, for many functions such as ei​x​t,xd,ex​t,1/xsuperscript𝑒𝑖𝑥𝑡superscript𝑥𝑑superscript𝑒𝑥𝑡1𝑥e^{ixt},x^{d},e^{xt},1/x, the constraint ‖A‖≤1−δnorm𝐴1𝛿\\|A\\|\\leq 1-\\delta can be relaxed to ‖A‖≤1norm𝐴1\\|A\\|\\leq 1. In addition, by quantum phase estimation, we can propose a quantum algorithm with complexity roughly O​(deg~ε​(f)2)𝑂subscript~degree𝜀superscript𝑓2O(\\widetilde{\\deg}_{\\varepsilon}(f)^{2}) without making assumptions.\nWe will discuss this in more detail in Section 4. Theorem 1.5 can be viewed as an analogy to the polynomial method for continuous functions of matrices. Recall that for a Boolean function f​(x1,…,xn):{0,1}n→{0,1}:𝑓subscript𝑥1…subscript𝑥𝑛→superscript01𝑛01f(x_{1},\\ldots,x_{n}):\\{0,1\\}^{n}\\rightarrow\\{0,1\\}, given a quantum oracle to query xisubscript𝑥𝑖x_{i} in superposition, it is known from the polynomial method that computing f​(x1,…,xn)𝑓subscript𝑥1…subscript𝑥𝑛f(x_{1},\\ldots,x_{n}) costs at least Ω​(deg~ε​(f))Ωsubscript~degree𝜀𝑓\\Omega(\\widetilde{\\deg}_{\\varepsilon}(f)) queries 4. Here deg~ε​(f)subscript~degree𝜀𝑓\\widetilde{\\deg}_{\\varepsilon}(f) is defined as the minimal degree of polynomial P​(x1,…,xn)𝑃subscript𝑥1…subscript𝑥𝑛P(x_{1},\\ldots,x_{n}) such that |P​(x)−f​(x)|≤ε𝑃𝑥𝑓𝑥𝜀|P(x)-f(x)|\\leq\\varepsilon and |P​(x)|≤1𝑃𝑥1|P(x)|\\leq 1 for all x∈{0,1}n𝑥superscript01𝑛x\\in\\{0,1\\}^{n}.\nThe polynomial method has been successful in proving certain tight lower bounds 4 .\nUnfortunately, for Boolean functions, the approximate degree is an imprecise measure of quantum query complexity. Namely, there exist total Boolean functions f𝑓f such that deg~1/3​(f)≤nαsubscript~degree13𝑓superscript𝑛𝛼\\widetilde{\\deg}_{1/3}(f)\\leq n^{\\alpha} while the quantum query complexity of computing f𝑓f is at least nβsuperscript𝑛𝛽n^{\\beta}, where α,β𝛼𝛽\\alpha,\\beta are constants with β>α𝛽𝛼\\beta>\\alpha, e.g., see  .\nFor functions of matrices, Theorems 1.5 and 1.7 indicate that up to a logarithmic term, the approximate degree characterises the quantum query complexity precisely when s​‖A‖max,δ,ε𝑠subscriptnorm𝐴𝛿𝜀s\\|A\\|_{\\max},\\delta,\\varepsilon are constants. For Problem 1.4, our main result in the classical case is described as follows. Let f​(x):[−1,1]→[−1,1]:𝑓𝑥→1111f(x):[-1,1]\\rightarrow[-1,1] be a continuous function, then there exists a 4-sparse Hermitian matrix A𝐴A with ‖A‖≤1norm𝐴1\\|A\\|\\leq 1 and two indices i,j𝑖𝑗i,j such that classical queries to A𝐴A are required in order to compute ⟨i|f​(A)|j⟩±ε/4plus-or-minusquantum-operator-product𝑖𝑓𝐴𝑗𝜀4\\langle i|f(A)|j\\rangle\\pm\\varepsilon/4. Combining Theorems 1.7 and 1.8, we can claim that for Problem 1.4, the quantum and classical separation is exponential in terms of the approximate degree for any continuous function. Recall that for functions like f​(x)=ei​x​t,xd𝑓𝑥superscript𝑒𝑖𝑥𝑡superscript𝑥𝑑f(x)=e^{ixt},x^{d}, the approximation of ⟨i|f​(A)|j⟩quantum-operator-product𝑖𝑓𝐴𝑗\\langle i|f(A)|j\\rangle is BQP-complete  . Namely, they are believed to be hard to solve for classical computers. In Theorem 1.8, we provide a quantitative result on this hardness using query complexity. For example, if f​(x)=ei​x​t𝑓𝑥superscript𝑒𝑖𝑥𝑡f(x)=e^{ixt}, then deg~ε​(f)=Θ​(t)subscript~degree𝜀𝑓Θ𝑡\\widetilde{\\deg}_{\\varepsilon}(f)=\\Theta(t) when ε=O​(1)𝜀𝑂1\\varepsilon=O(1) , so the classical lower bound we have is Ω​(2t/6t)Ωsuperscript2𝑡6𝑡\\Omega(\\frac{2^{t/6}}{t}), while the quantum upper bound is just O​(t)𝑂𝑡O(t). If f​(x)=xd𝑓𝑥superscript𝑥𝑑f(x)=x^{d}, then deg~ε​(f)=Θ​(d)subscript~degree𝜀𝑓Θ𝑑\\widetilde{\\deg}_{\\varepsilon}(f)=\\Theta(\\sqrt{d}) when ε=O​(1)𝜀𝑂1\\varepsilon=O(1) , so the classical lower bound is Ω​(2d/6d)Ωsuperscript2𝑑6𝑑\\Omega(\\frac{2^{\\sqrt{d}/6}}{\\sqrt{d}}), while the quantum upper bound is only O​(d)𝑂𝑑O(\\sqrt{d}). Regarding classical algorithms for Problem 1.4, when f𝑓f is a polynomial of degree d𝑑d, then there is an exact algorithm with query complexity O​(sd−1)𝑂superscript𝑠𝑑1O(s^{d-1}) building on the definition of functions of matrices, where s𝑠s is the sparsity. So for the situation of Theorem 1.8, this upper bound is O​(22​deg~ε​(f))𝑂superscript22subscript~degree𝜀𝑓O(2^{2\\widetilde{\\deg}_{\\varepsilon}(f)}) as the sparsity is s=4𝑠4s=4. This upper bound is not too far from the lower bound.\nIn Section 5, we also have two other classical algorithms for solving Problem 1.4, one is based on random walks, and the other one is based on the Cauchy integral formula.\nHere we state the result for the second algorithm, which is more efficient when f𝑓f is analytic. Let A𝐴A be an s𝑠s-sparse matrix with ‖A‖1>‖A‖subscriptnorm𝐴1norm𝐴\\|A\\|_{1}>\\|A\\|.\nLet f​(z)𝑓𝑧f(z) be an analytic function in the disk |z|≤R𝑧𝑅|z|\\leq R with R>‖A‖12/‖A‖𝑅superscriptsubscriptnorm𝐴12norm𝐴R>\\|A\\|_{1}^{2}/\\|A\\|. Then there is a classical algorithm that computes ⟨i|f​(A)|j⟩±εplus-or-minusquantum-operator-product𝑖𝑓𝐴𝑗𝜀\\langle i|f(A)|j\\rangle\\pm\\varepsilon in cost In the above complexity, the dominating term is M:=maxz∈ℂ,|z|=‖A‖1⁡|f​(z)|2assign𝑀subscriptformulae-sequence𝑧ℂ𝑧subscriptnorm𝐴1superscript𝑓𝑧2M:=\\max_{z\\in\\mathbb{C},|z|=\\|A\\|_{1}}|f(z)|^{2}. This classical algorithm is efficient when this quantity is small. However, M𝑀M can be exponentially large when ‖A‖1>1subscriptnorm𝐴11\\|A\\|_{1}>1 even if f𝑓f is bounded by 1 in the interval [−1,1]11[-1,1]. For example, if f​(x)=sin⁡(x​t)𝑓𝑥𝑥𝑡f(x)=\\sin(xt), then M=Θ​(e2​‖A‖1​t)𝑀Θsuperscript𝑒2subscriptnorm𝐴1𝑡M=\\Theta(e^{2\\|A\\|_{1}t}). If f​(x)=xd𝑓𝑥superscript𝑥𝑑f(x)=x^{d}, then M=‖A‖12​d𝑀superscriptsubscriptnorm𝐴12𝑑M=\\|A\\|_{1}^{2d}. More generally, when f​(x)=∑k=0dak​xk𝑓𝑥superscriptsubscript𝑘0𝑑subscript𝑎𝑘superscript𝑥𝑘f(x)=\\sum_{k=0}^{d}a_{k}x^{k} is a polynomial of degree d𝑑d, the quantity M𝑀M can be as large as ‖A‖12​dsuperscriptsubscriptnorm𝐴12𝑑\\|A\\|_{1}^{2d}. Note that ‖A‖1≤s​‖A‖subscriptnorm𝐴1𝑠norm𝐴\\|A\\|_{1}\\leq\\sqrt{s}\\|A\\|, so the above algorithm is usually more efficient than the exact algorithm. Finally, we remark that for total Boolean functions, it is known that the separation of quantum and classical query complexities is at most quartic [ref]3. Exponential separation only exists for some partial Boolean functions with certain structures. Our results show that for functions of sparse Hermitian matrices, the quantum and classical separation is exponential. Here a function of a sparse matrix can also be viewed as a partial function in some sense. This might provide an approach to finding partial Boolean functions that can demonstrate exponential separations.\n\nReference markers found: [3]\n\nContext windows for each [ref]:\n[ref]3: usually more efficient than the exact algorithm. Finally, we remark that for total Boolean functions, it is known that the separation of quantum and classical query complexities is at most quartic [ref]3. Exponential separation only exists for some partial Boolean functions with certain structures. Our results show that for functions of sparse Hermitian matrices, the quantum and classical\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 3,\n            \"titles\": [\n                \"Optimal-Degree Polynomial Approximations for Exponentials and Gaussian Kernel Density Estimation\",\n                \"Forrelation: A problem that optimally separates quantum from classical computing\",\n                \"Separations in query complexity using cheat sheets\",\n                \"Degree vs. approximate degree and quantum implications of Huang’s sensitivity theorem\",\n                \"Tight bound for estimating expectation values from a system of linear equations\",\n                \"Polynomial degree vs. quantum query complexity\",\n                \"An exponential separation between quantum query complexity and the polynomial degree\",\n                \"A theory of quantum differential equation solvers: limitations and fast-forwarding\",\n                \"On Solving Linear Systems in Sublinear Time\",\n                \"Quantum SDP-Solvers: Better upper and lower bounds\",\n                \"A (simple) classical algorithm for estimating Betti numbers\",\n                \"Quantum Query Algorithms are Completely Bounded Forms\",\n                \"𝑘-Forrelation Optimally Separates Quantum and Classical Query Complexity\",\n                \"Quantum lower bounds by polynomials\",\n                \"Strengths and weaknesses of quantum computing\",\n                \"Quantum complexity theory\",\n                \"Efficient quantum algorithms for simulating sparse Hamiltonians\",\n                \"Exponential improvement in precision for simulating sparse Hamiltonians\",\n                \"Approximate Degree in Classical and Quantum Computing\",\n                \"The Quantum Complexity of Computing Schatten 𝑝-norms\",\n                \"Linear programming\",\n                \"Rapid solution of problems by quantum computation\",\n                \"Limit on the speed of quantum computation in determining parity\",\n                \"Quantum singular value transformation and beyond: exponential improvements for quantum matrix arithmetics\",\n                \"Quantum algorithms for powering stable Hermitian matrices\",\n                \"A fast quantum mechanical algorithm for database search\",\n                \"Quantum algorithm for linear systems of equations\",\n                \"Functions of Matrices: Theory and Computation\",\n                \"On the construction of a Jacobi matrix from spectral data\",\n                \"Analysis of Numerical Methods\",\n                \"The Theory of Approximation, volume 11\",\n                \"BQP-complete problems concerning mixing properties of classical random walks on sparse graphs\",\n                \"Quantum lower bound for the collision problem with small range\",\n                \"On linear semi-infinite programming problems: An algorithm\",\n                \"Hamiltonian complexity\",\n                \"The Symmetric Eigenvalue Problem\",\n                \"Faster algorithms via approximation theory\",\n                \"Semi-infinite programming, duality, discretization and optimality conditions\",\n                \"Polynomial-time algorithms for prime factorization and discrete logarithms on a quantum computer\",\n                \"On the power of quantum computation\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]3 based on the context and research area of Quantum and classical query complexities of functions of matrices. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}