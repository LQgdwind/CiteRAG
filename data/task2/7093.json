{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: Quantum and classical query complexities of functions of matrices\n\nPaper Abstract: \n\nPaper Section Text:\nThe quantum query (or black-box) model is an important model in studying quantum advantage over classical algorithms. In this model, we are given an oracle that allows us to query the inputs xi,iâˆˆ[n]subscriptğ‘¥ğ‘–ğ‘–delimited-[]ğ‘›x_{i},i\\in[n] in superposition, and the goal is to determine some properties of an unknown object fâ€‹(x1,â€¦,xn)ğ‘“subscriptğ‘¥1â€¦subscriptğ‘¥ğ‘›f(x_{1},\\ldots,x_{n}) (e.g., an unknown function) using as few queries as possible.\nMany famous quantum algorithms fit naturally into the query model, such as the period-finding problem (a key subroutine of Shorâ€™s algorithm ) and Groverâ€™s algorithm , Simonâ€™s algorithm , Deutsch-Jozsaâ€™s algorithm , Bernstein-Vaziraniâ€™s algorithm , etc.\nAnother reason that makes the query model important is that one can prove nontrivial lower bounds and so can bound the potential quantum advantage . Quantum singular value transformation (QSVT) is a unified framework that encompasses many major quantum algorithms . Given a univariate bounded real-valued polynomial Pâ€‹(x)ğ‘ƒğ‘¥P(x) and a Hermitian matrix Ağ´A with a bounded operator norm (e.g., â€–Aâ€–â‰¤1normğ´1\\|A\\|\\leq 1) that is encoded into a quantum circuit, one can construct a new quantum circuit that implements Pâ€‹(A)ğ‘ƒğ´P(A) by QSVT. The complexity of this procedure is mainly dominated by the degree of Pâ€‹(x)ğ‘ƒğ‘¥P(x).\nMore generally, for any function fâ€‹(x)ğ‘“ğ‘¥f(x) that has an efficiently computable polynomial approximation, we can also apply QSVT to approximately implement fâ€‹(A)ğ‘“ğ´f(A).\nFunctions of matrices play an important role in exploring quantum advantage. For example, if fâ€‹(x)=eiâ€‹xâ€‹tğ‘“ğ‘¥superscriptğ‘’ğ‘–ğ‘¥ğ‘¡f(x)=e^{ixt}, then fâ€‹(A)ğ‘“ğ´f(A) corresponds to Hamiltonian simulation; if fâ€‹(x)=1/xğ‘“ğ‘¥1ğ‘¥f(x)=1/x, then fâ€‹(A)ğ‘“ğ´f(A) corresponds to the matrix inversion problem. These problems are BQP-complete and believed to be intractable for classical computers. For these problems, many efficient quantum algorithms were proposed, some of which use QSVT.\nAs mentioned above, the complexity of the algorithms based on QSVT is mainly determined by the degree of some polynomials.\nIt was proved in [24, Theorem 73] that the lower bound of the complexity of QSVT is roughly Î©â€‹(maxxâ¡|fâ€²â€‹(x)|)Î©subscriptğ‘¥superscriptğ‘“â€²ğ‘¥\\Omega(\\max_{x}|f^{\\prime}(x)|), which suggests that the dependence on the degree is optimal for many functions that are relevant to applications. In this work, we consider the problem of computing an entry of functions of matrices (with classical output) directly, via an arbitrary method that may not use QSVT. We prove a quantum query complexity lower bound based on the approximate degree, which implies a (tight) lower bound on QSVT in terms of the approximate degree directly. We will also study the classical query complexity of the same problem and show that the quantum-classical separation is exponential. Before stating our main results, we first recall some concepts. Let Ağ´A be a Hermitian matrix with eigenvalue decomposition A=Uâ€‹Dâ€‹Uâ€ ğ´ğ‘ˆğ·superscriptğ‘ˆâ€ A=UDU^{\\dagger}, and let fâ€‹(x)ğ‘“ğ‘¥f(x) be a univariate function. We define fâ€‹(A):=Uâ€‹fâ€‹(D)â€‹Uâ€ assignğ‘“ğ´ğ‘ˆğ‘“ğ·superscriptğ‘ˆâ€ f(A):=Uf(D)U^{\\dagger}, where fğ‘“f is applied to the diagonal entries of Dğ·D. Let fâ€‹(x):[âˆ’1,1]â†’[âˆ’1,1]:ğ‘“ğ‘¥â†’1111f(x):[-1,1]\\rightarrow[-1,1] be a function and Îµâˆˆ ğœ€01\\varepsilon\\in , we define the Îµğœ€\\varepsilon-approximate degree of fâ€‹(x)ğ‘“ğ‘¥f(x) as The approximate degree can be defined similarly for any function from an interval [a,b]ğ‘ğ‘[a,b] to the real field â„â„\\mathbb{R}, e.g., see  . In this work, our focus is on the interval [âˆ’1,1]11[-1,1]. One reason is that with appropriate scaling, we can change the domain and the range of fâ€‹(x)ğ‘“ğ‘¥f(x). Another reason is fitting the framework of quantum computing. Namely, when we design quantum algorithms for functions of matrices, we usually focus on bounded functions on the interval [âˆ’1,1]11[-1,1], e,g., see [24, Theorem 56]. Let A=(Aiâ€‹j)nÃ—nğ´subscriptsubscriptğ´ğ‘–ğ‘—ğ‘›ğ‘›A=(A_{ij})_{n\\times n} be a sparse Hermitian matrix. We assume that we can query Ağ´A through the following two oracles: where Î½iâ€‹jsubscriptğœˆğ‘–ğ‘—\\nu_{ij} is the position of the jğ‘—j-th nonzero entry of the iğ‘–i-th row. The second oracle is We assume that we can also use the above two oracles in superposition. In this work, we use |1âŸ©,â€¦,|nâŸ©ket1â€¦ketğ‘›|1\\rangle,\\dots,|n\\rangle to denote the standard basis for â„‚nsuperscriptâ„‚ğ‘›\\mathbb{C}^{n}. So the (i,j)ğ‘–ğ‘—(i,j)-th entry of Ağ´A is âŸ¨i|A|jâŸ©quantum-operator-productğ‘–ğ´ğ‘—\\langle i|A|j\\rangle, which is more intuitive. This is a little different from the standard quantum state notation, which usually starts from |0âŸ©ket0|0\\rangle. By sparse, we mean the number of nonzero entries in each row of Ağ´A is polylogarithmic in the dimension.\nIn the classical case, we also assume that we have oracles similar to (1.1), (1.2) to query matrix Ağ´A. The difference is that we cannot use them in superposition now.\nThe main problem we will study in this paper is the following. Let fâ€‹(x):[âˆ’1,1]â†’[âˆ’1,1]:ğ‘“ğ‘¥â†’1111f(x):[-1,1]\\rightarrow[-1,1] be a univariate function and let Ağ´A be a sparse Hermitian matrix with â€–Aâ€–â‰¤1normğ´1\\|A\\|\\leq 1 and two query oracles (1.1), (1.2). Let i,jğ‘–ğ‘—i,j be two indices and Îµâˆˆ(0,1]ğœ€01\\varepsilon\\in(0,1] be the accuracy. What is the query complexity of computing âŸ¨i|fâ€‹(A)|jâŸ©Â±Îµâ€‹?plus-or-minusquantum-operator-productğ‘–ğ‘“ğ´ğ‘—ğœ€?\\langle i|f(A)|j\\rangle\\pm\\varepsilon?111Generally, let fâ€‹(x):[âˆ’Î±,Î±]â†’[âˆ’M,M]:ğ‘“ğ‘¥â†’ğ›¼ğ›¼ğ‘€ğ‘€f(x):[-\\alpha,\\alpha]\\rightarrow[-M,M]. If M>1ğ‘€1M>1, then it is possible that âŸ¨i|fâ€‹(A)|jâŸ©quantum-operator-productğ‘–ğ‘“ğ´ğ‘—\\langle i|f(A)|j\\rangle can be very large, such as fâ€‹(x)=xdğ‘“ğ‘¥superscriptğ‘¥ğ‘‘f(x)=x^{d}. In this case, the relative error is more appropriate, i.e., computing âŸ¨i|fâ€‹(A)|jâŸ©Â±Mâ€‹Îµplus-or-minusquantum-operator-productğ‘–ğ‘“ğ´ğ‘—ğ‘€ğœ€\\langle i|f(A)|j\\rangle\\pm M\\varepsilon. This is equivalent to computing âŸ¨i|f~â€‹(A)|jâŸ©Â±Îµplus-or-minusquantum-operator-productğ‘–~ğ‘“ğ´ğ‘—ğœ€\\langle i|\\tilde{f}(A)|j\\rangle\\pm\\varepsilon, where f~â€‹(x)=fâ€‹(Î±â€‹x)/M~ğ‘“ğ‘¥ğ‘“ğ›¼ğ‘¥ğ‘€\\tilde{f}(x)=f(\\alpha x)/M is from [âˆ’1,1]11[-1,1] to [âˆ’1,1]11[-1,1]. This is another reason why we consider functions from [âˆ’1,1]11[-1,1] to [âˆ’1,1]11[-1,1]. For the above problem, we are more concerned about the lower bounds analysis.\nIn the above, the quantum/classical query complexity refers to the minimum number of queries to (1.1), (1.2)\nneeded for a quantum/classical algorithm that approximates âŸ¨i|fâ€‹(A)|jâŸ©quantum-operator-productğ‘–ğ‘“ğ´ğ‘—\\langle i|f(A)|j\\rangle for every sparse Hermitian matrix Ağ´A, with error probability at most 1/3.\nFor Problem 1.4, our main result in the quantum case is described as follows. For any continuous function fâ€‹(x):[âˆ’1,1]â†’[âˆ’1,1]:ğ‘“ğ‘¥â†’1111f(x):[-1,1]\\rightarrow[-1,1], there is a 2-sparse Hermitian matrix Ağ´A with â€–Aâ€–â‰¤1normğ´1\\|A\\|\\leq 1 and two indices i,jğ‘–ğ‘—i,j such that\nÎ©â€‹(deg~Îµâ€‹(f))Î©subscript~degreeğœ€ğ‘“\\Omega(\\widetilde{\\deg}_{\\varepsilon}(f)) queries to Ağ´A are required in order to\ncompute âŸ¨i|fâ€‹(A)|jâŸ©Â±Îµ/4plus-or-minusquantum-operator-productğ‘–ğ‘“ğ´ğ‘—ğœ€4\\langle i|f(A)|j\\rangle\\pm\\varepsilon/4. As an application, consider fâ€‹(x)=eiâ€‹xâ€‹tğ‘“ğ‘¥superscriptğ‘’ğ‘–ğ‘¥ğ‘¡f(x)=e^{ixt}, then the imaginary part of fâ€‹(x)ğ‘“ğ‘¥f(x) satisfies deg~Îµâ€‹(sinâ¡(xâ€‹t))=Î©â€‹(t)subscript~degreeğœ€ğ‘¥ğ‘¡Î©ğ‘¡\\widetilde{\\deg}_{\\varepsilon}(\\sin(xt))=\\Omega(t) [24, Lemma 57].\nBy the above theorem, we re-obtain the quantum no fast-forwarding theoremÂ 7, also see the analysis below Corollary 1.11 for more details.\nAs another application, we consider fâ€‹(x)=1/xğ‘“ğ‘¥1ğ‘¥f(x)=1/x. Although this function does not satisfy the condition of the above theorem, using a similar argument to the proof of Theorem 1.5, we can also obtain a lower bound of Î©â€‹(Îº)Î©ğœ…\\Omega(\\kappa), where Îºğœ…\\kappa is the condition number. We state the result as follows.222We can also consider the polynomial that approximates 1/x1ğ‘¥1/x in the interval [âˆ’1,1]\\[âˆ’Î´,Î´]\\11ğ›¿ğ›¿[-1,1]\\backslash[-\\delta,\\delta], where Î´ğ›¿\\delta is usually 1/Îº1ğœ…1/\\kappa. The degree is close to Oâ€‹(Î´âˆ’1â€‹logâ¡(1/Îµâ€‹Î´))ğ‘‚superscriptğ›¿11ğœ€ğ›¿O(\\delta^{-1}\\log(1/\\varepsilon\\delta)) [24, Corollary 69]. One problem is that it is not clear if this degree is minimal. If it is, then we can obtain a lower bound of Î©â€‹(Îºâ€‹logâ¡(Îº/Îµ))Î©ğœ…ğœ…ğœ€\\Omega(\\kappa\\log(\\kappa/\\varepsilon)) by Theorem 1.5.  There is a 2-sparse Hermitian matrix Ağ´A with â€–Aâ€–â‰¤1normğ´1\\|A\\|\\leq 1 and condition number Îºğœ…\\kappa such that Î©â€‹(Îº)Î©ğœ…\\Omega(\\kappa) quantum queries are required to compute âŸ¨i|Aâˆ’1|jâŸ©quantum-operator-productğ‘–superscriptğ´1ğ‘—\\langle i|A^{-1}|j\\rangle up to relative/additive error Îµ<1/4ğœ€14\\varepsilon<1/4. Note that for the matrix inversion problem, it was proved in  that the quantum query complexity of approximating âŸ¨ğ±|M|ğ±âŸ©quantum-operator-productğ±ğ‘€ğ±\\langle{\\bf x}|M|{\\bf x}\\rangle is lower bounded by Î©~â€‹(Îº1âˆ’Î´)~Î©superscriptğœ…1ğ›¿\\widetilde{\\Omega}(\\kappa^{1-\\delta}) for any Î´>0ğ›¿0\\delta>0, where M=|0âŸ©â€‹âŸ¨0|âŠ—Iğ‘€tensor-productket0bra0ğ¼M=|0\\rangle\\langle 0|\\otimes I and |ğ±âŸ©ketğ±|{\\bf x}\\rangle is a normalized state proportional to Aâˆ’1â€‹|0âŸ©superscriptğ´1ket0A^{-1}|0\\rangle. In the above theorem, we considered a different matrix inversion problem and also proved a lower bound in terms of the condition number. For an upper bound on the query complexity, by quantum singular value transformation [24, Theorem 56], it is not hard to prove the following result.\nBelow, for a matrix A=(Aiâ€‹j)nÃ—nğ´subscriptsubscriptğ´ğ‘–ğ‘—ğ‘›ğ‘›A=(A_{ij})_{n\\times n}, we define â€–Aâ€–max=maxi,jâ¡|Aiâ€‹j|subscriptnormğ´subscriptğ‘–ğ‘—subscriptğ´ğ‘–ğ‘—\\|A\\|_{\\max}=\\max_{i,j}|A_{ij}|. Note that if â€–Aâ€–â‰¤1normğ´1\\|A\\|\\leq 1, then â€–Aâ€–maxâ‰¤1subscriptnormğ´1\\|A\\|_{\\max}\\leq 1. Let Ağ´A be an sğ‘ s-sparse Hermitian matrix with â€–Aâ€–â‰¤1âˆ’Î´normğ´1ğ›¿\\|A\\|\\leq 1-\\delta for some Î´>0ğ›¿0\\delta>0, and\nlet f:[âˆ’1,1]â†’[âˆ’1,1]:ğ‘“â†’1111f:[-1,1]\\rightarrow[-1,1] be a continuous function. Then for any two efficiently preparable quantum states |xâŸ©,|yâŸ©ketğ‘¥ketğ‘¦|x\\rangle,|y\\rangle there is a quantum algorithm that computes âŸ¨x|fâ€‹(A)|yâŸ©Â±Îµplus-or-minusquantum-operator-productğ‘¥ğ‘“ğ´ğ‘¦ğœ€\\langle x|f(A)|y\\rangle\\pm\\varepsilon with query complexity Oâ€‹(CÎµâ€‹deg~Îµâ€‹(f))ğ‘‚ğ¶ğœ€subscript~degreeğœ€ğ‘“O(\\frac{C}{\\varepsilon}\\widetilde{\\deg}_{\\varepsilon}(f)), where C=sâ€‹â€–Aâ€–maxÎ´â€‹logâ¡(sâ€‹â€–Aâ€–maxÎµâ€‹deg~Îµâ€‹(f))ğ¶ğ‘ subscriptnormğ´ğ›¿ğ‘ subscriptnormğ´ğœ€subscript~degreeğœ€ğ‘“C=\\frac{s\\|A\\|_{\\max}}{\\delta}\\log(\\frac{s\\|A\\|_{\\max}}{\\varepsilon}\\widetilde{\\deg}_{\\varepsilon}(f)). In the above theorem, for many functions such as eiâ€‹xâ€‹t,xd,exâ€‹t,1/xsuperscriptğ‘’ğ‘–ğ‘¥ğ‘¡superscriptğ‘¥ğ‘‘superscriptğ‘’ğ‘¥ğ‘¡1ğ‘¥e^{ixt},x^{d},e^{xt},1/x, the constraint â€–Aâ€–â‰¤1âˆ’Î´normğ´1ğ›¿\\|A\\|\\leq 1-\\delta can be relaxed to â€–Aâ€–â‰¤1normğ´1\\|A\\|\\leq 1. In addition, by quantum phase estimation, we can propose a quantum algorithm with complexity roughly Oâ€‹(deg~Îµâ€‹(f)2)ğ‘‚subscript~degreeğœ€superscriptğ‘“2O(\\widetilde{\\deg}_{\\varepsilon}(f)^{2}) without making assumptions.\nWe will discuss this in more detail in Section 4. Theorem 1.5 can be viewed as an analogy to the polynomial method for continuous functions of matrices. Recall that for a Boolean function fâ€‹(x1,â€¦,xn):{0,1}nâ†’{0,1}:ğ‘“subscriptğ‘¥1â€¦subscriptğ‘¥ğ‘›â†’superscript01ğ‘›01f(x_{1},\\ldots,x_{n}):\\{0,1\\}^{n}\\rightarrow\\{0,1\\}, given a quantum oracle to query xisubscriptğ‘¥ğ‘–x_{i} in superposition, it is known from the polynomial method that computing fâ€‹(x1,â€¦,xn)ğ‘“subscriptğ‘¥1â€¦subscriptğ‘¥ğ‘›f(x_{1},\\ldots,x_{n}) costs at least Î©â€‹(deg~Îµâ€‹(f))Î©subscript~degreeğœ€ğ‘“\\Omega(\\widetilde{\\deg}_{\\varepsilon}(f)) queries 4. Here deg~Îµâ€‹(f)subscript~degreeğœ€ğ‘“\\widetilde{\\deg}_{\\varepsilon}(f) is defined as the minimal degree of polynomial Pâ€‹(x1,â€¦,xn)ğ‘ƒsubscriptğ‘¥1â€¦subscriptğ‘¥ğ‘›P(x_{1},\\ldots,x_{n}) such that |Pâ€‹(x)âˆ’fâ€‹(x)|â‰¤Îµğ‘ƒğ‘¥ğ‘“ğ‘¥ğœ€|P(x)-f(x)|\\leq\\varepsilon and |Pâ€‹(x)|â‰¤1ğ‘ƒğ‘¥1|P(x)|\\leq 1 for all xâˆˆ{0,1}nğ‘¥superscript01ğ‘›x\\in\\{0,1\\}^{n}.\nThe polynomial method has been successful in proving certain tight lower bounds 4 .\nUnfortunately, for Boolean functions, the approximate degree is an imprecise measure of quantum query complexity. Namely, there exist total Boolean functions fğ‘“f such that deg~1/3â€‹(f)â‰¤nÎ±subscript~degree13ğ‘“superscriptğ‘›ğ›¼\\widetilde{\\deg}_{1/3}(f)\\leq n^{\\alpha} while the quantum query complexity of computing fğ‘“f is at least nÎ²superscriptğ‘›ğ›½n^{\\beta}, where Î±,Î²ğ›¼ğ›½\\alpha,\\beta are constants with Î²>Î±ğ›½ğ›¼\\beta>\\alpha, e.g., see  .\nFor functions of matrices, Theorems 1.5 and 1.7 indicate that up to a logarithmic term, the approximate degree characterises the quantum query complexity precisely when sâ€‹â€–Aâ€–max,Î´,Îµğ‘ subscriptnormğ´ğ›¿ğœ€s\\|A\\|_{\\max},\\delta,\\varepsilon are constants. For Problem 1.4, our main result in the classical case is described as follows. Let fâ€‹(x):[âˆ’1,1]â†’[âˆ’1,1]:ğ‘“ğ‘¥â†’1111f(x):[-1,1]\\rightarrow[-1,1] be a continuous function, then there exists a 4-sparse Hermitian matrix Ağ´A with â€–Aâ€–â‰¤1normğ´1\\|A\\|\\leq 1 and two indices i,jğ‘–ğ‘—i,j such that classical queries to Ağ´A are required in order to compute âŸ¨i|fâ€‹(A)|jâŸ©Â±Îµ/4plus-or-minusquantum-operator-productğ‘–ğ‘“ğ´ğ‘—ğœ€4\\langle i|f(A)|j\\rangle\\pm\\varepsilon/4. Combining Theorems 1.7 and 1.8, we can claim that for Problem 1.4, the quantum and classical separation is exponential in terms of the approximate degree for any continuous function. Recall that for functions like fâ€‹(x)=eiâ€‹xâ€‹t,xdğ‘“ğ‘¥superscriptğ‘’ğ‘–ğ‘¥ğ‘¡superscriptğ‘¥ğ‘‘f(x)=e^{ixt},x^{d}, the approximation of âŸ¨i|fâ€‹(A)|jâŸ©quantum-operator-productğ‘–ğ‘“ğ´ğ‘—\\langle i|f(A)|j\\rangle is BQP-complete  . Namely, they are believed to be hard to solve for classical computers. In Theorem 1.8, we provide a quantitative result on this hardness using query complexity. For example, if fâ€‹(x)=eiâ€‹xâ€‹tğ‘“ğ‘¥superscriptğ‘’ğ‘–ğ‘¥ğ‘¡f(x)=e^{ixt}, then deg~Îµâ€‹(f)=Î˜â€‹(t)subscript~degreeğœ€ğ‘“Î˜ğ‘¡\\widetilde{\\deg}_{\\varepsilon}(f)=\\Theta(t) when Îµ=Oâ€‹(1)ğœ€ğ‘‚1\\varepsilon=O(1) , so the classical lower bound we have is Î©â€‹(2t/6t)Î©superscript2ğ‘¡6ğ‘¡\\Omega(\\frac{2^{t/6}}{t}), while the quantum upper bound is just Oâ€‹(t)ğ‘‚ğ‘¡O(t). If fâ€‹(x)=xdğ‘“ğ‘¥superscriptğ‘¥ğ‘‘f(x)=x^{d}, then deg~Îµâ€‹(f)=Î˜â€‹(d)subscript~degreeğœ€ğ‘“Î˜ğ‘‘\\widetilde{\\deg}_{\\varepsilon}(f)=\\Theta(\\sqrt{d}) when Îµ=Oâ€‹(1)ğœ€ğ‘‚1\\varepsilon=O(1) , so the classical lower bound is Î©â€‹(2d/6d)Î©superscript2ğ‘‘6ğ‘‘\\Omega(\\frac{2^{\\sqrt{d}/6}}{\\sqrt{d}}), while the quantum upper bound is only Oâ€‹(d)ğ‘‚ğ‘‘O(\\sqrt{d}). Regarding classical algorithms for Problem 1.4, when fğ‘“f is a polynomial of degree dğ‘‘d, then there is an exact algorithm with query complexity Oâ€‹(sdâˆ’1)ğ‘‚superscriptğ‘ ğ‘‘1O(s^{d-1}) building on the definition of functions of matrices, where sğ‘ s is the sparsity. So for the situation of Theorem 1.8, this upper bound is Oâ€‹(22â€‹deg~Îµâ€‹(f))ğ‘‚superscript22subscript~degreeğœ€ğ‘“O(2^{2\\widetilde{\\deg}_{\\varepsilon}(f)}) as the sparsity is s=4ğ‘ 4s=4. This upper bound is not too far from the lower bound.\nIn Section 5, we also have two other classical algorithms for solving Problem 1.4, one is based on random walks, and the other one is based on the Cauchy integral formula.\nHere we state the result for the second algorithm, which is more efficient when fğ‘“f is analytic. Let Ağ´A be an sğ‘ s-sparse matrix with â€–Aâ€–1>â€–Aâ€–subscriptnormğ´1normğ´\\|A\\|_{1}>\\|A\\|.\nLet fâ€‹(z)ğ‘“ğ‘§f(z) be an analytic function in the disk |z|â‰¤Rğ‘§ğ‘…|z|\\leq R with R>â€–Aâ€–12/â€–Aâ€–ğ‘…superscriptsubscriptnormğ´12normğ´R>\\|A\\|_{1}^{2}/\\|A\\|. Then there is a classical algorithm that computes âŸ¨i|fâ€‹(A)|jâŸ©Â±Îµplus-or-minusquantum-operator-productğ‘–ğ‘“ğ´ğ‘—ğœ€\\langle i|f(A)|j\\rangle\\pm\\varepsilon in cost In the above complexity, the dominating term is M:=maxzâˆˆâ„‚,|z|=â€–Aâ€–1â¡|fâ€‹(z)|2assignğ‘€subscriptformulae-sequenceğ‘§â„‚ğ‘§subscriptnormğ´1superscriptğ‘“ğ‘§2M:=\\max_{z\\in\\mathbb{C},|z|=\\|A\\|_{1}}|f(z)|^{2}. This classical algorithm is efficient when this quantity is small. However, Mğ‘€M can be exponentially large when â€–Aâ€–1>1subscriptnormğ´11\\|A\\|_{1}>1 even if fğ‘“f is bounded by 1 in the interval [âˆ’1,1]11[-1,1]. For example, if fâ€‹(x)=sinâ¡(xâ€‹t)ğ‘“ğ‘¥ğ‘¥ğ‘¡f(x)=\\sin(xt), then M=Î˜â€‹(e2â€‹â€–Aâ€–1â€‹t)ğ‘€Î˜superscriptğ‘’2subscriptnormğ´1ğ‘¡M=\\Theta(e^{2\\|A\\|_{1}t}). If fâ€‹(x)=xdğ‘“ğ‘¥superscriptğ‘¥ğ‘‘f(x)=x^{d}, then M=â€–Aâ€–12â€‹dğ‘€superscriptsubscriptnormğ´12ğ‘‘M=\\|A\\|_{1}^{2d}. More generally, when fâ€‹(x)=âˆ‘k=0dakâ€‹xkğ‘“ğ‘¥superscriptsubscriptğ‘˜0ğ‘‘subscriptğ‘ğ‘˜superscriptğ‘¥ğ‘˜f(x)=\\sum_{k=0}^{d}a_{k}x^{k} is a polynomial of degree dğ‘‘d, the quantity Mğ‘€M can be as large as â€–Aâ€–12â€‹dsuperscriptsubscriptnormğ´12ğ‘‘\\|A\\|_{1}^{2d}. Note that â€–Aâ€–1â‰¤sâ€‹â€–Aâ€–subscriptnormğ´1ğ‘ normğ´\\|A\\|_{1}\\leq\\sqrt{s}\\|A\\|, so the above algorithm is usually more efficient than the exact algorithm. Finally, we remark that for total Boolean functions, it is known that the separation of quantum and classical query complexities is at most quartic [ref]3. Exponential separation only exists for some partial Boolean functions with certain structures. Our results show that for functions of sparse Hermitian matrices, the quantum and classical separation is exponential. Here a function of a sparse matrix can also be viewed as a partial function in some sense. This might provide an approach to finding partial Boolean functions that can demonstrate exponential separations.\n\nReference markers found: [3]\n\nContext windows for each [ref]:\n[ref]3: usually more efficient than the exact algorithm. Finally, we remark that for total Boolean functions, it is known that the separation of quantum and classical query complexities is at most quartic [ref]3. Exponential separation only exists for some partial Boolean functions with certain structures. Our results show that for functions of sparse Hermitian matrices, the quantum and classical\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 3,\n            \"titles\": [\n                \"Optimal-Degree Polynomial Approximations for Exponentials and Gaussian Kernel Density Estimation\",\n                \"Forrelation: A problem that optimally separates quantum from classical computing\",\n                \"Separations in query complexity using cheat sheets\",\n                \"Degree vs. approximate degree and quantum implications of Huangâ€™s sensitivity theorem\",\n                \"Tight bound for estimating expectation values from a system of linear equations\",\n                \"Polynomial degree vs. quantum query complexity\",\n                \"An exponential separation between quantum query complexity and the polynomial degree\",\n                \"A theory of quantum differential equation solvers: limitations and fast-forwarding\",\n                \"On Solving Linear Systems in Sublinear Time\",\n                \"Quantum SDP-Solvers: Better upper and lower bounds\",\n                \"A (simple) classical algorithm for estimating Betti numbers\",\n                \"Quantum Query Algorithms are Completely Bounded Forms\",\n                \"ğ‘˜-Forrelation Optimally Separates Quantum and Classical Query Complexity\",\n                \"Quantum lower bounds by polynomials\",\n                \"Strengths and weaknesses of quantum computing\",\n                \"Quantum complexity theory\",\n                \"Efficient quantum algorithms for simulating sparse Hamiltonians\",\n                \"Exponential improvement in precision for simulating sparse Hamiltonians\",\n                \"Approximate Degree in Classical and Quantum Computing\",\n                \"The Quantum Complexity of Computing Schatten ğ‘-norms\",\n                \"Linear programming\",\n                \"Rapid solution of problems by quantum computation\",\n                \"Limit on the speed of quantum computation in determining parity\",\n                \"Quantum singular value transformation and beyond: exponential improvements for quantum matrix arithmetics\",\n                \"Quantum algorithms for powering stable Hermitian matrices\",\n                \"A fast quantum mechanical algorithm for database search\",\n                \"Quantum algorithm for linear systems of equations\",\n                \"Functions of Matrices: Theory and Computation\",\n                \"On the construction of a Jacobi matrix from spectral data\",\n                \"Analysis of Numerical Methods\",\n                \"The Theory of Approximation, volumeÂ 11\",\n                \"BQP-complete problems concerning mixing properties of classical random walks on sparse graphs\",\n                \"Quantum lower bound for the collision problem with small range\",\n                \"On linear semi-infinite programming problems: An algorithm\",\n                \"Hamiltonian complexity\",\n                \"The Symmetric Eigenvalue Problem\",\n                \"Faster algorithms via approximation theory\",\n                \"Semi-infinite programming, duality, discretization and optimality conditions\",\n                \"Polynomial-time algorithms for prime factorization and discrete logarithms on a quantum computer\",\n                \"On the power of quantum computation\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]3 based on the context and research area of Quantum and classical query complexities of functions of matrices. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}