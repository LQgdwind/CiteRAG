{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: Relative Timing Information and Orthology in Evolutionary Scenarios\n\nPaper Abstract: \n\nPaper Section Text:\nIn , we derived an algorithmic approach that recognizes\nLDT graphs and constructs a relaxed scenario 𝒮𝒮\\mathscr{S} for (G<,σ)subscript𝐺𝜎(G_{{}_{<}},\\sigma) in\nthe positive case. Here, we adapt the algorithmic idea to the case that,\ninstead of (G<,σ)subscript𝐺𝜎(G_{{}_{<}},\\sigma), the graph 3-partition\n𝒢=(G<,G=,G>,σ)𝒢subscript𝐺subscript𝐺subscript𝐺𝜎\\mathscr{G}=(G_{{}_{<}},G_{{}_{=}},G_{{}_{>}},\\sigma) is given, see\nAlgorithm 1, which is illustrated in\nFigure 9. As we shall see, the additional\ninformation can be leveraged to separate the construction of S𝑆S and T𝑇T in\nsuch a way that a suitable species tree can be computed first using a\nwell-known approach. This then considerably simplifies the construction of\na corresponding gene tree T𝑇T. More precisely, we construct the gene tree\nand its reconciliation with S𝑆S in a top-down fashion via a recursive\ndecomposition of L𝐿L into subsets that is guided by 𝒢𝒢\\mathscr{G} and S𝑆S. We\nfirst introduce three auxiliary graphs that we will use for this purpose. Let 𝒢=(G<,G=,G>,σ)𝒢subscript𝐺subscript𝐺subscript𝐺𝜎\\mathscr{G}=(G_{{}_{<}},G_{{}_{=}},G_{{}_{>}},\\sigma) be a graph 333-partition on vertex\nset L𝐿L with coloring σ:L→M:𝜎→𝐿𝑀\\sigma\\colon L\\to M and S𝑆S be a tree on M𝑀M.\nFor L′⊆Lsuperscript𝐿′𝐿L^{\\prime}\\subseteq L and u∈V0​(S)𝑢superscript𝑉0𝑆u\\in V^{0}(S) such that\nσ​(L′)⊆L​(S​(u))𝜎superscript𝐿′𝐿𝑆𝑢\\sigma(L^{\\prime})\\subseteq L(S(u)), we define the auxiliary graphs on L′superscript𝐿′L^{\\prime}: By construction, H2subscript𝐻2H_{2} is a subgraph of H1subscript𝐻1H_{1}. In particular, therefore,\nevery connected component of H2subscript𝐻2H_{2} is entirely included in some connected\ncomponent of H1subscript𝐻1H_{1}. In turn, one easily verifies that the connected\ncomponents of H3subscript𝐻3H_{3} are complete graphs. Moreover, H3subscript𝐻3H_{3} contains all edges\nof H2∩G=subscript𝐻2subscript𝐺H_{2}\\cap G_{{}_{=}} while there might be edges of G<​[L′]subscript𝐺delimited-[]superscript𝐿′G_{{}_{<}}[L^{\\prime}] that are not\ncontained in H3subscript𝐻3H_{3}. This implies that every connected\ncomponent of H3subscript𝐻3H_{3} is entirely included in some connected\ncomponent of H2subscript𝐻2H_{2}. We use the inclusion relation of the connected components to construct the\nlocal topology of T𝑇T in a recursive manner, see\nFigure 10 for an illustration of the following\ndescription. In each step, i.e., for some L′⊆Lsuperscript𝐿′𝐿L^{\\prime}\\subseteq L and uS∈V​(S)subscript𝑢𝑆𝑉𝑆u_{S}\\in V(S), we first construct a “local root” ρ′superscript𝜌′\\rho^{\\prime}\n(cf. Algorithm 1, Line 6). If\nuSsubscript𝑢𝑆u_{S} is a leaf of S𝑆S (the base case of the recursion), we directly attach\nthe elements of L′superscript𝐿′L^{\\prime} as children of ρ′superscript𝜌′\\rho^{\\prime}\n(Lines 8-11). On the other\nhand, if uSsubscript𝑢𝑆u_{S} is an inner vertex, we create a new child of ρ′superscript𝜌′\\rho^{\\prime} for\neach connected component of H1subscript𝐻1H_{1} in Line 15. For a\nspecific connected component Cisubscript𝐶𝑖C_{i} of H1subscript𝐻1H_{1} (corresponding to child uisubscript𝑢𝑖u_{i}\nof ρ′superscript𝜌′\\rho^{\\prime}), we then add a new child vjsubscript𝑣𝑗v_{j} of uisubscript𝑢𝑖u_{i} for each connected\ncomponent Cjsubscript𝐶𝑗C_{j} of H2subscript𝐻2H_{2} such that Cj⊆Cisubscript𝐶𝑗subscript𝐶𝑖C_{j}\\subseteq C_{i} in Line\n18. We proceed similarly for the connected components\nCksubscript𝐶𝑘C_{k} of H3subscript𝐻3H_{3}, which necessarily are subsets of a specific connected\ncomponent Cjsubscript𝐶𝑗C_{j} of H2subscript𝐻2H_{2}. The vertex corresponding to Cksubscript𝐶𝑘C_{k} is the “local\nroot” created in a recursive call operating on Cksubscript𝐶𝑘C_{k} as new subset of L𝐿L\nand vS∈childS⁡(uS)subscript𝑣𝑆subscriptchild𝑆subscript𝑢𝑆v_{S}\\in\\operatorname{child}_{S}(u_{S}) as new vertex of S𝑆S, which is chosen such that\nσ​(Ck)⊆L​(S​(uS))𝜎subscript𝐶𝑘𝐿𝑆subscript𝑢𝑆\\sigma(C_{k})\\subseteq L(S(u_{S})) in Line\n22. If Cj=Cisubscript𝐶𝑗subscript𝐶𝑖C_{j}=C_{i} or Ck=Cjsubscript𝐶𝑘subscript𝐶𝑗C_{k}=C_{j}, then the\ncorresponding vertices visubscript𝑣𝑖v_{i} and vjsubscript𝑣𝑗v_{j}, respectively, have a single child.\nAs a consequence, the resulting tree T′superscript𝑇′T^{\\prime} is in general not\nphylogenetic. The final gene tree T𝑇T is then obtained by suppressing all\nvertices with a single child (Line 26). By definition, two vertices x𝑥x and y𝑦y are in the same connected component\nCksubscript𝐶𝑘C_{k} of the auxiliary graph H3subscript𝐻3H_{3} only if σ​(x)𝜎𝑥\\sigma(x) and σ​(y)𝜎𝑦\\sigma(y) are\ndescendants of the same child vSsubscript𝑣𝑆v_{S} of the species tree vertex uSsubscript𝑢𝑆u_{S}. In\nparticular, we therefore can always find vS∈childS⁡(uS)subscript𝑣𝑆subscriptchild𝑆subscript𝑢𝑆v_{S}\\in\\operatorname{child}_{S}(u_{S}) such that\nσ​(Ck)⊆L​(S​(vS))𝜎subscript𝐶𝑘𝐿𝑆subscript𝑣𝑆\\sigma(C_{k})\\subseteq L(S(v_{S})) in Line 22 of\nAlgorithm 1. This guarantees that all colors appearing on\nthe vertices in L′superscript𝐿′L^{\\prime} are descendants of the species tree vertex uSsubscript𝑢𝑆u_{S} in\neach recursion step: In every recursion step of Algorithm 1, it holds\nσ​(L′)⊆L​(S​(us))𝜎superscript𝐿′𝐿𝑆subscript𝑢𝑠\\sigma(L^{\\prime})\\subseteq L(S(u_{s})). In particular, the auxiliary graphs\nH1subscript𝐻1H_{1}, H2subscript𝐻2H_{2}, and H3subscript𝐻3H_{3} are always well-defined. The recursion in Algorithm 1 can be thought of as a\ntree with the root being the top-level call of BuildGeneTree on\nL𝐿L and ρSsubscript𝜌𝑆\\rho_{S} and leaves being the calls in which uSsubscript𝑢𝑆u_{S} is a leaf of\nS𝑆S. Note that, for some recursion steps R𝑅R on L′superscript𝐿′L^{\\prime} and uSsubscript𝑢𝑆u_{S}, all of its\n“descendant recursion steps” have input L′′superscript𝐿′′L^{\\prime\\prime} and uS′subscriptsuperscript𝑢′𝑆u^{\\prime}_{S} satisfying\nL′′⊆L′superscript𝐿′′superscript𝐿′L^{\\prime\\prime}\\subseteq L^{\\prime} and uS′≺SuSsubscriptprecedes𝑆subscriptsuperscript𝑢′𝑆subscript𝑢𝑆u^{\\prime}_{S}\\prec_{S}u_{S}. Therefore, and because all\nleaves that are descendants of ρ′superscript𝜌′\\rho^{\\prime} (created in R′superscript𝑅′R^{\\prime}) must have been\nattached in some descendant recursion step of R𝑅R, we have\nL​(T′​(ρ′))⊆L′𝐿superscript𝑇′superscript𝜌′superscript𝐿′L(T^{\\prime}(\\rho^{\\prime}))\\subseteq L^{\\prime}. In turn, all elements x∈L′𝑥superscript𝐿′x\\in L^{\\prime} are either\ndirectly attached to ρ′superscript𝜌′\\rho^{\\prime} if uSsubscript𝑢𝑆u_{S} is a leaf, or will eventually be\npassed down to a recursion step on a leaf l≺SuSsubscriptprecedes𝑆𝑙subscript𝑢𝑆l\\prec_{S}u_{S} because each\nx∈L′𝑥superscript𝐿′x\\in L^{\\prime} is in some connected component Cksubscript𝐶𝑘C_{k} of H3subscript𝐻3H_{3}, Cksubscript𝐶𝑘C_{k} is entirely\nincluded in a connected component Cjsubscript𝐶𝑗C_{j} of H2subscript𝐻2H_{2}, and Cjsubscript𝐶𝑗C_{j} is entirely\nincluded in a connected component Cisubscript𝐶𝑖C_{i} of H1subscript𝐻1H_{1}. In this “leaf recursion\nstep”, x𝑥x is therefore attached to some descendant of ρ′superscript𝜌′\\rho^{\\prime}, implying\nL′⊆L​(T′​(ρ′))superscript𝐿′𝐿superscript𝑇′superscript𝜌′L^{\\prime}\\subseteq L(T^{\\prime}(\\rho^{\\prime})). Therefore, we have L′=L​(T′​(ρ′))superscript𝐿′𝐿superscript𝑇′superscript𝜌′L^{\\prime}=L(T^{\\prime}(\\rho^{\\prime})). We can\napply very similar arguments to see that L​(T′​(ui))=Ci𝐿superscript𝑇′subscript𝑢𝑖subscript𝐶𝑖L(T^{\\prime}(u_{i}))=C_{i} and\nL​(T′​(vj))=Cj𝐿superscript𝑇′subscript𝑣𝑗subscript𝐶𝑗L(T^{\\prime}(v_{j}))=C_{j} hold for each connected component Cisubscript𝐶𝑖C_{i} of H1subscript𝐻1H_{1} and Cjsubscript𝐶𝑗C_{j}\nof H2subscript𝐻2H_{2} with corresponding vertices uisubscript𝑢𝑖u_{i} and vjsubscript𝑣𝑗v_{j} created in\nLines 15 and 18, respectively.\nClearly, contraction of the redundant vertices to obtain the final tree T𝑇T\ndoes not change these relationship. We summarize these considerations as\nfollows: Let T𝑇T be a tree returned by Algorithm 1 and u∈V0​(T)𝑢superscript𝑉0𝑇u\\in V^{0}(T) be an inner vertex created in a recursion step on L′superscript𝐿′L^{\\prime} and uSsubscript𝑢𝑆u_{S}. If u𝑢u is a vertex ρ′superscript𝜌′\\rho^{\\prime} created in Line 6,\nthen L​(T​(u))=L′𝐿𝑇𝑢superscript𝐿′L(T(u))=L^{\\prime}. If u𝑢u is a vertex uisubscript𝑢𝑖u_{i} created in Line 15,\nthen L​(T​(u))=Ci𝐿𝑇𝑢subscript𝐶𝑖L(T(u))=C_{i} where Cisubscript𝐶𝑖C_{i} is the connected component of H1subscript𝐻1H_{1}\ncorresponding to uisubscript𝑢𝑖u_{i}. If u𝑢u is a vertex vjsubscript𝑣𝑗v_{j} created in Line 18,\nthen L​(T​(u))=Cj𝐿𝑇𝑢subscript𝐶𝑗L(T(u))=C_{j} where Cjsubscript𝐶𝑗C_{j} is the connected component of H2subscript𝐻2H_{2}\ncorresponding to vjsubscript𝑣𝑗v_{j}. In particular, every x∈L​(T​(u))𝑥𝐿𝑇𝑢x\\in L(T(u)) satisfies x∈L′𝑥superscript𝐿′x\\in L^{\\prime}. Algorithm 1 is a generalization of the\nalgorithm presented in  for the construction of a\nrelaxed scenario 𝒮𝒮\\mathscr{S} for a given LDT graph (G,σ)𝐺𝜎(G,\\sigma). A key property\nof the algorithm is that the restriction of 𝒮𝒮\\mathscr{S} to S​(uS)𝑆subscript𝑢𝑆S(u_{S}), i.e., the\nincomplete scenarios obtained for given uSsubscript𝑢𝑆u_{S} satisfies the time\nconsistency constraints (S2) and (S3). The construction of 𝒮𝒮\\mathscr{S}\nin Algorithm 1 differs from the procedure described in\n only by including in V​(T)∖(L​(T)∪{0T})𝑉𝑇𝐿𝑇subscript0𝑇V(T)\\setminus(L(T)\\cup\\{0_{T}\\}) the additional vertices uisubscript𝑢𝑖u_{i} created in\nLine 15. These satisfy μ​(ui)=uS𝜇subscript𝑢𝑖subscript𝑢𝑆\\mu(u_{i})=u_{S}. In the following\nline, we set τT​(ui)←τS​(uS)←subscript𝜏𝑇subscript𝑢𝑖subscript𝜏𝑆subscript𝑢𝑆\\tau_{T}(u_{i})\\leftarrow\\tau_{S}(u_{S}). Hence, constraint (S2)\nremains satisfied and (S3) is void because μ​(ui)∈V​(S)𝜇subscript𝑢𝑖𝑉𝑆\\mu(u_{i})\\in V(S). One\neasily checks, furthermore, that the reconciliation map μ𝜇\\mu constructed\nin Algorithm 1 satisfies (S0)\n(Line 27) and (S1)\n(Line 11). 𝒢=(G<,G=,G>,σ)𝒢subscript𝐺subscript𝐺subscript𝐺𝜎\\mathscr{G}=(G_{{}_{<}},G_{{}_{=}},G_{{}_{>}},\\sigma) is a valid input for\nAlgorithm 1 if (G<,G=,G>,σ)subscript𝐺subscript𝐺subscript𝐺𝜎(G_{{}_{<}},G_{{}_{=}},G_{{}_{>}},\\sigma) is a\n3-partition, G<subscript𝐺G_{{}_{<}} and G=subscript𝐺G_{{}_{=}} are properly colored, G<subscript𝐺G_{{}_{<}} and G>subscript𝐺G_{{}_{>}} are\ncographs, and (ℛS​(𝒢),ℱS​(𝒢))subscriptℛ𝑆𝒢subscriptℱ𝑆𝒢(\\mathscr{R}_{S}(\\mathscr{G}),\\mathscr{F}_{S}(\\mathscr{G})) is consistent. Given a valid input 𝒢=(G<,G=,G>,σ)𝒢subscript𝐺subscript𝐺subscript𝐺𝜎\\mathscr{G}=(G_{{}_{<}},G_{{}_{=}},G_{{}_{>}},\\sigma) with vertex set\nL𝐿L, Algorithm 1 returns a relaxed scenario\n𝒮=(T,S,σ,μ,τT,τS)𝒮𝑇𝑆𝜎𝜇subscript𝜏𝑇subscript𝜏𝑆\\mathscr{S}=(T,S,\\sigma,\\mu,\\tau_{T},\\tau_{S}) such that L​(T)=L𝐿𝑇𝐿L(T)=L. In order to keep this contribution self-contained, a detailed proof\nof Lemma 23, which largely parallels the material in\n, is given in Appendix Proof of Lemma 23.\n∎ We continue with a number of intermediate results that we will need to\nestablish the correctness of Algorithm 1. Let 𝒢=(G<,G=,G>,σ)𝒢subscript𝐺subscript𝐺subscript𝐺𝜎\\mathscr{G}=(G_{{}_{<}},G_{{}_{=}},G_{{}_{>}},\\sigma) with vertex set L𝐿L be a valid input\nfor Algorithm 1. Consider a recursion step on\nL′⊆Lsuperscript𝐿′𝐿L^{\\prime}\\subseteq L and uS∈V0​(S)subscript𝑢𝑆superscript𝑉0𝑆u_{S}\\in V^{0}(S) of\nAlgorithm 1. Then there are no x,y∈L′𝑥𝑦superscript𝐿′x,y\\in L^{\\prime} in the\nsame connected component of H1subscript𝐻1H_{1} such that x​y∈E​(G>)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{>}}) and\nlcaS⁡(σ​(x),σ​(y))=uSsubscriptlca𝑆𝜎𝑥𝜎𝑦subscript𝑢𝑆\\operatorname{lca}_{S}(\\sigma(x),\\sigma(y))=u_{S}. Assume for contradiction that, for some L′superscript𝐿′L^{\\prime} and uS∈V0​(S)subscript𝑢𝑆superscript𝑉0𝑆u_{S}\\in V^{0}(S)\nappearing in the recursion, there is a connected component Cisubscript𝐶𝑖C_{i} of H1subscript𝐻1H_{1}\nwith vertices x,y∈Ci𝑥𝑦subscript𝐶𝑖x,y\\in C_{i} and colors X≔σ​(x)≔𝑋𝜎𝑥X\\coloneqq\\sigma(x) and\nY≔σ​(y)≔𝑌𝜎𝑦Y\\coloneqq\\sigma(y) such that x​y∈E​(G>)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{>}}) and lcaS⁡(X,Y)=uSsubscriptlca𝑆𝑋𝑌subscript𝑢𝑆\\operatorname{lca}_{S}(X,Y)=u_{S}. By\nassumption, uSsubscript𝑢𝑆u_{S} is an interior vertex and thus X≠Y𝑋𝑌X\\neq Y. Since the\ninput G>subscript𝐺G_{{}_{>}} is a cograph, the induced subgraph G>​[L′]subscript𝐺delimited-[]superscript𝐿′G_{{}_{>}}[L^{\\prime}] and its\ncomplement, which by construction equals H1=G<​[L′]∪G=​[L′]subscript𝐻1subscript𝐺delimited-[]superscript𝐿′subscript𝐺delimited-[]superscript𝐿′H_{1}=G_{{}_{<}}[L^{\\prime}]\\cup G_{{}_{=}}[L^{\\prime}], are\nalso cographs (cf. Prop. 1). Consider a shortest path P𝑃P in H1subscript𝐻1H_{1} connecting x𝑥x and y𝑦y, which\nexists since x,y∈Ci𝑥𝑦subscript𝐶𝑖x,y\\in C_{i}. Since G>​[L′]subscript𝐺delimited-[]superscript𝐿′G_{{}_{>}}[L^{\\prime}] and H1subscript𝐻1H_{1} are edge-disjoint\nand x​y∈E​(G>​[L′])𝑥𝑦𝐸subscript𝐺delimited-[]superscript𝐿′xy\\in E(G_{{}_{>}}[L^{\\prime}]), P𝑃P contains at least 333 vertices. Since H1subscript𝐻1H_{1}\nis a cograph and thus does not contain induced P4subscript𝑃4P_{4}s, P𝑃P contains at\nmost 333 vertices. Hence, P𝑃P is of the form x−z−y𝑥𝑧𝑦x-z-y and we have x​y∈E​(G>)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{>}}) and x​z,y​z∉E​(G>)𝑥𝑧𝑦𝑧𝐸subscript𝐺xz,yz\\notin E(G_{{}_{>}}). Therefore, and since G<subscript𝐺G_{{}_{<}} and G=subscript𝐺G_{{}_{=}}\nare properly colored, we have Z≔σ​(z)∉{X,Y}≔𝑍𝜎𝑧𝑋𝑌Z\\coloneqq\\sigma(z)\\notin\\{X,Y\\}, and\nthus X,Y,Z𝑋𝑌𝑍X,Y,Z are pairwise distinct colors. By Prop. 2,\nX​Y|Z∈ℛS​(𝒢)conditional𝑋𝑌𝑍subscriptℛ𝑆𝒢XY|Z\\in\\mathscr{R}_{S}(\\mathscr{G}). Taken together, the latter arguments and the\nconstruction of S𝑆S in Line 1 imply that S𝑆S displays the\ninformative triple X​Y|Zconditional𝑋𝑌𝑍XY|Z. Since x,y,z∈L′𝑥𝑦𝑧superscript𝐿′x,y,z\\in L^{\\prime}, we have X,Y,Z∈L​(S​(us))𝑋𝑌𝑍𝐿𝑆subscript𝑢𝑠X,Y,Z\\in L(S(u_{s})) by Obs. 2. In particular, therefore,\nZ⪯SuSsubscriptprecedes-or-equals𝑆𝑍subscript𝑢𝑆Z\\preceq_{S}u_{S}. Thus X​Y|Zconditional𝑋𝑌𝑍XY|Z implies that lcaS⁡(X,Y)≺SuSsubscriptprecedes𝑆subscriptlca𝑆𝑋𝑌subscript𝑢𝑆\\operatorname{lca}_{S}(X,Y)\\prec_{S}u_{S}; a\ncontradiction.\n∎ Let 𝒢=(G<,G=,G>,σ)𝒢subscript𝐺subscript𝐺subscript𝐺𝜎\\mathscr{G}=(G_{{}_{<}},G_{{}_{=}},G_{{}_{>}},\\sigma) with vertex set L𝐿L be a valid input\nfor Algorithm 1. Consider a recursion step on\nL′⊆Lsuperscript𝐿′𝐿L^{\\prime}\\subseteq L and uS∈V0​(S)subscript𝑢𝑆superscript𝑉0𝑆u_{S}\\in V^{0}(S) of\nAlgorithm 1. Then, for all x,y∈L′𝑥𝑦superscript𝐿′x,y\\in L^{\\prime} that are\ncontained in the same connected component of H2subscript𝐻2H_{2} but in distinct\nconnected components of H3subscript𝐻3H_{3}, it holds x​y∈E​(G<)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{<}}). Suppose that, for some L′superscript𝐿′L^{\\prime} and uS∈V0​(S)subscript𝑢𝑆superscript𝑉0𝑆u_{S}\\in V^{0}(S) appearing in the\nrecursion, there is a connected component Cjsubscript𝐶𝑗C_{j} of H2subscript𝐻2H_{2} with x,y∈Cj𝑥𝑦subscript𝐶𝑗x,y\\in C_{j} such that x𝑥x and y𝑦y are in distinct connected components of H3subscript𝐻3H_{3}.\nIn addition, suppose for contradiction that x​y∉E​(G<)𝑥𝑦𝐸subscript𝐺xy\\notin E(G_{{}_{<}}). We may\nassume w.l.o.g. that x𝑥x and y𝑦y have minimal distance in H2subscript𝐻2H_{2}, i.e.,\nthere are no vertices x′,y′∈Cjsuperscript𝑥′superscript𝑦′subscript𝐶𝑗x^{\\prime},y^{\\prime}\\in C_{j} such that x′superscript𝑥′x^{\\prime} and y′superscript𝑦′y^{\\prime} are in\ndistinct connected components of H3subscript𝐻3H_{3}, x′​y′∉E​(G<)superscript𝑥′superscript𝑦′𝐸subscript𝐺x^{\\prime}y^{\\prime}\\notin E(G_{{}_{<}}), and in\naddition the distance of x′superscript𝑥′x^{\\prime} and y′superscript𝑦′y^{\\prime} in H2subscript𝐻2H_{2} is smaller than that of\nx𝑥x and y𝑦y. Set X≔σ​(x)≔𝑋𝜎𝑥X\\coloneqq\\sigma(x) and Y≔σ​(y)≔𝑌𝜎𝑦Y\\coloneqq\\sigma(y) and\nlet Cxsubscript𝐶𝑥C_{x} and Cysubscript𝐶𝑦C_{y} be the connected components of H3subscript𝐻3H_{3} that contain x𝑥x\nand y𝑦y, respectively. By Obs. 2, we have\nσ​(L′)⊆L​(S​(uS))𝜎superscript𝐿′𝐿𝑆subscript𝑢𝑆\\sigma(L^{\\prime})\\subseteq L(S(u_{S})). This and the fact that x𝑥x and y𝑦y are\nin distinct connected components of H3subscript𝐻3H_{3} but in the same connected\ncomponent Cjsubscript𝐶𝑗C_{j} of H2subscript𝐻2H_{2} implies that X⪯SvXsubscriptprecedes-or-equals𝑆𝑋subscript𝑣𝑋X\\preceq_{S}v_{X} and Y⪯SvYsubscriptprecedes-or-equals𝑆𝑌subscript𝑣𝑌Y\\preceq_{S}v_{Y} for two distinct children vX,vY∈childS⁡(uS)subscript𝑣𝑋subscript𝑣𝑌subscriptchild𝑆subscript𝑢𝑆v_{X},v_{Y}\\in\\operatorname{child}_{S}(u_{S}). In\nparticular, we have X≠Y𝑋𝑌X\\neq Y and lcaS⁡(X,Y)=uSsubscriptlca𝑆𝑋𝑌subscript𝑢𝑆\\operatorname{lca}_{S}(X,Y)=u_{S}. Moreover, by\nconstruction, every connected component of H2subscript𝐻2H_{2} is contained in a\nconnected component of H1subscript𝐻1H_{1} and thus, x𝑥x and y𝑦y are in the same\nconnected component of H1subscript𝐻1H_{1}. The latter two arguments together with\nLemma 24 imply x​y∉E​(G>)𝑥𝑦𝐸subscript𝐺xy\\notin E(G_{{}_{>}}). In summary, we\ntherefore have x​y∈E​(G=)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{=}}). Consider a shortest path P𝑃P connecting x𝑥x and y𝑦y in H2subscript𝐻2H_{2}, which\nexists since x,y∈Cj𝑥𝑦subscript𝐶𝑗x,y\\in C_{j}. By construction, x​y∈E​(G=)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{=}}) and\nlcaS⁡(X,Y)=uSsubscriptlca𝑆𝑋𝑌subscript𝑢𝑆\\operatorname{lca}_{S}(X,Y)=u_{S} imply that x​y∉E​(H2)𝑥𝑦𝐸subscript𝐻2xy\\notin E(H_{2}) and thus P𝑃P contains at\nleast 333 vertices. Let z∈Cj∖{x,y}𝑧subscript𝐶𝑗𝑥𝑦z\\in C_{j}\\setminus\\{x,y\\} be the neighbor of\nx𝑥x in P𝑃P. We consider the two possibilities (a) x​z∈E​(G=)𝑥𝑧𝐸subscript𝐺xz\\in E(G_{{}_{=}}) and (b)\nx​z∈E​(G<)𝑥𝑧𝐸subscript𝐺xz\\in E(G_{{}_{<}}). Note that X≠σ​(z)≕Z𝑋𝜎𝑧≕𝑍X\\neq\\sigma(z)\\eqqcolon Z holds in both\ncases since G=subscript𝐺G_{{}_{=}} and G<subscript𝐺G_{{}_{<}} are properly colored. In Case (a), we must have Z⪯SvXsubscriptprecedes-or-equals𝑆𝑍subscript𝑣𝑋Z\\preceq_{S}v_{X} since x​z𝑥𝑧xz is an edge in\nH2subscript𝐻2H_{2}. This implies that Z≠Y𝑍𝑌Z\\neq Y (and thus X,Y,Z𝑋𝑌𝑍X,Y,Z are pairwise\ndistinct) and lcaS⁡(Y,Z)=uSsubscriptlca𝑆𝑌𝑍subscript𝑢𝑆\\operatorname{lca}_{S}(Y,Z)=u_{S}. Based on the latter arguments, S𝑆S must\ndisplay the triple X​Z|Yconditional𝑋𝑍𝑌XZ|Y. Suppose that y​z∉E​(G=)𝑦𝑧𝐸subscript𝐺yz\\notin E(G_{{}_{=}}). Together\nwith x​y,x​z∈E​(G=)𝑥𝑦𝑥𝑧𝐸subscript𝐺xy,xz\\in E(G_{{}_{=}}), we have X​Z|Y∈ℱSconditional𝑋𝑍𝑌subscriptℱ𝑆XZ|Y\\in\\mathscr{F}_{S} and thus, by\nconstruction of S𝑆S in Line 1, S𝑆S cannot display X​Z|Yconditional𝑋𝑍𝑌XZ|Y;\na contradiction. Hence, y​z∈E​(G=)𝑦𝑧𝐸subscript𝐺yz\\in E(G_{{}_{=}}) must hold. Since Z⪯SvXsubscriptprecedes-or-equals𝑆𝑍subscript𝑣𝑋Z\\preceq_{S}v_{X} and Y⪯SvYsubscriptprecedes-or-equals𝑆𝑌subscript𝑣𝑌Y\\preceq_{S}v_{Y}, we have y​z∉E​(H3)𝑦𝑧𝐸subscript𝐻3yz\\notin E(H_{3}). Note that connected\ncomponents in H3subscript𝐻3H_{3} are complete graphs. Hence, y​z∉E​(H3)𝑦𝑧𝐸subscript𝐻3yz\\notin E(H_{3}) implies\nthat y𝑦y and z𝑧z are in distinct connected components of H3subscript𝐻3H_{3}. However,\nthe distance of y𝑦y and z𝑧z in H2subscript𝐻2H_{2} is strictly smaller than that of x𝑥x\nand y𝑦y (because z𝑧z is closer to y𝑦y than x𝑥x in the shortest path P𝑃P);\na contradiction to our choice of x𝑥x and y𝑦y. In summary, Case (a)\ntherefore cannot occur. In Case (b) we have x​z∈E​(G<)𝑥𝑧𝐸subscript𝐺xz\\in E(G_{{}_{<}}). If y​z∈E​(G<)𝑦𝑧𝐸subscript𝐺yz\\in E(G_{{}_{<}}), then Y≠Z𝑌𝑍Y\\neq Z\n(because G<subscript𝐺G_{{}_{<}} is properly colored) and, by definition, X​Y|Z∈ℛSconditional𝑋𝑌𝑍subscriptℛ𝑆XY|Z\\in\\mathscr{R}_{S}. By construction in Line 1, the species tree S𝑆S\ndisplays X​Y|Zconditional𝑋𝑌𝑍XY|Z. Together with X,Y,Z∈L​(S​(uS))𝑋𝑌𝑍𝐿𝑆subscript𝑢𝑆X,Y,Z\\in L(S(u_{S})) by\nObs. 2, this contradicts that lcaS⁡(X,Y)=uSsubscriptlca𝑆𝑋𝑌subscript𝑢𝑆\\operatorname{lca}_{S}(X,Y)=u_{S}.\nSimilarly, if y​z∈E​(G=)𝑦𝑧𝐸subscript𝐺yz\\in E(G_{{}_{=}}), then S𝑆S displays neither of the forbidden\ntriples X​Y|Zconditional𝑋𝑌𝑍XY|Z and Y​Z|Xconditional𝑌𝑍𝑋YZ|X. Hence, S𝑆S displays X​Z|Yconditional𝑋𝑍𝑌XZ|Y or\nS|XYZS_{|XYZ} is the star tree on the three colors. In both cases, we\nhave lcaS⁡(Y,Z)=lcaS⁡(X,Y)=uSsubscriptlca𝑆𝑌𝑍subscriptlca𝑆𝑋𝑌subscript𝑢𝑆\\operatorname{lca}_{S}(Y,Z)=\\operatorname{lca}_{S}(X,Y)=u_{S}. In particular, therefore y𝑦y and z𝑧z\nare in distinct connected components of H3subscript𝐻3H_{3}. As argued before, the\ndistance of y𝑦y and z𝑧z is smaller than that of x𝑥x and y𝑦y. Taken\ntogether the latter arguments again contradict our choice of x𝑥x and y𝑦y,\nand thus y​z∈E​(G>)𝑦𝑧𝐸subscript𝐺yz\\in E(G_{{}_{>}}) is left as the only remaining choice. In summary, only case (b) x​z∈E​(G<)𝑥𝑧𝐸subscript𝐺xz\\in E(G_{{}_{<}}) is possible, which in particular\nimplies y​z∈E​(G>)𝑦𝑧𝐸subscript𝐺yz\\in E(G_{{}_{>}}). Therefore, we have y​z∉E​(H2)𝑦𝑧𝐸subscript𝐻2yz\\notin E(H_{2}) and thus the\npath P𝑃P contains at least 444 vertices. Thus, consider the neighbor\nw∈Cj∖{x,y,z}𝑤subscript𝐶𝑗𝑥𝑦𝑧w\\in C_{j}\\setminus\\{x,y,z\\} of y𝑦y in P𝑃P and set W≔σ​(w)≔𝑊𝜎𝑤W\\coloneqq\\sigma(w). We can apply analogous arguments for x,y,w𝑥𝑦𝑤x,y,w as we have used\nfor x,y,z𝑥𝑦𝑧x,y,z to exclude the case (a’) y​w∈E​(G=)𝑦𝑤𝐸subscript𝐺yw\\in E(G_{{}_{=}}) and, in case (b’)\ny​w∈E​(G<)𝑦𝑤𝐸subscript𝐺yw\\in E(G_{{}_{<}}), we obtain x​w∈E​(G>)𝑥𝑤𝐸subscript𝐺xw\\in E(G_{{}_{>}}) as the only possibility. Taking the latter arguments together, it remains to consider the case x​y∈E​(G=)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{=}}), x​z,y​w∈E​(G<)𝑥𝑧𝑦𝑤𝐸subscript𝐺xz,yw\\in E(G_{{}_{<}}), and x​w,y​z∈E​(G>)𝑥𝑤𝑦𝑧𝐸subscript𝐺xw,yz\\in E(G_{{}_{>}}). Since G<subscript𝐺G_{{}_{<}} and\nG>subscript𝐺G_{{}_{>}} are cographs, we have z​w∈E​(G=)𝑧𝑤𝐸subscript𝐺zw\\in E(G_{{}_{=}}) because otherwise x−z−w−y𝑥𝑧𝑤𝑦x-z-w-y or\nx−w−z−y𝑥𝑤𝑧𝑦x-w-z-y would be an induced P4subscript𝑃4P_{4} in G<subscript𝐺G_{{}_{<}} and G>subscript𝐺G_{{}_{>}}, respectively. Now, x𝑥x and w𝑤w must be in the same connected component of H3subscript𝐻3H_{3}, as\notherwise x​w∉E​(G<)𝑥𝑤𝐸subscript𝐺xw\\notin E(G_{<}) and the fact that x𝑥x and w𝑤w are at a\nshorter distance than x𝑥x and y𝑦y in H2subscript𝐻2H_{2} would contradict our choice of\nx𝑥x and y𝑦y. Likewise, y𝑦y and z𝑧z are in the same connected component\nof H3subscript𝐻3H_{3} since y​z∉E​(G<)𝑦𝑧𝐸subscript𝐺yz\\notin E(G_{<}) and they are closer than x𝑥x and y𝑦y in\nH2subscript𝐻2H_{2}. It follows that w𝑤w and z𝑧z are in distinct connected components\nof H3subscript𝐻3H_{3}, again yielding a contradiction since they are closer than x𝑥x\nand y𝑦y in H2subscript𝐻2H_{2} and w​z∉E​(G<)𝑤𝑧𝐸subscript𝐺wz\\notin E(G_{<}). In summary, therefore, we have\nx​y∈E​(G<)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{<}}).\n∎ The following result is a consequence of Lemma 25\nand will be helpful later on. Let 𝒢=(G<,G=,G>,σ)𝒢subscript𝐺subscript𝐺subscript𝐺𝜎\\mathscr{G}=(G_{{}_{<}},G_{{}_{=}},G_{{}_{>}},\\sigma) with vertex set L𝐿L be a valid\ninput for Algorithm 1. Consider a recursion step on\nL′⊆Lsuperscript𝐿′𝐿L^{\\prime}\\subseteq L and uS∈V0​(S)subscript𝑢𝑆superscript𝑉0𝑆u_{S}\\in V^{0}(S) of\nAlgorithm 1. If x​y∈E​(H1)∖E​(H2)𝑥𝑦𝐸subscript𝐻1𝐸subscript𝐻2xy\\in E(H_{1})\\setminus E(H_{2}), then\nx𝑥x and y𝑦y are in distinct connected components of H2subscript𝐻2H_{2}. Suppose x​y∈E​(H1)∖E​(H2)𝑥𝑦𝐸subscript𝐻1𝐸subscript𝐻2xy\\in E(H_{1})\\setminus E(H_{2}). By construction of the auxiliary\ngraphs, this implies that x​y∈E​(G=)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{=}}) and there is no v∈childS⁡(uS)𝑣subscriptchild𝑆subscript𝑢𝑆v\\in\\operatorname{child}_{S}(u_{S}) such that σ​(x),σ​(y)≺Svsubscriptprecedes𝑆𝜎𝑥𝜎𝑦𝑣\\sigma(x),\\sigma(y)\\prec_{S}v. The latter\nin particular yields that x​y∉E​(H3)𝑥𝑦𝐸subscript𝐻3xy\\notin E(H_{3}). This, together with the\nfact that H3subscript𝐻3H_{3} is a graph whose connected components are complete\ngraphs, implies that x𝑥x and y𝑦y are in distinct connected components of\nH3subscript𝐻3H_{3}. We can now use Lemma 25 to conclude that\nx𝑥x and y𝑦y must also be in distinct connected components of H2subscript𝐻2H_{2} as\notherwise we would obtain x​y∈E​(G<)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{<}}); a contradiction.\n∎ We are now in the position to demonstrate that Algorithm 1\nis correct. Let 𝒢𝒢\\mathscr{G} be a valid input for\nAlgorithm 1. Then, Algorithm 1\nreturns a relaxed scenario 𝒮=(T,S,σ,μ,τT,τS)𝒮𝑇𝑆𝜎𝜇subscript𝜏𝑇subscript𝜏𝑆\\mathscr{S}=(T,S,\\sigma,\\mu,\\tau_{T},\\tau_{S}) that explains\n𝒢𝒢\\mathscr{G}. Let 𝒢=(G<,G=,G>,σ)𝒢subscript𝐺subscript𝐺subscript𝐺𝜎\\mathscr{G}=(G_{{}_{<}},G_{{}_{=}},G_{{}_{>}},\\sigma) be a valid input with vertex set L𝐿L\nfor Algorithm 1. By Lemma 23,\nAlgorithm 1 returns a relaxed scenario\n𝒮=(T,S,σ,μ,τT,τS)𝒮𝑇𝑆𝜎𝜇subscript𝜏𝑇subscript𝜏𝑆\\mathscr{S}=(T,S,\\sigma,\\mu,\\tau_{T},\\tau_{S}) such that L​(T)=L𝐿𝑇𝐿L(T)=L.\nWe continue with showing that 𝒮𝒮\\mathscr{S} explains 𝒢𝒢\\mathscr{G}. Consider two distinct vertices x,y∈L=L​(T)𝑥𝑦𝐿𝐿𝑇x,y\\in L=L(T) and their last common\nancestor lcaT⁡(x,y)subscriptlca𝑇𝑥𝑦\\operatorname{lca}_{T}(x,y). Let L′⊆Lsuperscript𝐿′𝐿L^{\\prime}\\subseteq L and uS∈V​(S)subscript𝑢𝑆𝑉𝑆u_{S}\\in V(S) be the\ninput of the recursive call of BuildGeneTree in which\nlcaT⁡(x,y)subscriptlca𝑇𝑥𝑦\\operatorname{lca}_{T}(x,y) was created. By Obs. 2\nand 3, we have σ​(L′)⊆L​(S​(us))𝜎superscript𝐿′𝐿𝑆subscript𝑢𝑠\\sigma(L^{\\prime})\\subseteq L(S(u_{s})) and\nx,y∈L′𝑥𝑦superscript𝐿′x,y\\in L^{\\prime}, respectively, and therefore lcaS⁡(σ​(x),σ​(y))⪯SuSsubscriptprecedes-or-equals𝑆subscriptlca𝑆𝜎𝑥𝜎𝑦subscript𝑢𝑆\\operatorname{lca}_{S}(\\sigma(x),\\sigma(y))\\preceq_{S}u_{S}. Moreover, time consistency yields τS​(lcaS⁡(σ​(x),σ​(y)))≤τS​(uS)subscript𝜏𝑆subscriptlca𝑆𝜎𝑥𝜎𝑦subscript𝜏𝑆subscript𝑢𝑆\\tau_{S}(\\operatorname{lca}_{S}(\\sigma(x),\\sigma(y)))\\leq\\tau_{S}(u_{S}). The vertex lcaT⁡(x,y)subscriptlca𝑇𝑥𝑦\\operatorname{lca}_{T}(x,y) has been created in\nexactly one of the following three locations in the algorithm: (a) in\nLine 6, (b) in Line 15, and (c) in\nLine 18. In Case (a), lcaT⁡(x,y)subscriptlca𝑇𝑥𝑦\\operatorname{lca}_{T}(x,y) equals ρ′superscript𝜌′\\rho^{\\prime} in the recursion step of\ninterest. Suppose first that uSsubscript𝑢𝑆u_{S} is a leaf of S𝑆S and thus\nσ​(x)=σ​(y)=uS𝜎𝑥𝜎𝑦subscript𝑢𝑆\\sigma(x)=\\sigma(y)=u_{S}. Hence, we have x​y∈E​(G>​(𝒮))𝑥𝑦𝐸subscript𝐺𝒮xy\\in E(G_{{}_{>}}(\\mathscr{S})) by\nCor. 1 and x​y∈E​(G>)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{>}}), since G<subscript𝐺G_{{}_{<}} and G=subscript𝐺G_{{}_{=}} are\nproperly colored. Now suppose that uSsubscript𝑢𝑆u_{S} is not a leaf. Then\nlcaT⁡(x,y)=ρ′subscriptlca𝑇𝑥𝑦superscript𝜌′\\operatorname{lca}_{T}(x,y)=\\rho^{\\prime} implies that x𝑥x and y𝑦y lie in distinct connected\ncomponents of the auxiliary graph H1subscript𝐻1H_{1} and thus x​y∉E​(H1)𝑥𝑦𝐸subscript𝐻1xy\\notin E(H_{1}). By\nconstruction of this graph, the latter yields x​y∈E​(G>)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{>}}). Moreover,\nwe have set τT​(ρ′)=τS​(uS)+ϵ>τS​(uS)subscript𝜏𝑇superscript𝜌′subscript𝜏𝑆subscript𝑢𝑆italic-ϵsubscript𝜏𝑆subscript𝑢𝑆\\tau_{T}(\\rho^{\\prime})=\\tau_{S}(u_{S})+\\epsilon>\\tau_{S}(u_{S}). Together with\nlcaT⁡(x,y)=ρ′subscriptlca𝑇𝑥𝑦superscript𝜌′\\operatorname{lca}_{T}(x,y)=\\rho^{\\prime}, this implies τS​(lcaS⁡(σ​(x),σ​(y)))≤τS​(uS)<τT​(lcaT⁡(x,y))subscript𝜏𝑆subscriptlca𝑆𝜎𝑥𝜎𝑦subscript𝜏𝑆subscript𝑢𝑆subscript𝜏𝑇subscriptlca𝑇𝑥𝑦\\tau_{S}(\\operatorname{lca}_{S}(\\sigma(x),\\sigma(y)))\\leq\\tau_{S}(u_{S})<\\tau_{T}(\\operatorname{lca}_{T}(x,y)) and thus x​y∈E​(G>​(𝒮))𝑥𝑦𝐸subscript𝐺𝒮xy\\in E(G_{{}_{>}}(\\mathscr{S})). In Case (b), uSsubscript𝑢𝑆u_{S} is an inner vertex of S𝑆S and lcaT⁡(x,y)subscriptlca𝑇𝑥𝑦\\operatorname{lca}_{T}(x,y) equals\nuisubscript𝑢𝑖u_{i}. We have set τT​(lcaT⁡(x,y))=τT​(ui)=τS​(uS)subscript𝜏𝑇subscriptlca𝑇𝑥𝑦subscript𝜏𝑇subscript𝑢𝑖subscript𝜏𝑆subscript𝑢𝑆\\tau_{T}(\\operatorname{lca}_{T}(x,y))=\\tau_{T}(u_{i})=\\tau_{S}(u_{S}). By\nconstruction, moreover, x𝑥x and y𝑦y must be in the same connected\ncomponent Cisubscript𝐶𝑖C_{i} of H1subscript𝐻1H_{1} but in distinct connected components of H2subscript𝐻2H_{2}.\nHence, we have x​y∉E​(H2)𝑥𝑦𝐸subscript𝐻2xy\\notin E(H_{2}) which implies x​y∉E​(G<)𝑥𝑦𝐸subscript𝐺xy\\notin E(G_{{}_{<}}) by the\nconstruction of H2subscript𝐻2H_{2}. Suppose first lcaS⁡(σ​(x),σ​(y))=uSsubscriptlca𝑆𝜎𝑥𝜎𝑦subscript𝑢𝑆\\operatorname{lca}_{S}(\\sigma(x),\\sigma(y))=u_{S}. Then x​y∈E​(G=)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{=}}) as otherwise it would hold x​y∈E​(G>)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{>}}); a\ncontradiction to Lemma 24. Moreover, we have\nτT​(lcaT⁡(x,y))=τS​(uS)=τS​(lcaS⁡(σ​(x),σ​(y)))subscript𝜏𝑇subscriptlca𝑇𝑥𝑦subscript𝜏𝑆subscript𝑢𝑆subscript𝜏𝑆subscriptlca𝑆𝜎𝑥𝜎𝑦\\tau_{T}(\\operatorname{lca}_{T}(x,y))=\\tau_{S}(u_{S})=\\tau_{S}(\\operatorname{lca}_{S}(\\sigma(x),\\sigma(y))) and thus\nx​y∈E​(G=​(𝒮))𝑥𝑦𝐸subscript𝐺𝒮xy\\in E(G_{{}_{=}}(\\mathscr{S})). Now suppose lcaS⁡(σ​(x),σ​(y))≺SuSsubscriptprecedes𝑆subscriptlca𝑆𝜎𝑥𝜎𝑦subscript𝑢𝑆\\operatorname{lca}_{S}(\\sigma(x),\\sigma(y))\\prec_{S}u_{S} and thus, by time consistency, τS​(lcaS⁡(σ​(x),σ​(y)))<τS​(uS)=τT​(lcaT⁡(x,y))subscript𝜏𝑆subscriptlca𝑆𝜎𝑥𝜎𝑦subscript𝜏𝑆subscript𝑢𝑆subscript𝜏𝑇subscriptlca𝑇𝑥𝑦\\tau_{S}(\\operatorname{lca}_{S}(\\sigma(x),\\sigma(y)))<\\tau_{S}(u_{S})=\\tau_{T}(\\operatorname{lca}_{T}(x,y)). This yields x​y∈E​(G>​(𝒮))𝑥𝑦𝐸subscript𝐺𝒮xy\\in E(G_{{}_{>}}(\\mathscr{S})).\nMoreover, from lcaS⁡(σ​(x),σ​(y))≺SuSsubscriptprecedes𝑆subscriptlca𝑆𝜎𝑥𝜎𝑦subscript𝑢𝑆\\operatorname{lca}_{S}(\\sigma(x),\\sigma(y))\\prec_{S}u_{S}, we conclude\nthat σ​(x),σ​(y)⪯Swsubscriptprecedes-or-equals𝑆𝜎𝑥𝜎𝑦𝑤\\sigma(x),\\sigma(y)\\preceq_{S}w for some child w∈childS⁡(uS)𝑤subscriptchild𝑆subscript𝑢𝑆w\\in\\operatorname{child}_{S}(u_{S}). Therefore, we must have x​y∈E​(G>)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{>}}) since otherwise\nx​y∈E​(G=)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{=}}) would imply that x​y∈E​(H2)𝑥𝑦𝐸subscript𝐻2xy\\in E(H_{2}). In Case (c), uSsubscript𝑢𝑆u_{S} is an inner vertex of S𝑆S and lcaT⁡(x,y)subscriptlca𝑇𝑥𝑦\\operatorname{lca}_{T}(x,y) equals\nvjsubscript𝑣𝑗v_{j}. We have set τT​(lcaT⁡(x,y))=τT​(vj)=τS​(uS)−ϵ<τS​(uS)subscript𝜏𝑇subscriptlca𝑇𝑥𝑦subscript𝜏𝑇subscript𝑣𝑗subscript𝜏𝑆subscript𝑢𝑆italic-ϵsubscript𝜏𝑆subscript𝑢𝑆\\tau_{T}(\\operatorname{lca}_{T}(x,y))=\\tau_{T}(v_{j})=\\tau_{S}(u_{S})-\\epsilon<\\tau_{S}(u_{S}). By construction, moreover, x𝑥x and y𝑦y must be in the same\nconnected component Cjsubscript𝐶𝑗C_{j} of H2subscript𝐻2H_{2} (and thus also in the same connected\ncomponent Cisubscript𝐶𝑖C_{i} of H1subscript𝐻1H_{1}) but in distinct connected components of H3subscript𝐻3H_{3}.\nThis immediately implies (i) that x​y∈E​(G<)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{<}}) by\nLemma 25 and (ii), by construction of H3subscript𝐻3H_{3}, that\nσ​(x)𝜎𝑥\\sigma(x) and σ​(y)𝜎𝑦\\sigma(y) lie below distinct children of uSsubscript𝑢𝑆u_{S}. In\nparticular, therefore, we have lcaS⁡(σ​(x),σ​(y))=uSsubscriptlca𝑆𝜎𝑥𝜎𝑦subscript𝑢𝑆\\operatorname{lca}_{S}(\\sigma(x),\\sigma(y))=u_{S} and\nthus τS​(lcaS⁡(σ​(x),σ​(y)))=τS​(uS)>τT​(lcaT⁡(x,y))subscript𝜏𝑆subscriptlca𝑆𝜎𝑥𝜎𝑦subscript𝜏𝑆subscript𝑢𝑆subscript𝜏𝑇subscriptlca𝑇𝑥𝑦\\tau_{S}(\\operatorname{lca}_{S}(\\sigma(x),\\sigma(y)))=\\tau_{S}(u_{S})>\\tau_{T}(\\operatorname{lca}_{T}(x,y)).\nThis implies x​y∈E​(G<​(𝒮))𝑥𝑦𝐸subscript𝐺𝒮xy\\in E(G_{{}_{<}}(\\mathscr{S})). In summary, we have shown that x​y∈E​(G<)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{<}}) iff x​y∈E​(G<​(𝒮))𝑥𝑦𝐸subscript𝐺𝒮xy\\in E(G_{{}_{<}}(\\mathscr{S})),\nx​y∈E​(G=)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{=}}) iff x​y∈E​(G=​(𝒮))𝑥𝑦𝐸subscript𝐺𝒮xy\\in E(G_{{}_{=}}(\\mathscr{S})), and x​y∈E​(G>)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{>}}) iff x​y∈E​(G>​(𝒮))𝑥𝑦𝐸subscript𝐺𝒮xy\\in E(G_{{}_{>}}(\\mathscr{S})). Since x,y∈L𝑥𝑦𝐿x,y\\in L where chosen arbitrarily and L=L​(T)𝐿𝐿𝑇L=L(T),\nthis proves that the relaxed scenario 𝒮𝒮\\mathscr{S} returned by the algorithm\nindeed explains the input 𝒢𝒢\\mathscr{G}.\n∎ As outlined in the proof of Lemma 26, edges\nx​y∈E​(G=)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{=}}) are considered only in Case (b) and we have lcaT⁡(x,y)=uisubscriptlca𝑇𝑥𝑦subscript𝑢𝑖\\operatorname{lca}_{T}(x,y)=u_{i} and lcaS⁡(σ​(x),σ​(y))=uSsubscriptlca𝑆𝜎𝑥𝜎𝑦subscript𝑢𝑆\\operatorname{lca}_{S}(\\sigma(x),\\sigma(y))=u_{S}. In this case, we put\nμ​(ui)=uS𝜇subscript𝑢𝑖subscript𝑢𝑆\\mu(u_{i})=u_{S} in Line 16 of\nAlgorithm 1. The reconciliation map μ𝜇\\mu therefore\nhas the following property: Let 𝒮𝒮\\mathscr{S} be a scenario produced by Algorithm 1\nfor a valid input 𝒢=(G<,G=,G>,σ)𝒢subscript𝐺subscript𝐺subscript𝐺𝜎\\mathscr{G}=(G_{{}_{<}},G_{{}_{=}},G_{{}_{>}},\\sigma). Then x​y∈E​(G=)𝑥𝑦𝐸subscript𝐺xy\\in E(G_{{}_{=}}) implies μ​(lcaT⁡(x,y))=lcaS⁡(σ​(x),σ​(y))𝜇subscriptlca𝑇𝑥𝑦subscriptlca𝑆𝜎𝑥𝜎𝑦\\mu(\\operatorname{lca}_{T}(x,y))=\\operatorname{lca}_{S}(\\sigma(x),\\sigma(y)). A main result of this section is the following characterization of\ngraph 333-partitions that derive from relaxed scenarios: A graph 333-partition 𝒢=(G<,G=,G>,σ)𝒢subscript𝐺subscript𝐺subscript𝐺𝜎\\mathscr{G}=(G_{{}_{<}},G_{{}_{=}},G_{{}_{>}},\\sigma) can be explained\nby a relaxed scenario if and only if G<subscript𝐺G_{{}_{<}} and G=subscript𝐺G_{{}_{=}} are properly\ncolored, G<subscript𝐺G_{{}_{<}} and G>subscript𝐺G_{{}_{>}} are cographs, and (ℛS​(𝒢),ℱS​(𝒢))subscriptℛ𝑆𝒢subscriptℱ𝑆𝒢(\\mathscr{R}_{S}(\\mathscr{G}),\\mathscr{F}_{S}(\\mathscr{G})) is consistent. Suppose first that 𝒢𝒢\\mathscr{G} can be explained by a relaxed scenario.\nThen G<subscript𝐺G_{{}_{<}} and G=subscript𝐺G_{{}_{=}} are properly colored by Cor. 1,\nG<subscript𝐺G_{{}_{<}} and G>subscript𝐺G_{{}_{>}} are cographs by Lemmas 14\nand 15, respectively, and (ℛS​(𝒢),ℱS​(𝒢))subscriptℛ𝑆𝒢subscriptℱ𝑆𝒢(\\mathscr{R}_{S}(\\mathscr{G}),\\mathscr{F}_{S}(\\mathscr{G})) is consistent by Prop. 2. Conversely,\nsuppose G<subscript𝐺G_{{}_{<}} and G=subscript𝐺G_{{}_{=}} are properly colored, G<subscript𝐺G_{{}_{<}} and G>subscript𝐺G_{{}_{>}} are\ncographs, and (ℛS​(𝒢),ℱS​(𝒢))subscriptℛ𝑆𝒢subscriptℱ𝑆𝒢(\\mathscr{R}_{S}(\\mathscr{G}),\\mathscr{F}_{S}(\\mathscr{G})) is consistent. In this\ncase, 𝒢=(G<,G=,G>,σ)𝒢subscript𝐺subscript𝐺subscript𝐺𝜎\\mathscr{G}=(G_{{}_{<}},G_{{}_{=}},G_{{}_{>}},\\sigma) is a valid input for\nAlgorithm 1 and Lemma 26 implies\nthat Algorithm 1 returns a relaxed scenario that\nexplains 𝒢𝒢\\mathscr{G}.\n∎ This result implies almost immediately that the property of being\nexplainable by a relaxed scenario is hereditary: A graph 333-partition 𝒢=(G<,G=,G>,σ)𝒢subscript𝐺subscript𝐺subscript𝐺𝜎\\mathscr{G}=(G_{{}_{<}},G_{{}_{=}},G_{{}_{>}},\\sigma) with vertex set\nL𝐿L can be explained by a relaxed scenario if and only if 𝒢|L′\\mathscr{G}_{|L^{\\prime}} can be explained by a relaxed scenario for all subsets\nL′⊆Lsuperscript𝐿′𝐿L^{\\prime}\\subseteq L. The if-part is clear as 𝒢=𝒢|L\\mathscr{G}=\\mathscr{G}_{|L}. Conversely,\nsuppose that 𝒢=(G<,G=,G>,σ)𝒢subscript𝐺subscript𝐺subscript𝐺𝜎\\mathscr{G}=(G_{{}_{<}},G_{{}_{=}},G_{{}_{>}},\\sigma) is explained by a relaxed\nscenario 𝒮=(T,S,σ,μ,τT,τS)𝒮𝑇𝑆𝜎𝜇subscript𝜏𝑇subscript𝜏𝑆\\mathscr{S}=(T,S,\\sigma,\\mu,\\tau_{T},\\tau_{S}) and let L′⊆Lsuperscript𝐿′𝐿L^{\\prime}\\subseteq L. By\nProp. 2, therefore, S𝑆S agrees with (ℛS​(𝒢),ℱS​(𝒢))subscriptℛ𝑆𝒢subscriptℱ𝑆𝒢(\\mathscr{R}_{S}(\\mathscr{G}),\\mathscr{F}_{S}(\\mathscr{G})). By Thm. 10, G<subscript𝐺G_{{}_{<}} and G=subscript𝐺G_{{}_{=}}\nare properly colored and G<subscript𝐺G_{{}_{<}} and G>subscript𝐺G_{{}_{>}} are cographs. Now consider\n𝒢|L′=(G<​[L′],G=​[L′],G>​[L′],σ|L′)\\mathscr{G}_{|L^{\\prime}}=(G_{{}_{<}}[L^{\\prime}],G_{{}_{=}}[L^{\\prime}],G_{{}_{>}}[L^{\\prime}],\\sigma_{|L^{\\prime}}).\nClearly, the induced subgraphs G<​[L′]subscript𝐺delimited-[]superscript𝐿′G_{{}_{<}}[L^{\\prime}] and G=​[L′]subscript𝐺delimited-[]superscript𝐿′G_{{}_{=}}[L^{\\prime}] are also properly\ncolored. By Prop. 1, G<​[L′]subscript𝐺delimited-[]superscript𝐿′G_{{}_{<}}[L^{\\prime}] and G>​[L′]subscript𝐺delimited-[]superscript𝐿′G_{{}_{>}}[L^{\\prime}] are also\ncographs. By definition of the informative and forbidden triples in\nDef. 6 and the induced subgraph relationships,\nwe observe furthermore that ℛS​(𝒢|L′)⊆ℛS​(𝒢)\\mathscr{R}_{S}(\\mathscr{G}_{|L^{\\prime}})\\subseteq\\mathscr{R}_{S}(\\mathscr{G}) and ℱS​(𝒢|L′)⊆ℱS​(𝒢)\\mathscr{F}_{S}(\\mathscr{G}_{|L^{\\prime}})\\subseteq\\mathscr{F}_{S}(\\mathscr{G}).\nHence, S𝑆S displays all triples in ℛS​(𝒢|L′)\\mathscr{R}_{S}(\\mathscr{G}_{|L^{\\prime}}) and none of\nthe triples in ℱS​(𝒢|L′)\\mathscr{F}_{S}(\\mathscr{G}_{|L^{\\prime}}), which yields that\n(ℛS​(𝒢|L′),ℱS​(𝒢|L′))(\\mathscr{R}_{S}(\\mathscr{G}_{|L^{\\prime}}),\\mathscr{F}_{S}(\\mathscr{G}_{|L^{\\prime}})) is consistent. We\ncan now again apply Thm. 10 to conclude that\n𝒢|L′\\mathscr{G}_{|L^{\\prime}} is explainable.\n∎ Using the characterization in Thm. 10, we can\ndecide in polynomial time whether a graph 333-partition is explainable by a\nrelaxed scenario: It can be decided in O​(|L|4​log⁡|L|)𝑂superscript𝐿4𝐿O(|L|^{4}\\log|L|) time whether a\ngraph 333-partition 𝒢=(G<,G=,G>,σ)𝒢subscript𝐺subscript𝐺subscript𝐺𝜎\\mathscr{G}=(G_{{}_{<}},G_{{}_{=}},G_{{}_{>}},\\sigma) can be explained by a\nrelaxed scenario. It can be checked in O​(|L|2)𝑂superscript𝐿2O(|L|^{2}) time whether G<subscript𝐺G_{{}_{<}} and G=subscript𝐺G_{{}_{=}} are\nproperly colored. It can be decided in in O​(|L|+|E|)𝑂𝐿𝐸O(|L|+|E|) time whether a graph G=(L,E)𝐺𝐿𝐸G=(L,E) is a cograph . In\nparticular, it can also be verified in O​(|L|2)𝑂superscript𝐿2O(|L|^{2}) time that\nG<subscript𝐺G_{{}_{<}} and G>subscript𝐺G_{{}_{>}} are cographs. Extraction of ℛ≔ℛS​(𝒢)≔ℛsubscriptℛ𝑆𝒢\\mathscr{R}\\coloneqq\\mathscr{R}_{S}(\\mathscr{G})\nand ℱ≔ℱS​(𝒢)≔ℱsubscriptℱ𝑆𝒢\\mathscr{F}\\coloneqq\\mathscr{F}_{S}(\\mathscr{G}) according to\nDef. 6 requires O​(|L|3)𝑂superscript𝐿3O(|L|^{3}). Let\nM′⊆Msuperscript𝑀′𝑀M^{\\prime}\\subseteq M be the subset of colors that appear on the leaves of the\ntriples in ℛ∪ℱℛℱ\\mathscr{R}\\cup\\mathscr{F}. By construction, we have |M′|∈O​(|L|)superscript𝑀′𝑂𝐿|M^{\\prime}|\\in O(|L|). The algorithm MTT, which stands for\nmixed triplets problem restricted to trees and was described in\n[ref]29, constructs a tree on M′superscript𝑀′M^{\\prime} that agrees with (ℛ,ℱ)ℛℱ(\\mathscr{R},\\mathscr{F}), if\none exists, in O​(|ℛ|⋅|M′|+|ℱ|⋅|M′|​log⁡|M′|+|M′|2​log⁡|M′|)𝑂⋅ℛsuperscript𝑀′⋅ℱsuperscript𝑀′superscript𝑀′superscriptsuperscript𝑀′2superscript𝑀′O(|\\mathscr{R}|\\cdot|M^{\\prime}|+|\\mathscr{F}|\\cdot|M^{\\prime}|\\log|M^{\\prime}|+|M^{\\prime}|^{2}\\log|M^{\\prime}|)\ntime. This, together with |ℛ|,|ℱ|∈O​(|L|3)ℛℱ𝑂superscript𝐿3|\\mathscr{R}|,|\\mathscr{F}|\\in O(|L|^{3}) and |M′|∈O​(|L|)superscript𝑀′𝑂𝐿|M^{\\prime}|\\in O(|L|) implies that it can\nbe decided in O​(|L|4​log⁡|L|)𝑂superscript𝐿4𝐿O(|L|^{4}\\log|L|) whether (ℛ,ℱ)ℛℱ(\\mathscr{R},\\mathscr{F})\nis consistent.\n∎ In particular, it can be decided in O​(|L|4​log⁡|L|)𝑂superscript𝐿4𝐿O(|L|^{4}\\log|L|)\nwhether 𝒢=(G<,G=,G>,σ)𝒢subscript𝐺subscript𝐺subscript𝐺𝜎\\mathscr{G}=(G_{{}_{<}},G_{{}_{=}},G_{{}_{>}},\\sigma) can be explained by a\nrelaxed scenario without explicit construction of such a scenario. We will\nshow in the following that the construction of relaxed scenarios is bounded\nby the same complexity. For simplicity, we will explicitly require that\nσ:L→M:𝜎→𝐿𝑀\\sigma\\colon L\\to M is surjective, i.e., that σ​(L)=M𝜎𝐿𝑀\\sigma(L)=M holds. One\neasily verifies, however, that the existence of “unused colors” in M𝑀M\nonly increases the size of the species tree S𝑆S (in particular, the number\nof leaves in S𝑆S that are attached to ρSsubscript𝜌𝑆\\rho_{S}) but does not affect the\nexistence of a relaxed scenario that explains 𝒢𝒢\\mathscr{G}. Algorithm 1 can be implemented to run in\nO​(|L|4​log⁡|L|)𝑂superscript𝐿4𝐿O(|L|^{4}\\log|L|) time (for valid inputs\n𝒢=(G<,G=,G>,σ)𝒢subscript𝐺subscript𝐺subscript𝐺𝜎\\mathscr{G}=(G_{{}_{<}},G_{{}_{=}},G_{{}_{>}},\\sigma) such that σ𝜎\\sigma is surjective). Let 𝒢=(G<,G=,G>,σ)𝒢subscript𝐺subscript𝐺subscript𝐺𝜎\\mathscr{G}=(G_{{}_{<}},G_{{}_{=}},G_{{}_{>}},\\sigma) with vertex set L𝐿L be a valid\ninput and surjective coloring σ:L→M:𝜎→𝐿𝑀\\sigma\\colon L\\to M that is given as\ninput for Algorithm 1. By assumption, G<subscript𝐺G_{{}_{<}} and\nG=subscript𝐺G_{{}_{=}} are properly colored, G<subscript𝐺G_{{}_{<}} and G>subscript𝐺G_{{}_{>}} are cographs, and\n(ℛS​(𝒢),ℱS​(𝒢))subscriptℛ𝑆𝒢subscriptℱ𝑆𝒢(\\mathscr{R}_{S}(\\mathscr{G}),\\mathscr{F}_{S}(\\mathscr{G})) is consistent. Extraction of\nℛ≔ℛS​(𝒢)≔ℛsubscriptℛ𝑆𝒢\\mathscr{R}\\coloneqq\\mathscr{R}_{S}(\\mathscr{G}) and ℱ≔ℱS​(𝒢)≔ℱsubscriptℱ𝑆𝒢\\mathscr{F}\\coloneqq\\mathscr{F}_{S}(\\mathscr{G}) according to\nDef. 6 requires O​(|L|3)𝑂superscript𝐿3O(|L|^{3}) operations.\nAs argued in the proof of Corollary 8, a tree S𝑆S on M𝑀M that\nagrees with (ℛ,ℱ)ℛℱ(\\mathscr{R},\\mathscr{F}) can be constructed in O​(|L|4​log⁡|L|)𝑂superscript𝐿4𝐿O(|L|^{4}\\log|L|) time using algorithm MTT [ref]29. A suitable time map τSsubscript𝜏𝑆\\tau_{S} can be constructed in O​(|M|)=O​(|L|)𝑂𝑀𝑂𝐿O(|M|)=O(|L|) time by Lemma 1. We can employ the LCA data structure described by\nBender et al. ,\nwhich pre-processes S𝑆S in O​(|M|)=O​(|L|)𝑂𝑀𝑂𝐿O(|M|)=O(|L|) time to\nallow O​(1)𝑂1O(1)-query of the last common ancestor of pairs of vertices in\nS𝑆S afterwards. In addition, we want to access the vertex\nw∈childS⁡(u)𝑤subscriptchild𝑆𝑢w\\in\\operatorname{child}_{S}(u) satisfying v⪯Swsubscriptprecedes-or-equals𝑆𝑣𝑤v\\preceq_{S}w for two given vertices\nu,v∈V​(T)𝑢𝑣𝑉𝑇u,v\\in V(T) with v≺Susubscriptprecedes𝑆𝑣𝑢v\\prec_{S}u. To achieve this, we pre-process S𝑆S as\nfollows: We first compute depth⁡(v)depth𝑣\\operatorname{depth}(v) for each v∈V​(T)𝑣𝑉𝑇v\\in V(T), i.e., the\nnumber of edges on the path from the root to v𝑣v in a top-down traversal\nof S𝑆S in O​(|L|)𝑂𝐿O(|L|) time. The Level Ancestor (LA)\nProblem asks for the ancestor LA⁡(v,d)LA𝑣𝑑\\operatorname{LA}(v,d) of a given vertex v𝑣v that has\ndepth d𝑑d, and has solutions with O​(|L|)𝑂𝐿O(|L|) pre-processing and\nO​(1)𝑂1O(1) query time  . Hence, we can obtain the\ndesired vertex w𝑤w as LA⁡(v,depth⁡(u)+1)LA𝑣depth𝑢1\\operatorname{LA}(v,\\operatorname{depth}(u)+1) in constant time. Since σ​(L′)⊆L​(S​(uS))𝜎superscript𝐿′𝐿𝑆subscript𝑢𝑆\\sigma(L^{\\prime})\\subseteq L(S(u_{S})) always holds by\nObs. 2, every x∈L𝑥𝐿x\\in L appears at most once in a\nloop corresponding to Line 9. Hence, the total\neffort of handling the cases where uSsubscript𝑢𝑆u_{S} is a leaf is bounded by O​(|L|)𝑂𝐿O(|L|). Consider now one execution of BuildGeneTree (without\nthe recursive calls) in which uSsubscript𝑢𝑆u_{S} is not a leaf. Construction of the\nauxiliary graphs H1subscript𝐻1H_{1} and H2subscript𝐻2H_{2} is done in O​(|L′|2)𝑂superscriptsuperscript𝐿′2O(|L^{\\prime}|^{2}), where\nthe condition σ​(x),σ​(y)≺Svsubscriptprecedes𝑆𝜎𝑥𝜎𝑦𝑣\\sigma(x),\\sigma(y)\\prec_{S}v for some v∈childS⁡(uS)𝑣subscriptchild𝑆subscript𝑢𝑆v\\in\\operatorname{child}_{S}(u_{S}) in the construction of H2subscript𝐻2H_{2} is equivalent to querying the\nLCA data structure in O​(1)𝑂1O(1) time whether lcaS⁡(σ​(x),σ​(y))≠uSsubscriptlca𝑆𝜎𝑥𝜎𝑦subscript𝑢𝑆\\operatorname{lca}_{S}(\\sigma(x),\\sigma(y))\\neq u_{S}. The connected components of H1subscript𝐻1H_{1} can be obtained in O​(|L′|+|E​(H1)|)=O​(|L′|2)𝑂superscript𝐿′𝐸subscript𝐻1𝑂superscriptsuperscript𝐿′2O(|L^{\\prime}|+|E(H_{1})|)=O(|L^{\\prime}|^{2}) time using\nbreadth-first search. Since H2subscript𝐻2H_{2} is a subgraph of H1subscript𝐻1H_{1}, we can, for\neach connected component Cisubscript𝐶𝑖C_{i} of H1subscript𝐻1H_{1}, determine the connected\ncomponents Cjsubscript𝐶𝑗C_{j} of H2subscript𝐻2H_{2} with Cj⊆Cisubscript𝐶𝑗subscript𝐶𝑖C_{j}\\subseteq C_{i} again using\nbreadth-first search and only the vertices in Cisubscript𝐶𝑖C_{i} as start vertices.\nThe overall effort for this is again bounded by O​(|L′|+|E​(H1)|)=O​(|L′|2)𝑂superscript𝐿′𝐸subscript𝐻1𝑂superscriptsuperscript𝐿′2O(|L^{\\prime}|+|E(H_{1})|)=O(|L^{\\prime}|^{2}). We can now, for each connected\ncomponent Cjsubscript𝐶𝑗C_{j} of H2subscript𝐻2H_{2}, construct the connected components Cksubscript𝐶𝑘C_{k} of\nH3subscript𝐻3H_{3} with Ck⊆Cjsubscript𝐶𝑘subscript𝐶𝑗C_{k}\\subseteq C_{j} by (i) adding the edge x​y𝑥𝑦xy to H3subscript𝐻3H_{3} if\nlcaS⁡(σ​(x),σ​(y))≠uSsubscriptlca𝑆𝜎𝑥𝜎𝑦subscript𝑢𝑆\\operatorname{lca}_{S}(\\sigma(x),\\sigma(y))\\neq u_{S} for all x,y∈Cj𝑥𝑦subscript𝐶𝑗x,y\\in C_{j} and (ii)\nperforming breadth-first search on H3subscript𝐻3H_{3} using only the vertices in Cjsubscript𝐶𝑗C_{j}\nas start vertices. Again, the overall effort for these breadth-first\nsearches is bounded by O​(|L′|2)𝑂superscriptsuperscript𝐿′2O(|L^{\\prime}|^{2}). The number of connected\ncomponent of the three graph H1subscript𝐻1H_{1}, H2subscript𝐻2H_{2}, and H3subscript𝐻3H_{3} is bounded by\nO​(|L′|)𝑂superscript𝐿′O(|L^{\\prime}|). For each connected component Cjsubscript𝐶𝑗C_{j} of H2subscript𝐻2H_{2}, we\nhave to choose vS∗∈childS⁡(uS)subscriptsuperscript𝑣𝑆subscriptchild𝑆subscript𝑢𝑆v^{*}_{S}\\in\\operatorname{child}_{S}(u_{S}) such that σ​(Cj)∩L​(S​(vS∗))≠∅𝜎subscript𝐶𝑗𝐿𝑆subscriptsuperscript𝑣𝑆\\sigma(C_{j})\\cap L(S(v^{*}_{S}))\\neq\\emptyset in Line 19. To this end, we\npick x∈Cj𝑥subscript𝐶𝑗x\\in C_{j} arbitrarily and query vS∗=LA⁡(σ​(x),depth⁡(uS)+1)subscriptsuperscript𝑣𝑆LA𝜎𝑥depthsubscript𝑢𝑆1v^{*}_{S}=\\operatorname{LA}(\\sigma(x),\\operatorname{depth}(u_{S})+1). For each connected component Cksubscript𝐶𝑘C_{k} of H3subscript𝐻3H_{3}, we can\nfind vS∈childS⁡(uS)subscript𝑣𝑆subscriptchild𝑆subscript𝑢𝑆v_{S}\\in\\operatorname{child}_{S}(u_{S}) such that σ​(Ck)⊆L​(S​(vS))𝜎subscript𝐶𝑘𝐿𝑆subscript𝑣𝑆\\sigma(C_{k})\\subseteq L(S(v_{S}))\nin Line 22 in the same way. In summary, for\neach connected component of each graph, the effort of creating a new\nvertex (in case of H1subscript𝐻1H_{1} and H2subscript𝐻2H_{2}), attaching the vertex to the tree\n(H1subscript𝐻1H_{1}, H2subscript𝐻2H_{2}, and H3subscript𝐻3H_{3}), choosing vS∗subscriptsuperscript𝑣𝑆v^{*}_{S} in Line 19\n(H2subscript𝐻2H_{2}), choosing vSsubscript𝑣𝑆v_{S} in Line 22 (H3subscript𝐻3H_{3}),\nand assigning the values for τTsubscript𝜏𝑇\\tau_{T} and μ𝜇\\mu for the newly created\nvertices are all constant-time operations. The overall effort for one\nrecursion step (excluding the recursive calls) is therefore bounded by\nO​(|L′|2)𝑂superscriptsuperscript𝐿′2O(|L^{\\prime}|^{2}). To bound the total effort of BuildGeneTree, consider the\nrecursion tree R𝑅R of the algorithm and let d𝑑d be its maximum depth\n(i.e. the maximum distance from ρRsubscript𝜌𝑅\\rho_{R} to a leaf). Notice that when a\nrecursion receives uS∈V​(S)subscript𝑢𝑆𝑉𝑆u_{S}\\in V(S) as input, it passes a child of uSsubscript𝑢𝑆u_{S} to\nany recursive call that it makes. Since terminal calls occur on leaves\nof S𝑆S, it follows that d𝑑d is at most the height of S𝑆S, which is\nO​(|V​(S)|)=O​(|L|)𝑂𝑉𝑆𝑂𝐿O(|V(S)|)=O(|L|) under the assumption that σ𝜎\\sigma\nis surjective. For r∈V​(R)𝑟𝑉𝑅r\\in V(R), denote by Lr′subscriptsuperscript𝐿′𝑟L^{\\prime}_{r} the set L′superscript𝐿′L^{\\prime} received\nas input on the recursive call corresponding to r𝑟r. If r𝑟r is not a\nleaf of R𝑅R, then notice that {Lq′:q∈childR⁡(r)}conditional-setsubscriptsuperscript𝐿′𝑞𝑞subscriptchild𝑅𝑟\\{L^{\\prime}_{q}:q\\in\\operatorname{child}_{R}(r)\\} is a\npartition of Lr′subscriptsuperscript𝐿′𝑟L^{\\prime}_{r} (without repeated subsets), since a recursive call is\nmade precisely for each connected component of H3subscript𝐻3H_{3}. Let ℓ∈{0,1,…,d}ℓ01…𝑑\\ell\\in\\{0,1,\\ldots,d\\}. We claim that for any two vertices r,q∈V​(R)𝑟𝑞𝑉𝑅r,q\\in V(R) at distance ℓℓ\\ell from ρRsubscript𝜌𝑅\\rho_{R}, Lr′∩Lq′=∅subscriptsuperscript𝐿′𝑟subscriptsuperscript𝐿′𝑞L^{\\prime}_{r}\\cap L^{\\prime}_{q}=\\emptyset. This can be seen by induction, with ℓ=0ℓ0\\ell=0 as the\ntrivial base case. Consider ℓ>0ℓ0\\ell>0. If r𝑟r and q𝑞q have the same\nparent, then Lr′∩Lq′=∅subscriptsuperscript𝐿′𝑟subscriptsuperscript𝐿′𝑞L^{\\prime}_{r}\\cap L^{\\prime}_{q}=\\emptyset follows from the observation\nthat recursions partition their input L′superscript𝐿′L^{\\prime} to their child calls. If r𝑟r\nand q𝑞q have distinct parents in R𝑅R, we know by induction that\nLp​a​rR​(r)′∩Lp​a​rR​(q)′=∅subscriptsuperscript𝐿′𝑝𝑎subscript𝑟𝑅𝑟subscriptsuperscript𝐿′𝑝𝑎subscript𝑟𝑅𝑞L^{\\prime}_{par_{R}(r)}\\cap L^{\\prime}_{par_{R}(q)}=\\emptyset. Since recursions pass a\nsubset of their input L′superscript𝐿′L^{\\prime}, Lr′∩Lq′=∅subscriptsuperscript𝐿′𝑟subscriptsuperscript𝐿′𝑞L^{\\prime}_{r}\\cap L^{\\prime}_{q}=\\emptyset holds as well.\nThus our claim is true. Now, for a given depth ℓ∈{0,1,…,d}ℓ01…𝑑\\ell\\in\\{0,1,\\ldots,d\\}, denote by r1,…,rksubscript𝑟1…subscript𝑟𝑘r_{1},\\ldots,r_{k} the set of vertices of\nR𝑅R at distance ℓℓ\\ell from ρRsubscript𝜌𝑅\\rho_{R}. The total effort of these vertices\nis O​(|Lr1′|2+…+|Lrk′|2)𝑂superscriptsubscriptsuperscript𝐿′subscript𝑟12…superscriptsubscriptsuperscript𝐿′subscript𝑟𝑘2O(|L^{\\prime}_{r_{1}}|^{2}+\\ldots+|L^{\\prime}_{r_{k}}|^{2}) and, since\n|Lr1′|+…+|Lrk′|≤|L|subscriptsuperscript𝐿′subscript𝑟1…subscriptsuperscript𝐿′subscript𝑟𝑘𝐿|L^{\\prime}_{r_{1}}|+\\ldots+|L^{\\prime}_{r_{k}}|\\leq|L| by\nour claim, the total time spent at depth ℓℓ\\ell is O​(|L|2)𝑂superscript𝐿2O(|L|^{2}).\nBecause this holds for every depth from 00 to d∈O​(|L|)𝑑𝑂𝐿d\\in O(|L|),\nthe total time spent in BuildGeneTree is O​(|L|3)𝑂superscript𝐿3O(|L|^{3}). It only remains to argue on the time spent constructing the final output\ntree T𝑇T. Note that in each recursion with corresponding vertex r∈V​(R)𝑟𝑉𝑅r\\in V(R), BuildGeneTree adds at most 2​|Lr′|+12subscriptsuperscript𝐿′𝑟12|L^{\\prime}_{r}|+1 nodes to\nthe constructed tree T′superscript𝑇′T^{\\prime} (we always add ρ′superscript𝜌′\\rho^{\\prime} and, additionally, in\nnon-terminal calls, we add one uisubscript𝑢𝑖u_{i} and one vjsubscript𝑣𝑗v_{j} vertex for each of the\nO​(|Lr′|)𝑂subscriptsuperscript𝐿′𝑟O(|L^{\\prime}_{r}|) connected components of H1subscript𝐻1H_{1} and H2subscript𝐻2H_{2},\nrespectively, and in terminal calls we add |Lr′|subscriptsuperscript𝐿′𝑟|L^{\\prime}_{r}| leaves).\nSince the vertices of R𝑅R at the same depth ℓℓ\\ell receive pairwise\ndisjoint Lr′subscriptsuperscript𝐿′𝑟L^{\\prime}_{r} sets, it follows that a total of at most O​(|L|)𝑂𝐿O(|L|) vertices are added to T𝑇T by the recursive calls at the same\ndepth ℓℓ\\ell. Since d∈O​(|L|)𝑑𝑂𝐿d\\in O(|L|), the resulting tree T′superscript𝑇′T^{\\prime} has\nat most O​(|L|2)𝑂superscript𝐿2O(|L|^{2}) vertices. To obtain the final gene tree T𝑇T,\nwe can traverse T′superscript𝑇′T^{\\prime} and suppress all vertices with a single child by\nremoving the vertex and reconnecting its child to its parent in (O(|V(T′)|)=O(|L|2)(O(|V(T^{\\prime})|)=O(|L|^{2}) total time. Hence, the overall time complexity of Algorithm 1 is\nO​(|L|4​log⁡|L|)𝑂superscript𝐿4𝐿O(|L|^{4}\\log|L|).\n∎\n\nReference markers found: [29]\n\nContext windows for each [ref]:\n[ref]29: By construction, we have |M′|∈O​(|L|)superscript𝑀′𝑂𝐿|M^{\\prime}|\\in O(|L|). The algorithm MTT, which stands for\nmixed triplets problem restricted to trees and was described in\n[ref]29, constructs a tree on M′superscript𝑀′M^{\\prime} that agrees with (ℛ,ℱ)ℛℱ(\\mathscr{R},\\mathscr{F}), if\none exists, in\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 29,\n            \"titles\": [\n                \"Biologically Feasible Gene Trees, Reconciliation Maps and Informative Triples\",\n                \"Inferring a tree from lowest common ancestors with an application to the optimization of relational expressions\",\n                \"Efficient algorithms for the reconciliation problem with gene duplication, horizontal transfer and loss\",\n                \"The level ancestor problem simplified\",\n                \"Lowest common ancestors in trees and directed acyclic graphs\",\n                \"Färbung von Graphen, deren sämtliche bzw. deren ungerade Kreise starr sind (Zusammenfassung)\",\n                \"Finding level-ancestors in trees\",\n                \"The ancestor of modern Holozoa acquired the CCA-adding enzyme from Alphaproteobacteria by horizontal gene transfer\",\n                \"Pattern matching for permutations\",\n                \"Extension operations on sets of leaf-labelled trees\",\n                \"Recognizing Berge graphs\",\n                \"The strong perfect graph theorem\",\n                \"Decomposition of odd-hole-free graphs by double star cutsets and 2-joins\",\n                \"Complement reducible graphs\",\n                \"A linear recognition algorithm for cographs\",\n                \"Xenolog classification\",\n                \"PhyloSift: phylogenetic analysis of genomes and metagenomes\",\n                \"Reconstruction methods for derivation trees\",\n                \"Distinguishing homologous from analogous proteins\",\n                \"Homology: a personal view on some of the problems\",\n                \"A method for investigating relative timing information on phylogenetic trees\",\n                \"Transitiv orientierbare graphen\",\n                \"Reconstructing Gene Trees From Fitch’s Xenology Relation\",\n                \"Best Match Graphs and Reconciliation of Gene Trees with Species Trees\",\n                \"Reciprocal best match graphs\",\n                \"H-trees: a model of evolutionary scenarios with horizontal gene transfer\",\n                \"Evolution of antibiotic resistance genes: The DNA sequence of a kanamycin resistance gene from Staphylococcus aureus\",\n                \"Reconstruction of ancient molecular phylogeny\",\n                \"Complete Edge-Colored Permutation Graphs\",\n                \"Inferring phylogenetic relationships avoiding forbidden rooted triplets\",\n                \"Alternative characterizations of Fitch’s xenology relation\",\n                \"On Symbolic Ultrametrics, Cotree Representations, and Cograph Edge Decompositions and Partitions\",\n                \"From sequence data incl. orthologs, paralogs, and xenologs to gene and species trees\",\n                \"On tree representations of relations and graphs: Symbolic ultrametrics and cograph edge decompositions\",\n                \"Orthology relations, symbolic ultrametrics, and cographs\",\n                \"A Short Note on Undirected Fitch Graphs\",\n                \"From event-labeled gene trees to species trees\",\n                \"A new characterization of P6subscript𝑃6P_{6}-free graphs\",\n                \"Determining the consistency of resolved triplets and fan triplets\",\n                \"Orthology and paralogy constraints: satisfiability and consistency\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]29 based on the context and research area of Relative Timing Information and Orthology in Evolutionary Scenarios. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}