{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: 1 Introduction\n\nPaper Abstract: \n\nPaper Section Text:\nAn effective method for analyzing classes of algorithms is to formalize the techniques used by the class into a formal proof system, and then analyze the formal proof system instead.\nBy doing this, theorists are able to hide many of the practical details of implementing these algorithms, while preserving the class of methods that the algorithms can feasibly employ.\nIndeed, this approach has been applied to study many different families of algorithms, such as Conflict-driven clause-learning algorithms for SAT   , which can be formalized using resolution proofs . Optimization algorithms using semidefinite programming  , which can often be formalized using Sums-of-Squares proofs  [ref]6. The classic cutting planes algorithms for integer programming  , which are formalized by cutting planes proofs   . In the present work, we continue the study of formal proof systems corresponding to modern integer programming algorithms.\nRecall that in the integer programming problem, we are given a polytope PâŠ†â„nğ‘ƒsuperscriptâ„ğ‘›P\\subseteq\\mathbb{R}^{n} and a vector câˆˆâ„nğ‘superscriptâ„ğ‘›c\\in\\mathbb{R}^{n}, and our goal is to find a point xâˆˆPâˆ©â„¤nğ‘¥ğ‘ƒsuperscriptâ„¤ğ‘›x\\in P\\cap\\mathbb{Z}^{n} maximizing câ‹…xâ‹…ğ‘ğ‘¥c\\cdot x.\nThe classic approach to solving this problem â€” pioneered by Gomory  â€” is to add***Throughout, we will say that a cutting plane, or an inequality is added to a polytope Pğ‘ƒP to mean that it is added to the set of inequalities defining Pğ‘ƒP. cutting planes to Pğ‘ƒP.\nA cutting plane for Pğ‘ƒP is any inequality of the form aâ€‹xâ‰¤âŒŠbâŒ‹ğ‘ğ‘¥ğ‘ax\\leq\\lfloor b\\rfloor, where ağ‘a is an integral vector, bğ‘b is rational, and every point of Pğ‘ƒP is satisfied by aâ€‹xâ‰¤bğ‘ğ‘¥ğ‘ax\\leq b.\nBy the integrality of ağ‘a, it follows that cutting planes preserve the integral points of Pğ‘ƒP, while potentially removing non-integral points from Pğ‘ƒP.\nThe cutting planes algorithms then proceed by heuristically choosing â€œgoodâ€ cutting planes to add to Pğ‘ƒP to try and locate the integral hull of Pğ‘ƒP as quickly as possible. As mentioned above, these algorithms can be naturally formalized into a proof system â€” the Cutting Planes proof system, denoted ğ–¢ğ–¯ğ–¢ğ–¯{\\mathsf{CP}} â€” as follows .\nInitially, we are given a polytope Pğ‘ƒP, presented as a list of integer-linear inequalities {aiâ€‹xâ‰¤bi}subscriptğ‘ğ‘–ğ‘¥subscriptğ‘ğ‘–\\left\\{a_{i}x\\leq b_{i}\\right\\}.\nFrom these inequalities we can then deduce new inequalities using two deduction rules: Linear Combination. From inequalities aâ€‹xâ‰¤b,câ€‹xâ‰¤dformulae-sequenceğ‘ğ‘¥ğ‘ğ‘ğ‘¥ğ‘‘ax\\leq b,cx\\leq d, deduce any non-negative linear combination of these two inequalities with integer coefficients. Division Rule. From an inequality aâ€‹xâ‰¤bğ‘ğ‘¥ğ‘ax\\leq b, if dâˆˆâ„¤ğ‘‘â„¤d\\in\\mathbb{Z} with dâ‰¥0ğ‘‘0d\\geq 0 divides all entries of ağ‘a then deduce (a/d)â€‹xâ‰¤âŒŠb/dâŒ‹ğ‘ğ‘‘ğ‘¥ğ‘ğ‘‘(a/d)x\\leq\\lfloor b/d\\rfloor. A Cutting Planes refutation of Pğ‘ƒP is a proof of the trivially false inequality 1â‰¤0101\\leq 0 from the inequalities in Pğ‘ƒP; clearly, such a refutation is possible only if Pğ‘ƒP does not contain any integral points.\nWhile Cutting Planes has grown to be an influential proof system in propositional proof complexity, the original cutting planes algorithms suffered from numerical instabilities, as well as difficulties in finding good heuristics for the next cutting planes to add . The modern algorithms in integer programming improve on the classical cutting planes method by combining them with a second technique, known as branch-and-bound, resulting in a family of optimization algorithms broadly referred to as branch-and-cut algorithms.\nThese algorithms search for integer solutions in a polytope Pğ‘ƒP by recursively repeating the following two procedures: First, Pğ‘ƒP is split into smaller polytopes P1,â€¦,Pksubscriptğ‘ƒ1â€¦subscriptğ‘ƒğ‘˜P_{1},\\ldots,P_{k} such that Pâˆ©â„¤nâŠ†â‹ƒiâˆˆ[k]Piğ‘ƒsuperscriptâ„¤ğ‘›subscriptğ‘–delimited-[]ğ‘˜subscriptğ‘ƒğ‘–P\\cap\\mathbb{Z}^{n}\\subseteq\\bigcup_{i\\in[k]}P_{i} (i.e.Â branching).\nNext, cutting planes deductions are made in order to further refine the branched polytopes (i.e.Â cutting).\nIn practice, branching is usually performed by selecting a variable xisubscriptğ‘¥ğ‘–x_{i} and branching on all possible values of xisubscriptğ‘¥ğ‘–x_{i}; that is, recursing on Pâˆ©{xi=t}ğ‘ƒsubscriptğ‘¥ğ‘–ğ‘¡P\\cap\\{x_{i}=t\\} for each feasible integer value tğ‘¡t.\nMore complicated branching schemes have also been considered, such as branching on the hamming weight of subsets of variables , branching using basis-reduction techniquesÂ   , and more general linear inequalities   . However, while these branch-and-cut algorithms are much more efficient in practice than the classical cutting planes methods, they are no longer naturally modelled by Cutting Planes proofs.\nSo, in order to model these solvers as proof systems, Beame et al.Â  introduced the Stabbing Planes proof system.\nGiven a polytope Pğ‘ƒP containing no integral points, a Stabbing Planes refutation of Pğ‘ƒP proceeds as follows.\nWe begin by choosing an integral vector ağ‘a, an integer bğ‘b, and replacing Pğ‘ƒP with the two polytopes Pâˆ©{aâ€‹xâ‰¤bâˆ’1}ğ‘ƒğ‘ğ‘¥ğ‘1P\\cap\\left\\{ax\\leq b-1\\right\\} and Pâˆ©{aâ€‹xâ‰¥b}ğ‘ƒğ‘ğ‘¥ğ‘P\\cap\\left\\{ax\\geq b\\right\\}.\nThen, we recurse on these two polytopes, continuing until all descendant polytopes are empty (that is, they do not even contain any real solutions).\nThe majority of branching schemes used in practical branch-and-cut algorithms (including all of the concrete schemes mentioned above) are examples of this general branching rule. It is now an interesting question how the two proof systems â€” Cutting Planes and Stabbing Planes â€” are related.\nBy contrasting the two systems we see at least three major differences: Top-down vs.Â Bottom-up. Stabbing Planes is a top-down proof system, formed by performing queries on the polytope and recursing; while Cutting Planes is a bottom-up proof system, formed by deducing new inequalities from old ones. Polytopes vs.Â Halfspaces. Individual â€œlinesâ€ in a Stabbing Planes proof are polytopes, while individual â€œlinesâ€ in a Cutting Planes proof are halfspaces. Tree-like vs.Â DAG-like. The graphs underlying Stabbing Planes proofs are trees, while the graphs underlying Cutting Planes proofs are general DAGs: intuitively, this means that Cutting Planes proofs can â€œre-useâ€ their intermediate steps, while Stabbing Planes proofs cannot. When taken together, these facts suggest that Stabbing Planes and Cutting Planes could be incomparable in power, as polytopes are more expressive than halfspaces, while DAG-like proofs offer the power of line-reuse.\nGoing against this natural intuition, Beame et al.Â proved that Stabbing Planes can actually efficiently simulate Cutting Planes  (see FigureÂ 1) â€” this simulation was later extended by Basu et al.Â  to almost all types of cuts used in practical integer programming, including split cuts.\nFurthermore, Beame et al. proved that Stabbing Planes is equivalent to the proof system tree-like ğ–±â€‹(ğ–¢ğ–¯)ğ–±ğ–¢ğ–¯\\mathsf{R}({\\mathsf{CP}}), denoted ğ–³ğ—‹ğ–¾ğ–¾ğ–±â€‹(ğ–¢ğ–¯)ğ–³ğ—‹ğ–¾ğ–¾ğ–±ğ–¢ğ–¯\\mathsf{TreeR(CP)}, which was introduced by KrajÃ­Äek , and whose relationship to Cutting Planes was previously unknown. This leaves the converse problem â€” of whether Stabbing Planes can also be simulated by Cutting Planes â€” as an intriguing open question.\nBeame et al.Â conjectured that such a simulation was impossible, and furthermore that the Tseitin formulas provided a separation between these systems .\nFor any graph GğºG and any {0,1}01\\left\\{0,1\\right\\}-labelling â„“â„“\\ell of the vertices of GğºG, the Tseitin formula of (G,â„“)ğºâ„“(G,\\ell) is the following system of ğ”½2subscriptğ”½2\\mathbb{F}_{2}-linear equations: for each edge eğ‘’e we introduce a variable xesubscriptğ‘¥ğ‘’x_{e}, and for each vertex vğ‘£v we have an equation asserting that the sum of the edge variables incident with vğ‘£v must agree with its label â„“â€‹(v)â„“ğ‘£\\ell(v) (note such a system is unsatisfiable as long as âˆ‘vâ„“â€‹(v)subscriptğ‘£â„“ğ‘£\\sum_{v}\\ell(v) is odd).\nOn the one hand, Beame et al.Â proved that there are quasi-polynomial size Stabbing Planes refutations of the Tseitin formulas .\nOn the other hand, Tseitin formulas had long been conjectured to be exponentially hard for Cutting PlanesÂ , as they form one of the canonical families of hard examples for algebraic and semi-algebraic proof systems, including Nullstellensatz , Polynomial Calculus 8, and Sum-of-Squares  . In a recent breakthrough, the long-standing conjecture that Tseitin was exponentially hard for Cutting Planes was refuted by Dadush and TiwariÂ 6, who gave quasi-polynomial size Cutting Planes refutations of Tseitin instances.\nMoreover, to prove their result, Dadush and Tiwari showed how to translate the quasipolynomial-size Stabbing Planes refutations of Tseitin into Cutting Planes refutations.\nThis translation result is interesting for several reasons.\nFirst, it brings up the possibility that Cutting Planes can actually simulate Stabbing Planes.\nIf possible, such a simulation would allow the significant analysis done on the Cutting Planes system to be lifted directly to branch-and-cut solvers.\nIn particular, this would mean that the known exponential-size lower bounds for Cutting Planes refutations would immediately imply the first exponential lower bounds for these algorithms for arbitrary branching heuristics.\nSecond, the translation converts shallow Stabbing Planes proofs into very deep Cutting Planes proofs: the Stabbing Planes refutation of Tseitin has depth Oâ€‹(log2â¡n)ğ‘‚superscript2ğ‘›O(\\log^{2}n) and quasi-polynomial size, while the Cutting Planes refutation has quasipolynomial size and depth.\nThis is quite unusual since simulations between proof systems typically preserve the structure of the proofs, and thus brings up the possibility that the Tseitin formulas yield a supercritical size/depth tradeoff â€“ formulas with short proofs, requiring superlinear depth.\nFor contrast: another simulation from the literature which emphatically does not preserve the structure of proofs is the simulation of bounded-size resolution by bounded-width resolution by Ben-Sasson and Wigderson 1.\nIn this setting, it is known that this simulation is tight 5, and even that there exist formulas refutable in resolution width wğ‘¤w requiring maximal size nÎ©â€‹(w)superscriptğ‘›Î©ğ‘¤n^{\\Omega(w)} .\nFurthermore, under the additional assumption that the proofs are tree-like, Razborov 7 proved a supercritical trade-off between width and size.\n\nReference markers found: [6]\n\nContext windows for each [ref]:\n[ref]6: algorithms for SAT   , which can be formalized using resolution proofs . Optimization algorithms using semidefinite programming  , which can often be formalized using Sums-of-Squares proofs  [ref]6. The classic cutting planes algorithms for integer programming  , which are formalized by cutting planes proofs   . In the present work, we continue the study of formal proof systems\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 6,\n            \"titles\": [\n                \"Complexity of branch-and-bound and cutting planes in mixed-integer optimization - II\",\n                \"Market split and basis reduction: Towards a solution of the cornuÃ©jols-dawande instances\",\n                \"Hard equality constrained integer knapsacks\",\n                \"Satisfiability, branch-width and tseitin tautologies\",\n                \"Lower bounds for the weak pigeonhole principle and random formulas beyond resolution\",\n                \"Narrow proofs may be maximally long\",\n                \"Hypercontractivity, sum-of-squares proofs, and their applications\",\n                \"Time-space tradeoffs in resolution: superpolynomial lower bounds for superlinear space\",\n                \"Stabbing planes\",\n                \"Some trade-off results for polynomial calculus: extended abstract\",\n                \"Short proofs are narrow - resolution made simple\",\n                \"Supercritical space-width trade-offs for resolution\",\n                \"On the chvÃ¡tal rank of polytopes in the 0/1 cube\",\n                \"Aggregation-based cutting-planes for packing and covering integer programs\",\n                \"Optimality of size-width tradeoffs for resolution\",\n                \"Lower bounds for cutting planes proofs with small coefficients\",\n                \"Rank bounds and integrality gaps for cutting planes procedures\",\n                \"Linear gaps between degrees for the polynomial calculus modulo distinct primes\",\n                \"Edmonds polytopes and a hierarchy of combinatorial problems\",\n                \"Cutting-plane proofs and the stability number of a graph\",\n                \"On cutting-plane proofs in combinatorial optimization\",\n                \"Many hard examples for resolution\",\n                \"The relative efficiency of propositional proof systems\",\n                \"On the complexity of cutting-plane proofs\",\n                \"On the rank of mixed 0, 1 polyhedra\",\n                \"On the Complexity of Branching Proofs\",\n                \"Recursive conditioning\",\n                \"A computing procedure for quantification theory\",\n                \"Bucket elimination: A unifying framework for processing hard and soft constraints\",\n                \"Bounds on the chvÃ¡tal rank of polytopes in the 0/1-cube\",\n                \"Semantic versus syntactic cutting planes\",\n                \"Local branching\",\n                \"Random Î˜Î˜\\\\Theta(log n)-CNFs are hard for cutting planes\",\n                \"Monotone circuit lower bounds from resolution\",\n                \".879approximationn algorithms for max cut and max 2sat\",\n                \"An algorithm for integer solutions to linear programs\",\n                \"Automating cutting planes is np-hard\",\n                \"Tseitinâ€™s tautologies and lower bounds for nullstellensatz proofs\",\n                \"Linear lower bound on degrees of positivstellensatz calculus proofs for the parity\",\n                \"Random formulas, monotone circuits, and interpolation\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]6 based on the context and research area of 1 Introduction. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}