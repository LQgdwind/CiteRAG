{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: 1 Introduction\n\nPaper Abstract: \n\nPaper Section Text:\nAn effective method for analyzing classes of algorithms is to formalize the techniques used by the class into a formal proof system, and then analyze the formal proof system instead.\nBy doing this, theorists are able to hide many of the practical details of implementing these algorithms, while preserving the class of methods that the algorithms can feasibly employ.\nIndeed, this approach has been applied to study many different families of algorithms, such as Conflict-driven clause-learning algorithms for SAT   , which can be formalized using resolution proofs . Optimization algorithms using semidefinite programming  , which can often be formalized using Sums-of-Squares proofs  [ref]6. The classic cutting planes algorithms for integer programming  , which are formalized by cutting planes proofs   . In the present work, we continue the study of formal proof systems corresponding to modern integer programming algorithms.\nRecall that in the integer programming problem, we are given a polytope P⊆ℝn𝑃superscriptℝ𝑛P\\subseteq\\mathbb{R}^{n} and a vector c∈ℝn𝑐superscriptℝ𝑛c\\in\\mathbb{R}^{n}, and our goal is to find a point x∈P∩ℤn𝑥𝑃superscriptℤ𝑛x\\in P\\cap\\mathbb{Z}^{n} maximizing c⋅x⋅𝑐𝑥c\\cdot x.\nThe classic approach to solving this problem — pioneered by Gomory  — is to add***Throughout, we will say that a cutting plane, or an inequality is added to a polytope P𝑃P to mean that it is added to the set of inequalities defining P𝑃P. cutting planes to P𝑃P.\nA cutting plane for P𝑃P is any inequality of the form a​x≤⌊b⌋𝑎𝑥𝑏ax\\leq\\lfloor b\\rfloor, where a𝑎a is an integral vector, b𝑏b is rational, and every point of P𝑃P is satisfied by a​x≤b𝑎𝑥𝑏ax\\leq b.\nBy the integrality of a𝑎a, it follows that cutting planes preserve the integral points of P𝑃P, while potentially removing non-integral points from P𝑃P.\nThe cutting planes algorithms then proceed by heuristically choosing “good” cutting planes to add to P𝑃P to try and locate the integral hull of P𝑃P as quickly as possible. As mentioned above, these algorithms can be naturally formalized into a proof system — the Cutting Planes proof system, denoted 𝖢𝖯𝖢𝖯{\\mathsf{CP}} — as follows .\nInitially, we are given a polytope P𝑃P, presented as a list of integer-linear inequalities {ai​x≤bi}subscript𝑎𝑖𝑥subscript𝑏𝑖\\left\\{a_{i}x\\leq b_{i}\\right\\}.\nFrom these inequalities we can then deduce new inequalities using two deduction rules: Linear Combination. From inequalities a​x≤b,c​x≤dformulae-sequence𝑎𝑥𝑏𝑐𝑥𝑑ax\\leq b,cx\\leq d, deduce any non-negative linear combination of these two inequalities with integer coefficients. Division Rule. From an inequality a​x≤b𝑎𝑥𝑏ax\\leq b, if d∈ℤ𝑑ℤd\\in\\mathbb{Z} with d≥0𝑑0d\\geq 0 divides all entries of a𝑎a then deduce (a/d)​x≤⌊b/d⌋𝑎𝑑𝑥𝑏𝑑(a/d)x\\leq\\lfloor b/d\\rfloor. A Cutting Planes refutation of P𝑃P is a proof of the trivially false inequality 1≤0101\\leq 0 from the inequalities in P𝑃P; clearly, such a refutation is possible only if P𝑃P does not contain any integral points.\nWhile Cutting Planes has grown to be an influential proof system in propositional proof complexity, the original cutting planes algorithms suffered from numerical instabilities, as well as difficulties in finding good heuristics for the next cutting planes to add . The modern algorithms in integer programming improve on the classical cutting planes method by combining them with a second technique, known as branch-and-bound, resulting in a family of optimization algorithms broadly referred to as branch-and-cut algorithms.\nThese algorithms search for integer solutions in a polytope P𝑃P by recursively repeating the following two procedures: First, P𝑃P is split into smaller polytopes P1,…,Pksubscript𝑃1…subscript𝑃𝑘P_{1},\\ldots,P_{k} such that P∩ℤn⊆⋃i∈[k]Pi𝑃superscriptℤ𝑛subscript𝑖delimited-[]𝑘subscript𝑃𝑖P\\cap\\mathbb{Z}^{n}\\subseteq\\bigcup_{i\\in[k]}P_{i} (i.e. branching).\nNext, cutting planes deductions are made in order to further refine the branched polytopes (i.e. cutting).\nIn practice, branching is usually performed by selecting a variable xisubscript𝑥𝑖x_{i} and branching on all possible values of xisubscript𝑥𝑖x_{i}; that is, recursing on P∩{xi=t}𝑃subscript𝑥𝑖𝑡P\\cap\\{x_{i}=t\\} for each feasible integer value t𝑡t.\nMore complicated branching schemes have also been considered, such as branching on the hamming weight of subsets of variables , branching using basis-reduction techniques   , and more general linear inequalities   . However, while these branch-and-cut algorithms are much more efficient in practice than the classical cutting planes methods, they are no longer naturally modelled by Cutting Planes proofs.\nSo, in order to model these solvers as proof systems, Beame et al.  introduced the Stabbing Planes proof system.\nGiven a polytope P𝑃P containing no integral points, a Stabbing Planes refutation of P𝑃P proceeds as follows.\nWe begin by choosing an integral vector a𝑎a, an integer b𝑏b, and replacing P𝑃P with the two polytopes P∩{a​x≤b−1}𝑃𝑎𝑥𝑏1P\\cap\\left\\{ax\\leq b-1\\right\\} and P∩{a​x≥b}𝑃𝑎𝑥𝑏P\\cap\\left\\{ax\\geq b\\right\\}.\nThen, we recurse on these two polytopes, continuing until all descendant polytopes are empty (that is, they do not even contain any real solutions).\nThe majority of branching schemes used in practical branch-and-cut algorithms (including all of the concrete schemes mentioned above) are examples of this general branching rule. It is now an interesting question how the two proof systems — Cutting Planes and Stabbing Planes — are related.\nBy contrasting the two systems we see at least three major differences: Top-down vs. Bottom-up. Stabbing Planes is a top-down proof system, formed by performing queries on the polytope and recursing; while Cutting Planes is a bottom-up proof system, formed by deducing new inequalities from old ones. Polytopes vs. Halfspaces. Individual “lines” in a Stabbing Planes proof are polytopes, while individual “lines” in a Cutting Planes proof are halfspaces. Tree-like vs. DAG-like. The graphs underlying Stabbing Planes proofs are trees, while the graphs underlying Cutting Planes proofs are general DAGs: intuitively, this means that Cutting Planes proofs can “re-use” their intermediate steps, while Stabbing Planes proofs cannot. When taken together, these facts suggest that Stabbing Planes and Cutting Planes could be incomparable in power, as polytopes are more expressive than halfspaces, while DAG-like proofs offer the power of line-reuse.\nGoing against this natural intuition, Beame et al. proved that Stabbing Planes can actually efficiently simulate Cutting Planes  (see Figure 1) — this simulation was later extended by Basu et al.  to almost all types of cuts used in practical integer programming, including split cuts.\nFurthermore, Beame et al. proved that Stabbing Planes is equivalent to the proof system tree-like 𝖱​(𝖢𝖯)𝖱𝖢𝖯\\mathsf{R}({\\mathsf{CP}}), denoted 𝖳𝗋𝖾𝖾𝖱​(𝖢𝖯)𝖳𝗋𝖾𝖾𝖱𝖢𝖯\\mathsf{TreeR(CP)}, which was introduced by Krajíček , and whose relationship to Cutting Planes was previously unknown. This leaves the converse problem — of whether Stabbing Planes can also be simulated by Cutting Planes — as an intriguing open question.\nBeame et al. conjectured that such a simulation was impossible, and furthermore that the Tseitin formulas provided a separation between these systems .\nFor any graph G𝐺G and any {0,1}01\\left\\{0,1\\right\\}-labelling ℓℓ\\ell of the vertices of G𝐺G, the Tseitin formula of (G,ℓ)𝐺ℓ(G,\\ell) is the following system of 𝔽2subscript𝔽2\\mathbb{F}_{2}-linear equations: for each edge e𝑒e we introduce a variable xesubscript𝑥𝑒x_{e}, and for each vertex v𝑣v we have an equation asserting that the sum of the edge variables incident with v𝑣v must agree with its label ℓ​(v)ℓ𝑣\\ell(v) (note such a system is unsatisfiable as long as ∑vℓ​(v)subscript𝑣ℓ𝑣\\sum_{v}\\ell(v) is odd).\nOn the one hand, Beame et al. proved that there are quasi-polynomial size Stabbing Planes refutations of the Tseitin formulas .\nOn the other hand, Tseitin formulas had long been conjectured to be exponentially hard for Cutting Planes , as they form one of the canonical families of hard examples for algebraic and semi-algebraic proof systems, including Nullstellensatz , Polynomial Calculus 8, and Sum-of-Squares  . In a recent breakthrough, the long-standing conjecture that Tseitin was exponentially hard for Cutting Planes was refuted by Dadush and Tiwari 6, who gave quasi-polynomial size Cutting Planes refutations of Tseitin instances.\nMoreover, to prove their result, Dadush and Tiwari showed how to translate the quasipolynomial-size Stabbing Planes refutations of Tseitin into Cutting Planes refutations.\nThis translation result is interesting for several reasons.\nFirst, it brings up the possibility that Cutting Planes can actually simulate Stabbing Planes.\nIf possible, such a simulation would allow the significant analysis done on the Cutting Planes system to be lifted directly to branch-and-cut solvers.\nIn particular, this would mean that the known exponential-size lower bounds for Cutting Planes refutations would immediately imply the first exponential lower bounds for these algorithms for arbitrary branching heuristics.\nSecond, the translation converts shallow Stabbing Planes proofs into very deep Cutting Planes proofs: the Stabbing Planes refutation of Tseitin has depth O​(log2⁡n)𝑂superscript2𝑛O(\\log^{2}n) and quasi-polynomial size, while the Cutting Planes refutation has quasipolynomial size and depth.\nThis is quite unusual since simulations between proof systems typically preserve the structure of the proofs, and thus brings up the possibility that the Tseitin formulas yield a supercritical size/depth tradeoff – formulas with short proofs, requiring superlinear depth.\nFor contrast: another simulation from the literature which emphatically does not preserve the structure of proofs is the simulation of bounded-size resolution by bounded-width resolution by Ben-Sasson and Wigderson 1.\nIn this setting, it is known that this simulation is tight 5, and even that there exist formulas refutable in resolution width w𝑤w requiring maximal size nΩ​(w)superscript𝑛Ω𝑤n^{\\Omega(w)} .\nFurthermore, under the additional assumption that the proofs are tree-like, Razborov 7 proved a supercritical trade-off between width and size.\n\nReference markers found: [6]\n\nContext windows for each [ref]:\n[ref]6: algorithms for SAT   , which can be formalized using resolution proofs . Optimization algorithms using semidefinite programming  , which can often be formalized using Sums-of-Squares proofs  [ref]6. The classic cutting planes algorithms for integer programming  , which are formalized by cutting planes proofs   . In the present work, we continue the study of formal proof systems\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 6,\n            \"titles\": [\n                \"Complexity of branch-and-bound and cutting planes in mixed-integer optimization - II\",\n                \"Market split and basis reduction: Towards a solution of the cornuéjols-dawande instances\",\n                \"Hard equality constrained integer knapsacks\",\n                \"Satisfiability, branch-width and tseitin tautologies\",\n                \"Lower bounds for the weak pigeonhole principle and random formulas beyond resolution\",\n                \"Narrow proofs may be maximally long\",\n                \"Hypercontractivity, sum-of-squares proofs, and their applications\",\n                \"Time-space tradeoffs in resolution: superpolynomial lower bounds for superlinear space\",\n                \"Stabbing planes\",\n                \"Some trade-off results for polynomial calculus: extended abstract\",\n                \"Short proofs are narrow - resolution made simple\",\n                \"Supercritical space-width trade-offs for resolution\",\n                \"On the chvátal rank of polytopes in the 0/1 cube\",\n                \"Aggregation-based cutting-planes for packing and covering integer programs\",\n                \"Optimality of size-width tradeoffs for resolution\",\n                \"Lower bounds for cutting planes proofs with small coefficients\",\n                \"Rank bounds and integrality gaps for cutting planes procedures\",\n                \"Linear gaps between degrees for the polynomial calculus modulo distinct primes\",\n                \"Edmonds polytopes and a hierarchy of combinatorial problems\",\n                \"Cutting-plane proofs and the stability number of a graph\",\n                \"On cutting-plane proofs in combinatorial optimization\",\n                \"Many hard examples for resolution\",\n                \"The relative efficiency of propositional proof systems\",\n                \"On the complexity of cutting-plane proofs\",\n                \"On the rank of mixed 0, 1 polyhedra\",\n                \"On the Complexity of Branching Proofs\",\n                \"Recursive conditioning\",\n                \"A computing procedure for quantification theory\",\n                \"Bucket elimination: A unifying framework for processing hard and soft constraints\",\n                \"Bounds on the chvátal rank of polytopes in the 0/1-cube\",\n                \"Semantic versus syntactic cutting planes\",\n                \"Local branching\",\n                \"Random ΘΘ\\\\Theta(log n)-CNFs are hard for cutting planes\",\n                \"Monotone circuit lower bounds from resolution\",\n                \".879approximationn algorithms for max cut and max 2sat\",\n                \"An algorithm for integer solutions to linear programs\",\n                \"Automating cutting planes is np-hard\",\n                \"Tseitin’s tautologies and lower bounds for nullstellensatz proofs\",\n                \"Linear lower bound on degrees of positivstellensatz calculus proofs for the parity\",\n                \"Random formulas, monotone circuits, and interpolation\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]6 based on the context and research area of 1 Introduction. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}