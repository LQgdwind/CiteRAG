{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: An Algorithmic Framework for Locally Constrained Homomorphisms\n\nPaper Abstract: \n\nPaper Section Text:\nA homomorphism from a graph G𝐺G to a graph H𝐻H is a mapping ϕ:V​(G)→V​(H):italic-ϕ→𝑉𝐺𝑉𝐻\\phi:V(G)\\to V(H) such that ϕ​(u)​ϕ​(v)∈E​(H)italic-ϕ𝑢italic-ϕ𝑣𝐸𝐻\\phi(u)\\phi(v)\\in E(H) for every u​v∈E​(G)𝑢𝑣𝐸𝐺uv\\in E(G). Graph homomorphisms generalise graph colourings (let H𝐻H be a complete graph) and have been intensively studied over a long period of time, both from a structural and an algorithmic perspective. We refer to the textbook of Hell and Nešetřil  for a further introduction. We write G→H→𝐺𝐻G\\to H if there exists a homomorphism from G𝐺G to H𝐻H; here, G𝐺G is called the guest graph and H𝐻H is the host graph.\nWe denote the corresponding decision problem by Hom, and if H𝐻H is fixed, that is, not part of the input, we write H𝐻H-Hom. The renowned Hell-Nešetřil dichotomy  states that H𝐻H-Hom is polynomial-time solvable if H𝐻H is bipartite, and NP-complete otherwise.\nWe denote the vertices of H𝐻H by 1,…,|V​(H)|1…𝑉𝐻1,\\ldots,|V(H)| and call them colours.\nThe reason for doing this is that graph homomorphisms generalise graph colourings: there exists a homomorphism from a graph G𝐺G to the complete graph on k𝑘k vertices if and only if G𝐺G is k𝑘k-colourable. Instead of fixing the host graph H𝐻H, one can also restrict the\nstructure of the guest graph G𝐺G by bounding some graph\nparameter. A classical result states that Hom is polynomial-time solvable when the guest graph G𝐺G has bounded treewidth  . The core of a graph G𝐺G is the subgraph F𝐹F of G𝐺G such that G→F→𝐺𝐹G\\to F and there is no proper subgraph F′superscript𝐹′F^{\\prime} of F𝐹F with G→F′→𝐺superscript𝐹′G\\to F^{\\prime}\n(the core is unique up to isomorphism ).\nDalmau, Kolaitis and Vardi  proved that the Hom problem is polynomial-time solvable even if the core of the guest graph G𝐺G has bounded treewidth. This result was strengthened by Grohe , who proved that if FPT≠W​FPTWdelimited-[]1{\\mbox{{{FPT}}}}\\neq{{{\\mbox{{{W}}}}}}{{{}}}, then Hom can be solved in polynomial time if and only if this condition holds. Locally constrained homomorphisms. We are interested in three well-studied variants of graph homomorphisms that occur after placing constraints on the neighbourhoods of the vertices of the guest graph G𝐺G.\nConsider a homomorphism ϕitalic-ϕ\\phi from a graph G𝐺G to a graph H𝐻H.\nWe say that ϕitalic-ϕ\\phi is locally injective, locally bijective or locally surjective for u∈V​(G)𝑢𝑉𝐺u\\in V(G) if\nthe restriction ϕusubscriptitalic-ϕ𝑢\\phi_{u} to the neighbourhood\nNG​(u)={v|u​v∈E​(G)}subscript𝑁𝐺𝑢conditional-set𝑣𝑢𝑣𝐸𝐺N_{G}(u)=\\{v\\;|\\;uv\\in E(G)\\}\nof u𝑢u is injective, bijective or surjective. We say that\nϕitalic-ϕ\\phi is locally injective, locally bijective or locally surjective if it is locally injective, locally bijective, or locally surjective for every u∈V​(G)𝑢𝑉𝐺u\\in V(G).\nWe denote these locally constrained homomorphisms by\nG→B⁡H𝐵→𝐺𝐻G\\xrightarrow{{}_{B}}H, G→I⁡H𝐼→𝐺𝐻G\\xrightarrow{{}_{I}}H and G→S⁡H𝑆→𝐺𝐻G\\xrightarrow{{}_{S}}H, respectively. The three variants have been well studied in several settings over a long period of time. For example, locally injective homomorphisms are also known as partial graph coverings and are used in telecommunications , in distance constrained labelling  and as indicators of the existence of homomorphisms of derivative graphs . Locally bijective homomorphisms originate from topological graph theory   and are more commonly known as graph coverings. They are used in distributed\ncomputing    and in constructing highly transitive regular graphs . Locally surjective homomorphisms are sometimes called colour dominations 2. They have applications in distributed computing 2 3 and in social science 6   . In the latter context they are known as role assignments, as we will explain in more detail below. Let LBHom, LIHom and LSHom be the three problems of deciding, for two graphs G𝐺G and H𝐻H, whether G→B⁡H𝐵→𝐺𝐻G\\xrightarrow{{}_{B}}H, G→I⁡H𝐼→𝐺𝐻G\\xrightarrow{{}_{I}}H or G→S⁡H𝑆→𝐺𝐻G\\xrightarrow{{}_{S}}H holds, respectively. As before, we write\nH𝐻H-LBHom, H𝐻H-LIHom and H𝐻H-LSHom in the case where the host graph H𝐻H is fixed.\nOut of the three problems, only the complexity of H𝐻H-LSHom has been completely classified, both for general graphs and bipartite graphs 2. We refer to a series of papers    1 9 0 5 for polynomial-time solvable and NP-complete cases of H𝐻H-LBHom and H𝐻H-LIHom; see also the survey by Fiala and Kratochvíl 0. Some more recent results include sub-exponential algorithms for H𝐻H-LBHom, H𝐻H-LIHom and H𝐻H-LSHom on string graphs 0 and complexity results for H𝐻H-LBHom for host graphs H𝐻H that are multigraphs 1 or that have semi-edges . In our paper we assume that both G𝐺G and H𝐻H are part of the input.\nWe note a fundamental difference between locally injective homomorphisms on one hand and locally bijective and surjective homomorphisms on the other hand. Namely, for connected graphs G𝐺G and H𝐻H, we must have\n|V​(G)|≥|V​(H)|𝑉𝐺𝑉𝐻|V(G)|\\geq|V(H)| if G→B⁡H𝐵→𝐺𝐻G\\xrightarrow{{}_{B}}H or G→S⁡H𝑆→𝐺𝐻G\\xrightarrow{{}_{S}}H, whereas H𝐻H might be arbitrarily larger than G𝐺G if G→I⁡H𝐼→𝐺𝐻G\\xrightarrow{{}_{I}}H holds. For example, if we let G𝐺G be a complete graph, then G→I⁡H𝐼→𝐺𝐻G\\xrightarrow{{}_{I}}H holds if and only if H𝐻H contains a clique on at least |V​(G)|𝑉𝐺|V(G)| vertices. The above difference is also reflected in the complexity results for the three problems under input restrictions.\nIn fact, LIHom is closely related to the Subgraph Isomorphism problem and is usually the\nhardest problem. For example, LBHom is Graph Isomorphism-complete on chordal guest graphs, but polynomial-time solvable on interval\nguest\ngraphs and LSHom is NP-complete on chordal guest graphs, but polynomial-time solvable on proper interval\nguest\ngraphs 1.\nIn contrast, LIHom is NP-complete even on complete guest graphs G𝐺G, which follows from a reduction from the Clique problem via the aforementioned equivalence: G→I⁡H𝐼→𝐺𝐻G\\xrightarrow{{}_{I}}H holds if and only if H𝐻H contains a clique on at least |V​(G)|𝑉𝐺|V(G)| vertices. To give another example,\nLBHom, LSHom and LIHom are NP-complete for guest graphs G𝐺G of path-width at most 555, 444 and 222, respectively 5 (all three problems are polynomial-time solvable if G𝐺G is a tree 5 3).\nNote that these hardness results imply that the aforementioned polynomial-time result on Hom for guest graphs G𝐺G of bounded treewidth   does not carry over to any of the three locally constrained homomorphism problems. It is also known that LBHom 8, LSHom 2 and\nLIHom  are NP-complete even if G𝐺G is cubic and H𝐻H is the complete graph K4subscript𝐾4K_{4} on four vertices, but\npolynomial-time solvable if G𝐺G has bounded treewidth and one of the two graphs G𝐺G or H𝐻H has bounded maximum degree 5. An Application. Locally surjective homomorphisms from a graph G𝐺G to a graph H𝐻H are known as H𝐻H-role assignments in social network theory. We will include this topic in our investigation and provide some brief context.\nSuppose we are given a social network of individuals whose properties we aim to characterise. Can we assign each individual a role such that individuals with the same role relate in the same way to other individuals with some role, using exactly hℎh different roles in total?\nTo formalise this question, we model the network as a graph G𝐺G, where vertices represent individuals and edges represent the existence of a relationship between two individuals.\nWe now ask whether G𝐺G has\nan hℎh-role assignment, that is, a function f𝑓f that assigns each vertex u∈V​(G)𝑢𝑉𝐺u\\in V(G) a role f​(u)∈{1,…,h}𝑓𝑢1…ℎf(u)\\in\\{1,\\ldots,h\\}, such that f​(V​(G))={1,…,h}𝑓𝑉𝐺1…ℎf(V(G))=\\{1,\\ldots,h\\} and for every two vertices u𝑢u and v𝑣v, if f​(u)=f​(v)𝑓𝑢𝑓𝑣f(u)=f(v) then f​(NG​(u))=f​(NG​(v))𝑓subscript𝑁𝐺𝑢𝑓subscript𝑁𝐺𝑣f(N_{G}(u))=f(N_{G}(v)). Role assignments were introduced\nby White and Reitz  as regular equivalences and were called role colourings by Everett and Borgatti 6.\nWe observe that two adjacent vertices u𝑢u and v𝑣v may have the same role, that is, f​(u)=f​(v)𝑓𝑢𝑓𝑣f(u)=f(v) is allowed (so role assignments are not proper colourings).\nHence, a connected graph G𝐺G has an hℎh-role assignment if and only if G→S⁡H𝑆→𝐺𝐻G\\xrightarrow{{}_{S}}H for some connected graph H𝐻H with |V​(H)|=h𝑉𝐻ℎ|V(H)|=h, as long as we allow H𝐻H to have self-loops (while we assume that G𝐺G is a graph with no self-loops). The Role Assignment problem is to decide, for a graph G𝐺G and an integer hℎh, whether G𝐺G has an hℎh-role assignment. If hℎh is fixed, we denote the problem hℎh-Role Assignment. Whereas 111-Role Assignment is trivial, 222-Role Assignment is NP-complete . In fact, hℎh-Role Assignment is NP-complete for planar graphs (h≥2)ℎ2(h\\geq 2) 4, cubic graphs (h≥2)ℎ2(h\\geq 2) 5, bipartite graphs (h≥3)ℎ3(h\\geq 3) 2, chordal graphs (h≥3)ℎ3(h\\geq 3) 8 and split graphs (h≥4)ℎ4(h\\geq 4) 0.\nVery recently, Pandey, Raman and Sahlo 1 gave an n𝒪​(h)superscript𝑛𝒪ℎn^{\\mathcal{O}(h)}-time algorithm for Role Assignment on general graphs and an f​(h)​n𝒪​(1)𝑓ℎsuperscript𝑛𝒪1f(h)n^{\\mathcal{O}(1)}-time algorithm on forests. Our Focus. We continue the line of study in 5 and focus on the following research question: For which parameters of the guest graph do LBHom, LSHom and LIHom become fixed-parameter tractable? We will also apply our new techniques towards answering this question for the Role Assignment problem.\nIn order to address our research question, we need some additional terminology.\nA graph parameter p𝑝p dominates a parameter q𝑞q if there is a function f𝑓f such that p​(G)≤f​(q​(G))𝑝𝐺𝑓𝑞𝐺p(G)\\leq f(q(G)) for every graph G𝐺G.\nIf p𝑝p dominates q𝑞q but q𝑞q does not dominate p𝑝p, then p𝑝p is more powerful (less restrictive) than q𝑞q. We denote this by p⊳qcontains-as-subgroup𝑝𝑞p\\rhd q.\nIf neither p𝑝p dominates q𝑞q nor q𝑞q dominates p𝑝p, then p𝑝p and q𝑞q are incomparable (orthogonal).\nGiven the para-NP-hardness results on LBHom, LSHom and LIHom for graph classes of bounded path-width 5, we will consider a range of graph parameters that are less powerful than path-width. In this way we aim to increase our understanding of the (parameterized) complexity of LBHom, LSHom and LIHom. For an integer c≥1𝑐1c\\geq 1, a c𝑐c-deletion set of a graph G𝐺G is a subset S⊆V​(G)𝑆𝑉𝐺S\\subseteq V(G) such that every connected component of G∖S𝐺𝑆G\\setminus S has at most c𝑐c vertices. The c𝑐c-deletion set number dsc​(G)subscriptds𝑐𝐺{\\textup{ds}_{c}}(G) of a graph G𝐺G is the minimum size of a c𝑐c-deletion set in G𝐺G. If c=1𝑐1c=1, then we obtain the vertex cover number vc​(G)vc𝐺{\\textup{vc}}(G) of G𝐺G.\nThe c𝑐c-deletion set number is also known as vertex integrity 3.\nIt is closely related to the fracture number fr​(G)fr𝐺{\\textup{fr}}(G),\nintroduced in 4, which is the minimum k𝑘k such that G𝐺G has a k𝑘k-deletion set on at most k𝑘k vertices.\nNote that fr​(G)≤max⁡{c,dsc​(G)}fr𝐺𝑐subscriptds𝑐𝐺{\\textup{fr}}(G)\\leq\\max\\{c,{\\textup{ds}_{c}}(G)\\} holds for every integer c𝑐c.\nThe feedback vertex set number fv​(G)fv𝐺{\\textup{fv}}(G) of a graph G𝐺G is the size of a smallest set S𝑆S such that G∖S𝐺𝑆G\\setminus S is a forest.\nWe write tw​(G)tw𝐺{\\textup{tw}}(G), pw​(G)pw𝐺{\\textup{pw}}(G) and td​(G)td𝐺{\\textup{td}}(G) for the treewidth, path-width and tree-depth of a graph G𝐺G, respectively; see 9 for more information,\nin particular on tree-depth. It is known that where the second relationship is proven\nin [ref]8 and the others follow immediately from their definitions (see also Section 2.2).\nIt is readily seen that and that fv​(G)fv𝐺{\\textup{fv}}(G) is incomparable with the parameters pw​(G)pw𝐺{\\textup{pw}}(G), td​(G)td𝐺{\\textup{td}}(G), fr​(G)fr𝐺{\\textup{fr}}(G) and dsc​(G)subscriptds𝑐𝐺{\\textup{ds}_{c}}(G) for every fixed\nc≥3𝑐3c\\geq 3\n(consider e.g. a tree of arbitrarily large path-width and\nthe disjoint union of arbitrarily many triangles). Our Results.\nWe prove a number of new parameterized complexity results for LBHom, LSHom and LIHom by taking some property of the guest graph G𝐺G as the parameter. In particular, we consider the graph parameters above.\nOur two main results, which are proven in Section 4, show that LBHom and LSHom are fixed-parameter tractable\nparameterized by the fracture number of G𝐺G.\nThese two results cannot be strengthened to the tree-depth of the guest graph, for which we prove para-NP-completeness in Section 6. Note that the latter results imply the known para-NP-completeness results for path-width of the guest graph 5.\nIn Section 6 we also prove that LBHom and LSHom are para-NP-complete when parameterized by the feedback vertex set number of the guest graph. This result and the para-NP-hardness for tree-depth motivated us to consider the fracture number as a natural remaining graph parameter for obtaining an fpt algorithm. The above para-NP-completeness results for LBHom in fact even hold for 333-FoldCover,\nthe restriction of LBHom to input pairs (G,H)𝐺𝐻(G,H) where |V​(G)|=3​|V​(H)|𝑉𝐺3𝑉𝐻|V(G)|=3|V(H)|. The k𝑘k-FoldCover problem was introduced in  (where it was called the k𝑘k-Graph Covering problem).\nIn fact, the aforementioned result of 5 on LBHom for path-width is the first proof that 333-FoldCover is NP-complete, and the proof can easily be adapted for k≥4𝑘4k\\geq 4, as observed by Klavík 7. In Section 5 we prove that LIHom is in XP and W-hard when parameterized by the vertex cover number, or equivalently, the c𝑐c-deletion set number for c=1𝑐1c=1. We then show that the XP-result for LIHom cannot be generalised to hold for c≥2𝑐2c\\geq 2.\nIn fact, in the same section, we will determine the complexity of LIHom on graphs with c𝑐c-deletion set number at most k𝑘k for every fixed pair of integers c𝑐c and k𝑘k.\nOur results for LBHom, LSHom and LIHom are summarised, together with the known results, in Table 1. Algorithmic Framework.\nThe FPT algorithms for LBHom and LSHom are proven via a new\nalgorithmic framework (described in detail in Section 3)\nthat involves a reduction to an integer linear program (ILP) that has\na wider applicability. To illustrate this, in Section 4\nwe also use our general framework to prove that Role Assignment\nis FPT when parameterized by c+dsc𝑐subscriptds𝑐c+{\\textup{ds}_{c}}.\nWe emphasize that in our framework the host graph H𝐻H is not fixed,\nbut part of the input, in contrast to other frameworks that include\nthe locally constrained homomorphism problems (and that consequently\nwork for more powerful graph parameters), such as the framework of\nlocally checkable vertex partitioning problems 0 7 or\nthe framework of Gerber and Kobler 9 based on (feasible) interval degree constraint matrices. Techniques.\nThe main ideas behind our algorithmic ILP framework are as\nfollows. Let G𝐺G and H𝐻H be the guest and host graphs, respectively.\nFirst, we observe that if G𝐺G has a\nc𝑐c-deletion of size at most k𝑘k and there is a locally surjective\nhomomorphism from G𝐺G to H𝐻H, then H𝐻H must also have a\nc𝑐c-deletion set of size at most k𝑘k.\nHowever it does not suffice to compute c𝑐c-deletion sets\nDGsubscript𝐷𝐺D_{G} and DHsubscript𝐷𝐻D_{H} for G𝐺G and H𝐻H, guess a partial homomorphism hℎh\nfrom DGsubscript𝐷𝐺D_{G} to DHsubscript𝐷𝐻D_{H}, and use the structural properties of c𝑐c-deletion\nsets to decide whether hℎh can be extended to\na desired homomorphism from G𝐺G to H𝐻H. This is because\na homomorphism from G𝐺G to H𝐻H does not necessarily map DGsubscript𝐷𝐺D_{G} to DHsubscript𝐷𝐻D_{H}.\nMoreover, even if it did, vertices in G∖DG𝐺subscript𝐷𝐺G\\setminus D_{G} can still be mapped to vertices in DHsubscript𝐷𝐻D_{H}.\nConsequently, components of G∖DG𝐺subscript𝐷𝐺G\\setminus D_{G} can still be mapped to more than one\ncomponent of H∖DH𝐻subscript𝐷𝐻H\\setminus D_{H}. This makes it difficult to decompose the\nhomomorphism from G𝐺G to H𝐻H into small independent parts.\nTo overcome this challenge, we\nprove that there are small sets DGsubscript𝐷𝐺D_{G} and DHsubscript𝐷𝐻D_{H} of vertices in G𝐺G and\nH𝐻H, respectively, such that every locally surjective homomorphism\nfrom G𝐺G to H𝐻H satisfies: \n the pre-image of DHsubscript𝐷𝐻D_{H} is a subset of DGsubscript𝐷𝐺D_{G}, DHsubscript𝐷𝐻D_{H} is a c′superscript𝑐′c^{\\prime}-deletion set for H𝐻H for some c′superscript𝑐′c^{\\prime} bounded in\nterms of only c+k𝑐𝑘c+k, and all but at most k𝑘k components of G∖DG𝐺subscript𝐷𝐺G\\setminus D_{G} have at most c𝑐c vertices and, while the remaining\ncomponents can be arbitrary large, their treewidth is bounded in terms\nof c+k𝑐𝑘c+k.\n As DGsubscript𝐷𝐺D_{G} and DHsubscript𝐷𝐻D_{H} are small, we can enumerate all possible\nhomomorphisms\nfrom some subset of DGsubscript𝐷𝐺D_{G} to DHsubscript𝐷𝐻D_{H}. Condition 2 allows us to show that any locally\nsurjective homomorphism from G𝐺G to H𝐻H can be decomposed into locally\nsurjective homomorphisms from a small set of components of G∖DG𝐺subscript𝐷𝐺G\\setminus D_{G} (plus DGsubscript𝐷𝐺D_{G}) to one component of H∖DH𝐻subscript𝐷𝐻H\\setminus D_{H} (plus DHsubscript𝐷𝐻D_{H}). This\nenables us to formulate the question of whether\na homomorphism from a subset of DGsubscript𝐷𝐺D_{G} to a subset of DHsubscript𝐷𝐻D_{H}\ncan be extended to a desired homomorphism from G𝐺G to H𝐻H\nin terms of an ILP. Finally, Condition 3 allows us to efficiently\ncompute the possible parts of the decomposition, that is, which (small) sets of\ncomponents of G∖DG𝐺subscript𝐷𝐺G\\setminus D_{G} can be mapped to which components of DHsubscript𝐷𝐻D_{H}.\n\nReference markers found: [8]\n\nContext windows for each [ref]:\n[ref]8: for the treewidth, path-width and tree-depth of a graph G𝐺G, respectively; see 9 for more information,\nin particular on tree-depth. It is known that where the second relationship is proven\nin [ref]8 and the others follow immediately from their definitions (see also Section 2.2).\nIt is readily seen that and that fv​(G)fv𝐺{\\textup{fv}}(G) is incomparable with the parameters\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 8,\n            \"titles\": [\n                \"Computational Complexity of Covering Two-vertex Multigraphs with Semi-edges\",\n                \"On the complexity and combinatorics of covering finite complexes\",\n                \"Local and global properties in networks of processors (extended abstract)\",\n                \"Finite common coverings of pairs of regular graphs\",\n                \"Algebraic Graph Theory\",\n                \"Constructing 555-arc transitive cubic graphs\",\n                \"Locally injective homomorphism to the simple weight graphs\",\n                \"The classification of coverings of processor networks\",\n                \"Approximating treewidth, pathwidth, frontsize, and shortest elimination tree\",\n                \"Fast dynamic programming for locally checkable vertex subset and vertex partitioning problems\",\n                \"Local computations on closed unlabelled edges: The election problem and the naming problem\",\n                \"Local computations in graphs: The case of cellular edge local computations\",\n                \"Graph labelings derived from models in distributed computing: A complete complexity classification\",\n                \"Packing bipartite graphs with covers of complete bipartite graphs\",\n                \"Locally constrained homomorphisms on graphs of bounded treewidth and bounded degree\",\n                \"Conjunctive query containment revisited\",\n                \"Parameterized Algorithms\",\n                \"Constraint satisfaction, bounded treewidth, and finite-variable logics\",\n                \"Graph Theory, volume 173 of Graduate Texts in Mathematics\",\n                \"Computing role assignments of split graphs\",\n                \"Fixed-parameter tractability and completeness II: on completeness for W[1]\",\n                \"Fundamentals of Parameterized Complexity\",\n                \"On the computational complexity of vertex integrity and component order connectivity\",\n                \"Solving integer linear programs with a small number of global variables and constraints\",\n                \"Paths, trees, and flowers\",\n                \"Role colouring a graph\",\n                \"Graph layout problems parameterized by vertex cover\",\n                \"Fixed-parameter complexity of lambda-labelings\",\n                \"Partial covers of graphs\",\n                \"Locally constrained graph homomorphisms - structure, complexity, and applications\",\n                \"On the computational complexity of partial covers of theta graphs\",\n                \"A complete complexity classification of the role assignment problem\",\n                \"Comparing universal covers in polynomial time\",\n                \"Dichotomy of the H𝐻{H}-Quasi-Cover problem\",\n                \"Parameterized Complexity Theory, volume XIV of Texts in Theoretical Computer Science. An EATCS Series\",\n                \"An application of simultaneous diophantine approximation in combinatorial optimization\",\n                \"Complexity of k𝑘k-tree structured constraint satisfaction problems\",\n                \"Computers and Intractability: A Guide to the Theory of NP-Completeness\",\n                \"Algorithms for vertex-partitioning problems on graphs with fixed clique-width\",\n                \"The complexity of homomorphism and constraint satisfaction problems seen from the other side\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]8 based on the context and research area of An Algorithmic Framework for Locally Constrained Homomorphisms. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}