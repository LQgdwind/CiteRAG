{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: Pruning and Quantization for Deep Neural Network Acceleration: A Survey\n\nPaper Abstract: \n\nPaper Section Text:\nAs a result of network redundancy, neurons or connections can often be removed without significant loss of accuracy.\nAs shown in EquationÂ 1, the core operation of a network is a convolution operation. It involves three parts: 1) input features as produced by the previous layer, 2) weights produced from the training phase, and 3) bias values produced from the training phase. The output of the convolution operation may result in either zero valued weights or features that lead to a zero output. Another possibility is that similar weights or features may be produced. These may be merged for distributive convolutions. An early method to prune networks is brute-force pruning. In this method the entire network is traversed element-wise and weights that do not affect accuracy are removed. A disadvantage of this approach is the large solution space to traverse.\nA typical metric to determine which values to prune is given by the lpâ€‹-norm, s.t.Â â€‹pâˆˆ{N,âˆ}subscriptğ‘™ğ‘-norm, s.t.Â ğ‘ğ‘l_{p}\\text{-norm, s.t. }p\\in\\{N,\\infty\\}, where Nğ‘N is natural number. The lpsubscriptğ‘™ğ‘l_{p}-norm of a vector ğ±ğ±\\mathbf{x} which consists of nğ‘›n elements is mathematically described by EquationÂ 5. Among the widely applied measurements, the l1subscriptğ‘™1l_{1}-norm is also known as the Manhattan norm and the l2subscriptğ‘™2l_{2}-norm is also known as the Euclidean norm.\nThe corresponding l1subscriptğ‘™1l_{1} and l2subscriptğ‘™2l_{2} regularization have the names LASSO (least absolute shrinkage and selection operator) and Ridge, respectively .\nThe difference between the l2subscriptğ‘™2l_{2}-norm pruned tensor and an unpruned tensor is called the l2subscriptğ‘™2l_{2}-distance.\nSometimes researchers also use the term l0subscriptğ‘™0l_{0}-norm defined as the total number of nonzero elements in a vector. Equation EquationÂ 6 mathematically describes l2subscriptğ‘™2l_{2} LASSO regularization. Consider a sample consisting of Nğ‘N cases, each of which consists of pğ‘p covariates and a single outcome yisubscriptğ‘¦ğ‘–y_{i}. Let xi=(xiâ€‹1,â€¦,xiâ€‹p)Tsuperscriptğ‘¥ğ‘–superscriptsubscriptğ‘¥ğ‘–1â€¦subscriptğ‘¥ğ‘–ğ‘ğ‘‡x^{i}=(x_{i1},...,x_{ip})^{T} be the standardized covariate vector for the iğ‘–i-th case (input feature in DNNs), so we have âˆ‘ixiâ€‹j/N=0,âˆ‘ixiâ€‹j2/N=1formulae-sequencesubscriptğ‘–subscriptğ‘¥ğ‘–ğ‘—ğ‘0subscriptğ‘–superscriptsubscriptğ‘¥ğ‘–ğ‘—2ğ‘1\\sum_{i}x_{ij}/N=0,\\ \\sum_{i}x_{ij}^{2}/N=1. Î²ğ›½\\beta represents the coefficients Î²=(Î²1,â€¦,Î²p)Tğ›½superscriptsubscriptğ›½1â€¦subscriptğ›½ğ‘ğ‘‡{\\beta}=({\\beta_{1}},...,{\\beta_{p}})^{T} (weights) and tğ‘¡t is a predefined tunning parameter that determines the sparsity. The LASSO estimate Î±ğ›¼\\alpha is 0 when the average of yisubscriptğ‘¦ğ‘–y_{i} is 0 because for all tğ‘¡t, the solution for Î±ğ›¼\\alpha is Î±=yÂ¯ğ›¼Â¯ğ‘¦\\alpha=\\overline{y}. If the constraint is âˆ‘jpÎ²j2â©½tsuperscriptsubscriptğ‘—ğ‘superscriptsubscriptğ›½ğ‘—2ğ‘¡\\sum_{j}^{p}\\beta_{j}^{2}\\leqslant t then the EquationÂ 6 becomes Ridge regression. Removing the constraint will results in the Ordinary Least Squares (OLS) solution. EquationÂ 6 can be simplified into the so-called Lagrangian form shown in EquationÂ 7. The Lagrangian multiplier translates the objective function fâ€‹(x)ğ‘“ğ‘¥f(x) and constraint gâ€‹(x)=0ğ‘”ğ‘¥0g(x)=0 into the format of â„’â€‹(x,Î»)=fâ€‹(x)âˆ’Î»â€‹gâ€‹(x)â„’ğ‘¥ğœ†ğ‘“ğ‘¥ğœ†ğ‘”ğ‘¥\\mathcal{L}(x,\\lambda)=f(x)-\\lambda g(x), Where the âˆ¥â‹…âˆ¥p\\|\\cdot\\|_{p} is the standard lpâ€‹-normsubscriptğ‘™ğ‘-norml_{p}\\text{-norm}, the ğ—ğ—\\mathbf{X} is the covariate matrix that contains xiâ€‹jsubscriptğ‘¥ğ‘–ğ‘—x_{ij}, and Î»ğœ†\\lambda is the data dependent parameter related to tğ‘¡t from EquationÂ 6. Both magnitude-based pruning and penalty based pruning may generate zero values or near-zero values for the weights. In this section we discuss both methods and their impact. It has been proposed and is widely accepted that trained weights with large values are more important than trained weights with smaller values . This observation is the key to magnitude-based methods.\nMagnitude-based pruning methods seek to identify unneeded weights or features to remove them from runtime evaluation. Unneeded values may be pruned either in the kernel or at the activation map. The most intuitive magnitude-based pruning methods is to prune all zero-valued weights or all weights within an absolute value threshold. LeCun as far back as 1990 proposed Optimal Brain Damage (OBD) to prune single non-essential weights . By using the second derivative (Hessian matrix) of the loss function, this static pruning technique reduced network parameters by a quarter. For a simplified derivative computation, OBD functions under three assumptions: 1) quadratic - the cost function is near-quadratic, 2) extremal - the pruning is done after the network converged, and 3) diagonal - sums up the error of individual weights by pruning the result of the error caused by their co-consequence.\nThis research also suggested that the sparsity of DNNs could provide opportunities to accelerate network performance.\nLater Optimal Brain Surgeon (OBS) [ref]97 extended OBD with a similar second-order method but removed the diagonal assumption in OBD. OBS considers the Hessian matrix is usually non-diagonal for most applications. OBS improved the neuron removal precision with up to a 90% reduction in weights for XOR networks. These early methods reduced the number of connections based on the second derivative of the loss function. The training procedure did not consider future pruning but still resulted in networks that were amenable to pruning. They also suggested that methods based on Hessian pruning would exhibit higher accuracy than those pruned with only magnitude-based algorithms [ref]97.\nMore recent DNNs exhibit larger weight values when compared to early DNNs. Early DNNs were also much shallower with orders of magnitude less neurons. GPT-3 , for example, contains 175-billion parameters while VGG-16  contains just 133-million parameters. Calculating the Hessian matrix during training for networks with the complexity of GPT-3 is not currently feasible as it has the complexity of Oâ€‹(W2)ğ‘‚superscriptğ‘Š2O(W^{2}). Because of this simpler magnitude-based algorithms have been developed  . Filter-wise pruning  uses the l1subscriptğ‘™1l_{1}-norm to remove filters that do not affect the accuracy of the classification. Pruning entire filters and their related feature maps resulted in a reduced inference cost of 34% for VGG-16 and 38% for ResNet-110 on the CIFAR-10 dataset with improved accuracy 0.75% and 0.02%, respectively. Most network pruning methods choose to measure weights rather than activations when rating the effectiveness of pruning [ref]88.\nHowever, activations may also be an indicator to prune corresponding weights. Average Percentage Of Zeros (APoZ)  was introduced to judge if one output activation map is contributing to the result. Certain activation functions, particularly rectification such as Rectified Linear Unit (ReLU), may result in a high percentage of zeros in activations and thus be amenable to pruning. EquationÂ 8 shows the definition of APoZc(i)superscriptsubscriptAPoZğ‘ğ‘–\\operatorname{APoZ}_{c}^{(i)} of the cğ‘c-th neuron in the iğ‘–i-th layer, where ğc(i)superscriptsubscriptğğ‘ğ‘–\\mathbf{O}_{c}^{(i)} denotes the activation, Nğ‘N is the number of calibration (validation) images, and Mğ‘€M is the dimension of activation map. fâ€‹(true)=1ğ‘“true1f(\\text{true})=1 and fâ€‹(false)=0ğ‘“false0f(\\text{false})=0. Similarly, inbound pruning [ref]195, also an activation technique, considers channels that do not contribute to the result. If the top activation channel in the standard convolution of FigureÂ 2 are determined to be less contributing, the corresponding channel of the filter in the bottom of the figure will be removed. After pruning this technique achieved about 1.5Ã—1.5\\times compression. Filter-wise pruning using a threshold from the sum of filtersâ€™ absolute values can directly take advantage of the structure in the network. In this way, the ratio of pruned to unpruned neurons (i.e. the pruning ratio) is positively correlated to the percentage of kernel weights with zero values, which can be further improved by penalty-based methods.\n In penalty-based pruning, the goal is to modify an error function or add other constraints, known as bias terms, in the training process. A penalty value is used to update some weights to zero or near zero values. These values are then pruned. Hanson  explored hyperbolic and exponential bias terms for pruning in the late 80s. This method uses weight decay in backpropagation to determine if a neuron should be pruned. Low-valued weights are replaced by zeros. Residual zero valued weights after training are then used to prune unneeded neurons. Feature selection  is a technique that selects a subset of relevant features that contribute to the result. It is also known as attribute selection or variable selection. Feature selection helps algorithms avoiding over-fitting and accelerates both training and inference by removing features and/or connections that donâ€™t contribute to the results. Feature selection also aids model understanding by simplifying them to the most important features. Pruning in DNNs can be considered to be a kind of feature selection . LASSO was previously introduced as a penalty term. LASSO shrinks the least absolute valued featureâ€™s corresponding weights. This increases weight sparsity. This operation is also referred to as LASSO feature selection and has been shown to perform better than traditional procedures such as OLS by selecting the most significantly contributed variables instead of using all the variables. This lead to approximately 60% more sparsity than OLS . Element-wise pruning may result in an unstructured network organizations. This leads to sparse weight matrices that are not efficiently executed on instruction set processors. In addition they are usually hard to compress or accelerate without specialized hardware support . Group LASSO 0 mitigates these inefficiencies by using a structured pruning method that removes entire groups of neurons while maintaining structure in the network organization . Group LASSO is designed to ensure that all the variables sorted into one group could be either included or excluded as a whole. EquationÂ 9 gives the pruning constraint where ğ—ğ—\\mathbf{X} and Î²ğ›½\\beta in EquationÂ 7 are replaced by the higher dimensional ğ—ğ£subscriptğ—ğ£\\mathbf{X_{j}} and Î²jsubscriptğ›½ğ‘—\\beta_{j} for the jğ‘—j groups. FigureÂ 10 shows Group LASSO with group shapes used in Structured Sparsity Learning (SSL) . Weights are split into multiple groups. Unneeded groups of weights are removed using LASSO feature selection. Groups may be determined based on geometry, computational complexity, group sparsity, etc. SSL describes an example where group sparsity in row and column directions may be used to reduce the execution time of GEMM. SSL has shown improved inference times on AlexNet with both CPUs and GPUs by 5.1Ã—5.1\\times and 3.1Ã—3.1\\times, respectively. Group-wise brain damage  also introduced the group LASSO constraint but applied it to filters. This simulates brain damage and introduces sparsity. It achieved 2Ã—2\\times speedup with 0.7% ILSVRC-2012 accuracy loss on the VGG Network. Sparse Convolutional Neural Networks (SCNN)  take advantage of two-stage tensor decomposition. By decomposing the input feature map and convolutional kernels, the tensors are transformed into two tensor multiplications. Group LASSO is then applied. SCNN also proposed a hardware friendly algorithm to further accelerate sparse matrix computations. They achieved 2.47Ã—2.47\\times to 6.88Ã—6.88\\times speed-up on various types of convolution. Network slimming  applies LASSO on the scaling factors of BN. BN normalizes the activation by statistical parameters which are obtained during the training phase. Network slimming has the effect of introducing forward invisible additional parameters without additional overhead.\nSpecifically, by setting the BN scaler parameter to zero, channel-wise pruning is enabled. They achieved 82.5% size reduction with VGG and 30.4% computation compression without loss of accuracy on ILSVRC-2012.\n Sparse structure selection  is a generalized network slimming method. It prunes by applying LASSO to sparse scaling factors in neurons, groups, or residual blocks. Using an improved gradient method, Accelerated Proximal Gradient (APG), the proposed method shows better performance without fine-tunning achieving 4Ã—4\\times speed-up on VGG-16 with 3.93% ILSVRC-2012 top-1 accuracy loss. While not specifically a technique to prune networks, dropout does reduce the number of parameters . It was originally designed as a stochastic regularizer to avoid over-fitting of data . The technique randomly omits a percentage of neurons typically up to 50%, This dropout operation breaks off part of the connections between neurons to avoid co-adaptations. Dropout could also be regarded as an operation that separately trains many sub-networks and takes the average of them during the inference phase. Dropout increases training overhead but it does not affect the inference time. Sparse variational dropout 6 added a dropout hyperparameter called the dropout rate to reduce the weights of VGG-like networks by 68Ã—68\\times. During training the dropout rate can be used to identify single weights to prune. This can also be applied with other compression approaches for further reduction in weights. The goal of norm-based pruning algorithms is to remove zeros. This implies that the distribution of values should wide enough to retain some values but contain enough values close to zero such that a smaller network organization is still accurate. This does not hold in some circumstances. For example, filters that have small norm deviations or a large minimum norm have small search spaces making it difficult to prune based on a threshold .\nEven when parameter values are wide enough, in some networks smaller values may still play an important role in producing results. One example of this is when large valued parameters saturate . In these cases magnitude-based pruning of zero values may decrease result accuracy. Similarly, penalty-based pruning may cause network accuracy loss. In this case, the filters identified as unneeded due to similar coefficient values in other filters may actually be required. Removing them may significantly decrease network accuracy [ref]88. SectionÂ 3.1.2 describes techniques to undo pruning by tuning the weights to minimize network loss while this section describes redundancy based pruning. Using BN parameters, feature map channel distances can be computed by layer 6. Using a clustering approach for distance, nearby features can be tuned. An advantage of clustering is that redundancy is not measured with an absolute distance but a relative value. With about 60 epochs of training they were able to prune the network resulting in a 50% reduction in FLOPs (including non-convolutional operations) with a reduction in accuracy of only 1% for both top-1 and top-5 on the ImageNet dataset. Filter pruning via geometric median (FPGM)  identifies filters to prune by measuring the l2subscriptğ‘™2l_{2}-distance using the geometric median. FPGM found 42% FLOPs reduction with 0.05% top-1 accuracy drop on ILSVRC-2012 with ResNet-101. The reduce and reused (also described as outbound)  method [ref]195 prunes entire filters by computing the statistical variance of each filterâ€™s output using a calibration set. Filters with low variance are pruned. The outbound method obtained 2.37Ã—2.37\\times acceleration with 1.52% accuracy loss on Labeled Faces in the Wild (LFW) dataset  in the filed of face recognition. A method that iteratively removes redundant neurons for FCLs without requiring special validation data is proposed in . This approach measures the similarity of weight groups after a normalization. It removes redundant weights and merges the weights into a single value. This lead to a 34.89% reduction of FCL weights on AlexNet with 2.24% top-1 accuracy loss on ILSVRC-2012. Comparing with the similarity based approach above, DIVersity NETworks (DIVNET)  considers the calculation redundancy based on the activations. DIVNET introduces Determinantal Point Process (DPP)  as a pruning tool. DPP sorts neurons into categories including dropped and retained. Instead of forcing the removal of elements with low contribution factors, they fuse the neurons by a process named re-weighting. Re-weighting works by minimizing the impact of neuron removal. This minimizes pruning influence and mitigates network information loss. They found 3% loss on CIFAR-10 dataset when compressing the network into half weight. ThiNet  adopts statistics information from the next layer to determine the importance of filters. It uses a greedy search to prune the channel that has the smallest reconstruction cost in the next layer. ThiNet prunes layer-by-layer instead of globally to minimize large errors in classification accuracy. It also prunes less during each training epoch to allow for coefficient stability. The pruning ratio is a predefined hyper-parameter and the runtime complexity is directly related to the pruning ratio. ThiNet compressed ResNet-50 FLOPs to 44.17% with a top-1 accuracy reduction of 1.87%. He  adopts LASSO regression instead of a greedy algorithm to estimate the channels. Specifically, in one iteration, the first step is to evaluate the most important channel using the l1subscriptğ‘™1l_{1}-norm. The next step is to prune the corresponding channel that has the smallest Mean Square Error (MSE). Compared to an unpruned network, this approach obtained 2Ã—2\\times acceleration of ResNet-50 on ILSVRC-2012 with about 1.4% accuracy loss on top-5, and a 4Ã—4\\times reduction in execution time with top-5 accuracy loss of 1.0% for VGG-16. The authors categorize their approach as dynamic inference-time channel pruning. However it requires 5000 images for calibration with 10 samples per image and more importantly results in a statically pruned network. Thus we have placed it under static pruning.\n\nReference markers found: [97]\n\nContext windows for each [ref]:\n[ref]97: of the error caused by their co-consequence.\nThis research also suggested that the sparsity of DNNs could provide opportunities to accelerate network performance.\nLater Optimal Brain Surgeon (OBS) [ref]97 extended OBD with a similar second-order method but removed the diagonal assumption in OBD. OBS considers the Hessian matrix is usually non-diagonal for most applications. OBS improved the\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 97,\n            \"titles\": [\n                \"ì¸ê³µì§€ëŠ¥ ê¸°ë°˜ ê³µê²© ê·¸ë˜í”„ ìƒì„±\",\n                \"TensorFlow: Large-Scale Machine Learning on Heterogeneous Distributed Systems\",\n                \"Convolutional Neural Networks for Speech Recognition\",\n                \"Accelerating CNN inference on FPGAs: A Survey\",\n                \"FPGAs Enable the Next Generation of Communication and Networking Solutions\",\n                \"convnet-burden\",\n                \"Ternary neural networks for resource-efficient AI applications\",\n                \"Radeon Instinctâ„¢ MI25 Accelerator\",\n                \"ARM Architecture Reference Manual ARMv8, for ARMv8-A architecture profile\",\n                \"Arm Cortex-M Processor Comparison Table\",\n                \"MALI-G76 High-Performance GPU for Complex Graphics Features and Bene ts High Performance for Mixed Realities\",\n                \"Neon technology introduction\",\n                \"Pruning algorithms of neural networks - A comparative study\",\n                \"PArallel Distributed Deep LEarning: Machine Learning Framework from Industrial Practice\",\n                \"Weight quantization in Boltzmann machines\",\n                \"Scalable Methods for 8-bit Training of Neural Networks\",\n                \"Post training 4-bit quantization of convolutional networks for rapid-deployment\",\n                \"Sparse Convolutional Neural Networks\",\n                \"UNIQ: Uniform Noise Injection for Non-Uniform Quantization of Neural Networks\",\n                \"Conditional computation in neural networks for faster models\",\n                \"Estimating or Propagating Gradients Through Stochastic Neurons\",\n                \"MeliusNet: Can Binary Neural Networks Achieve MobileNet-level Accuracy?\",\n                \"BinaryDenseNet: Developing an architecture for binary neural networks\",\n                \"Benchmark Analysis of Representative Deep Neural Network Architectures\",\n                \"What is the State of Neural Network Pruning?\",\n                \"Adaptive Neural Networks for Efficient Inference\",\n                \"Language Models are Few-Shot Learners\",\n                \"BUG1989/caffe-int8-convert-tools: Generate a quantization parameter file for ncnn framework int8 inference\",\n                \"Once-for-All: Train One Network and Specialize it for Efficient Deployment\",\n                \"SeerNet : Predicting Convolutional Neural Network Feature-Map Sparsity through Low-Bit Quantization\",\n                \"High Performance Convolutional Neural Networks for Document Processing, in: Tenth International Workshop on Frontiers in Handwriting Recognition\",\n                \"DianNao family: Energy-Efficient Hardware Accelerators for Machine Learning\",\n                \"Recent Advances in Efficient Computation of Deep Convolutional Neural Networks\",\n                \"A Survey of Model Compression and Acceleration for Deep Neural Networks\",\n                \"Training Binary Multilayer Neural Networks for Image Classification using Expectation Backpropagation\",\n                \"Solving local minima problem with large number of hidden nodes on two-layered feed-forward artificial neural networks\",\n                \"PACT: Parameterized Clipping Activation for Quantized Neural Networks\",\n                \"Towards the Limit of Network Quantization, in: International Conference on Learning Representations(ICLR), IEEE\",\n                \"Energy-Efficient Design of Processing Element for Convolutional Neural Network\",\n                \"A comprehensive survey on model compression and acceleration\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]97 based on the context and research area of Pruning and Quantization for Deep Neural Network Acceleration: A Survey. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}