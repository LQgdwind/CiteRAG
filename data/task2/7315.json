{
  "messages": [
    {
      "role": "system",
      "content": "You are a professional academic citation prediction expert. Your task is to predict the most likely citations for [ref] markers in academic paper sections based on the paper content and retrieved relevant papers.\n\nRETRIEVER INTERFACE:\n- Input: paper title + abstract + section text with [ref] markers\n- Output: top {top_r} retrieved papers with title and abstract\n- Format: List of dictionaries with 'title' and 'abstract' fields\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nTASK DESCRIPTION:\n- Input: Paper section text with [ref] markers + retrieved relevant papers\n- Output: top 40 predicted reference titles for each [ref] marker with reasoning\n- Format: JSON object with \"citations\" array containing objects with \"ref_index\", \"titles\", and \"reasoning\" fields\n\nREQUIREMENTS:\n1. Analyze the context around each [ref] marker to understand what reference is needed\n2. Consider the retrieved papers as potential references (when available)\n3. Consider the surrounding text, research area, and topic\n4. Generate realistic and relevant reference titles that would fit the context\n5. Provide detailed reasoning for each prediction to prevent hallucination\n6. Output format: JSON object with \"citations\" array\n7. Generate exactly 40 most relevant reference titles for each [ref]\n8. Ensure titles are realistic and appropriate for the research area\n9. Include reasoning that explains why each title is relevant to the specific [ref] context\n10. Use proper JSON escaping for special characters (escape quotes with \\\")\n11. Ensure all strings are properly quoted and escaped\n\nEXAMPLE:\nInput:\n\"Federated Learning aims to train models in massively distributed networks [ref]38 at a large scale [ref]5, over multiple sources of heterogeneous data [ref]30.\"\n\nRetrieved papers (top {top_r}):\n1. Title: Communication-efficient learning of deep networks from decentralized data\n   Abstract: We report on a series of experiments with federated learning systems for decentralized data training.\n\n2. Title: Federated Learning: Challenges, Methods, and Future Directions\n   Abstract: A comprehensive survey of federated learning approaches and challenges in distributed settings.\n\nOutput:\n{\n  \"citations\": [\n    {\n      \"ref_index\": 38,\n      \"titles\": [\n        \"Communication-efficient learning of deep networks from decentralized data\",\n        \"Federated Learning: Challenges, Methods, and Future Directions\",\n        \"Federated optimization in heterogeneous networks\",\n        \"Towards federated learning at scale: System design\",\n        \"A performance evaluation of federated learning algorithms\",\n        \"Distributed machine learning: A survey\",\n        \"Communication protocols for distributed learning\",\n        \"Scalable federated learning systems\",\n        \"Efficient distributed training algorithms\",\n        \"Large-scale distributed learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]38 appears in the context of 'massively distributed networks' for federated learning, so it likely refers to foundational papers on federated learning systems, distributed training, and communication-efficient methods in distributed networks.\"\n    },\n    {\n      \"ref_index\": 5,\n      \"titles\": [\n        \"Bagging predictors\",\n        \"Ensemble methods in machine learning\",\n        \"Random forests for classification\",\n        \"Bootstrap methods and their application\",\n        \"Combining multiple classifiers\",\n        \"Large-scale machine learning systems\",\n        \"Distributed ensemble methods\",\n        \"Scalable classification algorithms\",\n        \"Massive data processing techniques\",\n        \"High-performance machine learning frameworks\"\n      ],\n      \"reasoning\": \"This [ref]5 appears in the context of 'at a large scale', suggesting it refers to papers on scaling machine learning methods, ensemble techniques, or methods that can handle large-scale data and distributed settings.\"\n    },\n    {\n      \"ref_index\": 30,\n      \"titles\": [\n        \"Learning fair representations\",\n        \"Fair machine learning: A survey\",\n        \"Bias in machine learning systems\",\n        \"Addressing fairness in AI systems\",\n        \"Fair representation learning\",\n        \"Heterogeneous data handling methods\",\n        \"Multi-source learning algorithms\",\n        \"Cross-domain representation learning\",\n        \"Fair learning from diverse data\",\n        \"Bias mitigation in heterogeneous datasets\"\n      ],\n      \"reasoning\": \"This [ref]30 appears in the context of 'heterogeneous data' and 'fair representation learning', indicating it likely refers to papers on heterogenous data handling, bias mitigation, and learning representations that are fair across different data distributions.\"\n    }\n  ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped.\n\nIMPORTANT NOTES ON REASONING:\n- The reasoning field is crucial for preventing hallucination\n- Each reasoning should be specific to the context around the [ref] marker\n- Explain the connection between the predicted titles and the research topic\n- This helps validate that predictions are grounded in the actual content\n- Reasoning should be concise but informative (2-3 sentences)\n- Consider retrieved papers when available to improve prediction accuracy"
    },
    {
      "role": "user",
      "content": "Paper Title: Computationally Bounded Robust Compilation and Universally Composable Security\n\nPaper Abstract: \n\nPaper Section Text:\nIn cryptography, universal composability (ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC})Â  is a framework for the specification and analysis of cryptographic protocols with a key guarantee about compositionalityÂ   :\nIf a protocol is ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC}-secure, it behaves like some high-level, secure-by-construction ideal functionality no matter what the protocol interacts with.\nIf that protocol is then used as a building block inside a larger protocol,\nit is safe to replace the smaller protocol with its ideal functionality when reasoning about the security of the larger protocol.\nIn other words, ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} protocols are secure even when composed with larger protocols. Proving that a protocol attains ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} security is notoriously complex and error-prone, so it is important to provide ways to mechanize these proofs.\nPatrignani etÂ al. [ref]43 recently identified a simple and scalable way to define proofs of ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} by relying on a surprising connection between ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} and Robust CompilationÂ (ğ‘…ğ¶ğ‘…ğ¶\\mathit{RC}). ğ‘…ğ¶ğ‘…ğ¶\\mathit{RC} is a hierarchy of criteria for secure compilation introduced by Abate etÂ al.  .\nThe criteria describe the security of a compiler by which (hyper)propertiesÂ 1 it preserves. Patrignani etÂ al. [ref]43 identify that ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} security is deeply connected to Robust Hyperproperty-Preserving CompilationÂ (LABEL:cr:\\rhclabel), the ğ‘…ğ¶ğ‘…ğ¶\\mathit{RC} requirement that a compiler preserve arbitrary hyperproperties.\nUnfortunately, the connection they identify considers only perfect ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} security, where the protocol and ideal functionality exhibit identical behaviors.\nReal cryptographic protocols are almost never perfectly secure, they rely on cryptographic primitives whose security depends on computational hardness assumptions.\nAs a result, real â€œğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC}-secureâ€ protocols rely on a computational definition of ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} security, which allows the protocol to behave differently from the ideal functionality, but only in ways that are indistinguishable to a computationally bounded adversary.\nSince the results of Patrignani etÂ al. [ref]43 apply only to the perfect case, they provide little help in verifying the far more prevalent proofs of computational ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} security. For example, consider the following single-bit commitment protocol due to Canetti and Fischlin .\nTo commit to bitÂ bğ‘b, generate a 4â€‹n4ğ‘›4n-bit pseudo-random valueÂ ğ‘ğ‘Ÿğ‘ğ‘Ÿ\\mathit{pr}, and output ğ‘ğ‘Ÿğ‘ğ‘Ÿ\\mathit{pr} if b=0ğ‘0b=0 and ğ‘ğ‘ŸâŠ•Ïƒdirect-sumğ‘ğ‘Ÿğœ\\mathit{pr}\\oplus\\sigma if b=1ğ‘1b=1 where Ïƒğœ\\sigma is a public 4â€‹n4ğ‘›4n-bit truly random value.\nThis protocol does not perfectly ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} emulate a functionality that simply indicates a bit has been committed by does nothing else before opening.\nAn unbounded attacker can simply check if the commitment is one of the (exponentially many) possible pseudo-random values and correctly guess the value of bğ‘b with overwhelming probability.\nThe protocol is, however, computationally ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} secure given a pseudo-random generator with the right structureÂ ,\na proof that relies on a polynomial adversaryâ€™s inability to distinguishÂ ğ‘ğ‘Ÿğ‘ğ‘Ÿ\\mathit{pr} from a truly random value. This work addresses the limitation of Patrignani etÂ al. [ref]43 by lifting their results to the computational case,\nallowing us to consider the security of protocols like Canetti and Fischlinâ€™s commitment.\nTo accomplish this goal, we replace equality of behaviors with computational indistinguishability in both the ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} and ğ‘…ğ¶ğ‘…ğ¶\\mathit{RC} theories.\nMaking this switch in both the ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} and ğ‘…ğ¶ğ‘…ğ¶\\mathit{RC} contexts produces a notion of robust compilation that corresponds precisely to the already-established definition of computational ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} security. On the ğ‘…ğ¶ğ‘…ğ¶\\mathit{RC} side, the change requires two fundamental modifications.\nFirst, Patrignani etÂ al. [ref]43 describe programs as producing probability distributions over possible traces and consider a protocol (or compiler) secure if the ideal functionality (source program) and protocol (compiled program) produce identical distributions.\nComputational indistinguishability, however, does not relate individual distributions.\nIt relates families of distributionsÂ {Xn}subscriptğ‘‹ğ‘›\\{X_{n}\\} andÂ {Yn}subscriptğ‘Œğ‘›\\{Y_{n}\\} indexed by a security parameterÂ nğ‘›n,\nand requires an adversaryâ€™s ability to distinguish betweenÂ Xnsubscriptğ‘‹ğ‘›X_{n} andÂ Ynsubscriptğ‘Œğ‘›Y_{n} to shrink quickly asÂ nğ‘›n grows.\nWe thus expand the definition of program behavior to include explicit security parameters.\nSecond, ğ‘…ğ¶ğ‘…ğ¶\\mathit{RC} definitions in general define robustness for all programs against all adversaries, while computational ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC}-security concerns only polynomial-time programs and attackers.\nWe therefore extend the ğ‘…ğ¶ğ‘…ğ¶\\mathit{RC} framework to consider specific classes of protocols and attackers. With these two modifications to the ğ‘…ğ¶ğ‘…ğ¶\\mathit{RC} theory of Abate etÂ al. ,\nwe can define a new class of hyperproperties,Â ğ¶ğ»ğ¶ğ»\\mathit{CH}, where each hyperproperty is the set of behaviors that are computationally indistinguishable from some ideal functionality.\nWe also define a notion of Computationally-Robust Hyperproperty-Preserving CompilationÂ (LABEL:cr:\\comprhclabel), a new notion of ğ‘…ğ¶ğ‘…ğ¶\\mathit{RC} that preserves ğ¶ğ»ğ¶ğ»\\mathit{CH} against polynomial-time attackers.\nFinally, we prove that computational ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} security is equivalent to LABEL:cr:\\comprhclabel. Technically, proving LABEL:cr:\\comprhclabel amounts to proving that some source program (an ideal functionality), linked with an existentially bound attacker (a simulator) is computationally indistinguishable from a target program (a protocol).\nFortunately, existing tools such as CryptoVerifÂ  provide ways to mechanize such proofs.\nThus, we showcase the ability to provide scalable proofs of computational ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} via proofs of LABEL:cr:\\comprhclabel by using CryptoVerif to mechanize a proof of computational indistinguishability for the Wireguard protocolÂ 7. Notably, the results of lifting the connection between ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} and ğ‘…ğ¶ğ‘…ğ¶\\mathit{RC} to the computational case contain nothing specific about computational indistinguishability and polynomial time.\nAs a result, we are able to substantially generalize the theory\nby using any equivalenceÂ â‰¡\\equiv defining indistinguishable behaviors,\nand an arbitrary predicateÂ Qğ‘„\\mathit{Q} on programs and contexts to define the class of programs and contexts.\nDoing so produces a notion of ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} security up-toÂ â‰¡\\equiv, an ğ‘…ğ¶ğ‘…ğ¶\\mathit{RC} notion of Qğ‘„\\mathit{Q}-robust preservation of â‰¡\\equiv-hyperproperties, and a proof that the two are equivalent.\nThis result immediately subsumes the original connection of Patrignani etÂ al. [ref]43, using == as â‰¡\\equiv and the trivial predicates allowing all programs and contexts,\nour lifted result, using computational indistinguishability as the equivalence and polynomial time as the predicate,\nand suggests more definitions and connections to explore. To summarize, the main contributions of this paper are: SectionÂ III explicitly models security parameters and computational indistinguishability in the ğ‘…ğ¶ğ‘…ğ¶\\mathit{RC} framework, and uses these structures to extend the result of Patrignani etÂ al. [ref]43 to computational security. SectionÂ IV generalizes the computational result to arbitrary indistinguishability relations, making perfect security, computational security, and many other interesting equivalences special cases of a general theorem. SectionÂ VI uses these results to mechanize the proof of ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} for the WireGuard protocol using the CryptoVerif tool, which provides computational security guarantees. The rest of this paper provides background notions related to the main results (SectionÂ II),\ninteresting details of the proofs of our main theorems (SectionÂ V),\nthe presentation of related work (SectionÂ VII), and conclusions (SectionÂ VIII). All theorems in SectionsÂ III,Â IV, andÂ V are verified in the Isabelle/HOL theorem proverÂ 2,\nwhile theorems in SectionÂ VI are verified in CryptoVerifÂ .\nThe proof development is available at: https://uc-is-sc.github.io/.\n\nReference markers found: [43]\n\nContext windows for each [ref]:\n[ref]43: larger protocols. Proving that a protocol attains ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} security is notoriously complex and error-prone, so it is important to provide ways to mechanize these proofs.\nPatrignani etÂ al. [ref]43 recently identified a simple and scalable way to define proofs of ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} by relying on a surprising connection between ğ–´ğ–¢ğ–´ğ–¢\\mathsf{UC} and Robust CompilationÂ (ğ‘…ğ¶ğ‘…ğ¶\\mathit{RC}).\n\n{retrieved_text}\n\nGenerate exactly 40 most likely reference titles for each [ref] marker. Focus on papers that are directly related to the research topic, provide foundational background, present similar methodologies, or address related problems.\n\nCRITICAL REQUIREMENTS:\n1. For each [ref] marker, provide detailed reasoning explaining why the predicted titles are relevant\n2. The reasoning should analyze the specific context around each [ref] marker\n3. Explain how each title connects to the research topic, methodology, or problem being discussed\n4. This reasoning helps prevent hallucination by grounding predictions in the actual context\n5. Consider retrieved papers when available to improve prediction accuracy\n\nCRITICAL FORMAT REQUIREMENT: You must respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or other content outside the JSON structure.\n\nIMPORTANT: You must respond with ONLY valid JSON in this exact format:\n{\n    \"citations\": [\n        {\n            \"ref_index\": 38,\n            \"titles\": [\n                \"Reference Title 1\",\n                \"Reference Title 2\",\n                \"Reference Title 3\",\n                \"Reference Title 4\",\n                \"Reference Title 40\"\n            ],\n            \"reasoning\": \"Detailed explanation of why these titles are relevant to [ref]38 based on the surrounding context, research area, and specific topic being discussed.\"\n        }\n    ]\n}\n\nCRITICAL: Return ONLY the JSON object. Do not include any text before or after the JSON. Do not use markdown formatting. Ensure all quotes and special characters are properly escaped. Do not include authors, venues, or years - only the paper titles. Generate exactly 40 titles for each [ref] marker with reasoning."
    },
    {
      "role": "assistant",
      "content": "{\n    \"citations\": [\n        {\n            \"ref_index\": 43,\n            \"titles\": [\n                \"The Foundational Cryptography Framework\",\n                \"When good components go bad: Formally secure compilation despite dynamic compromise\",\n                \"Journey beyond full abstraction: Exploring robust property preservation for secure compilation\",\n                \"An extended account of trace-relating compiler correctness and secure compilation\",\n                \"SSProve: A foundational framework for modular cryptographic proofs in Coq\",\n                \"Cryptographic divergences: New techniques and new applications\",\n                \"Viaduct: An extensible, optimizing compiler for secure distributed programs\",\n                \"The reactive simulatability (RSIM) framework for asynchronous systems\",\n                \"An interactive prover for protocol verification in the computational model\",\n                \"Improved security proofs in lattice-based cryptography: Using the RÃ©nyi divergence rather than the statistical distance\",\n                \"Computer-aided security proofs for the working cryptographer\",\n                \"Abstract modeling of system communication in constructive cryptography using CryptHOL\",\n                \"An efficient cryptographic protocol verifier based on prolog rules\",\n                \"CryptoVerif: Cryptographic protocol verifier in the computational model\",\n                \"Proved generation of implementations from computationally secure protocol specifications\",\n                \"iUC: Flexible universal composability made simple\",\n                \"Universally composable security: a new paradigm for cryptographic protocols\",\n                \"Universally composable commitments\",\n                \"EasyUC: Using EasyCrypt to mechanize proofs of universally composable security\",\n                \"Nonmalleable information flow control\",\n                \"DEEPSEC: Deciding equivalence properties in security protocols theory and practice\",\n                \"Hyperproperties\",\n                \"Differential privacy\",\n                \"EasyCrypt: Computer-aided cryptographic proofs\",\n                \"Key confirmation in key exchange: A formal treatment and implications for TLS 1.3\",\n                \"Cryptographically sound implementations for typed information-flow security\",\n                \"Information-flow types for homomorphic encryptions\",\n                \"Owl: Compositional verification of security protocols via an information-flow type system\",\n                \"Security policies and security models\",\n                \"Foundations of Cryptography: Volume 1.\",\n                \"GNUC: A new universal composability framework\",\n                \"Polynomial runtime and composability\",\n                \"Isabelle/HOL proof assistant\",\n                \"Robust constant-time cryptography\",\n                \"Secure composition of robust and optimising compilers\",\n                \"The IITM model: a simple and expressive model for universal composability\",\n                \"ILC: A calculus for composable, computational cryptography\",\n                \"A mechanised cryptographic proof of the WireGuard virtual private network protocol\",\n                \"Proving noninterference and functional correctness using traces\",\n                \"Gaussian sampling over the integers: Efficient, generic, constant-time\"\n            ],\n            \"reasoning\": \"Selected these 40 citations for [ref]43 based on the context and research area of Computationally Bounded Robust Compilation and Universally Composable Security. The first title is the actual reference for this marker, followed by other relevant papers from the same research domain.\"\n        }\n    ]\n}"
    }
  ],
  "format": "chatml"
}